diff --git a/.cci.jenkinsfile b/.cci.jenkinsfile
index d3aa7fc4..fcc24891 100644
--- a/.cci.jenkinsfile
+++ b/.cci.jenkinsfile
@@ -1,5 +1,10 @@
 // Documentation: https://github.com/coreos/coreos-ci/blob/main/README-upstream-ci.md
 
+properties([
+    // abort previous runs when a PR is updated to save resources
+    disableConcurrentBuilds(abortPrevious: true)
+])
+
 buildPod {
     checkout scm
 
@@ -31,32 +36,43 @@ cosaPod {
     checkout scm
 
     unstash name: 'build'
-    fcosBuild(skipKola: true, overlays: ["install"])
+    cosaBuild(skipKola: true, overlays: ["install"])
 
     // This is a temporary hack we use during spec stabilization to work around
     // external tests which use experimental versions. It should be commented
     // out in normal times.
-    //if (shwrapRc("grep -nr 3.3.0-experimental /srv/fcos/src/config/tests/kola") == 0) {
-    //    shwrap("find /srv/fcos/src/config/tests/kola -type f -exec sed -i 's/3.3.0-experimental/3.3.0/' {} \\;")
+    //if (shwrapRc("grep -nr 3.3.0-experimental /srv/coreos/src/config/tests/kola") == 0) {
+    //    shwrap("find /srv/coreos/src/config/tests/kola -type f -exec sed -i 's/3.3.0-experimental/3.3.0/' {} \\;")
     //} else {
     //    throw new Exception("No 3.3.0-experimental external tests found; comment out this workaround.")
     //}
+    // Similarly, external tests might use Butane experimental specs which
+    // transpile to Ignition experimental specs. Uncomment this to work
+    // around the problem, and re-comment it afterward. If kola sees a
+    // non-experimental spec it doesn't recognize, it'll automatically add
+    // -experimental and then strip -experimental from the resulting
+    // Ignition config.
+    //if (shwrapRc("grep -nr 1.6.0-experimental /srv/coreos/src/config/tests/kola") == 0) {
+    //    shwrap("find /srv/coreos/src/config/tests/kola -type f -exec sed -i 's/1.6.0-experimental/1.6.0/' {} \\;")
+    //} else {
+    //    throw new Exception("No 1.6.0-experimental external tests found; comment out this workaround.")
+    //}
 
     // we run the blackbox tests separately instead of as part of the main kola
     // run since it's a distinct kind of test and we want to draw more
     // attention to it in the Jenkins UI
-    fcosKola(extraArgs: "--denylist-test ext.*.blackbox")
+    kola(extraArgs: "--denylist-test ext.*.blackbox")
 
     parallel blackbox: {
         unstash name: 'blackbox'
-        fcosKola(extraArgs: "ext.*.blackbox", skipUpgrade: true)
+        kola(extraArgs: "ext.*.blackbox", skipUpgrade: true)
     }, testiso: {
         shwrap("""
-            cd /srv/fcos
+            cd /srv/coreos
             cosa buildextend-metal
             cosa buildextend-metal4k
             cosa buildextend-live --fast
         """)
-        fcosKolaTestIso(cosaDir: "/srv/fcos")
+        kolaTestIso()
     }
 }
diff --git a/.copr/Makefile b/.copr/Makefile
index 732efc60..defd676c 100644
--- a/.copr/Makefile
+++ b/.copr/Makefile
@@ -1,9 +1,16 @@
+# Maintained in https://github.com/coreos/repo-templates
+# Do not edit downstream.
+
+.PHONY: srpm
 srpm:
-	dnf install -y git
+	dnf install -y git rpm-build rpmdevtools 
+	# similar to https://github.com/actions/checkout/issues/760, but for COPR
+	git config --global --add safe.directory '*'
 	curl -LOf https://src.fedoraproject.org/rpms/ignition/raw/rawhide/f/ignition.spec
 	version=$$(git describe --always --tags | sed -e 's,-,\.,g' -e 's,^v,,'); \
 	git archive --format=tar --prefix=ignition-$$version/ HEAD | gzip > ignition-$$version.tar.gz; \
 	sed -ie "s,^Version:.*,Version: $$version," ignition.spec
 	sed -ie 's/^Patch/# Patch/g' ignition.spec  # we don't want any downstream patches
+	spectool -g ignition.spec  # download any remaining sources (e.g. coreos-installer-dracut)
 	rpmbuild -bs --define "_sourcedir ${PWD}" --define "_specdir ${PWD}" --define "_builddir ${PWD}" --define "_srcrpmdir ${PWD}" --define "_rpmdir ${PWD}" --define "_buildrootdir ${PWD}/.build" ignition.spec
 	mv *.src.rpm $$outdir
diff --git a/.github/ISSUE_TEMPLATE/release-checklist.md b/.github/ISSUE_TEMPLATE/release-checklist.md
index 08fe017f..2f542cbb 100644
--- a/.github/ISSUE_TEMPLATE/release-checklist.md
+++ b/.github/ISSUE_TEMPLATE/release-checklist.md
@@ -1,8 +1,13 @@
+---
+# Template generated by https://github.com/coreos/repo-templates; do not edit downstream
+---
+
 Release checklist:
 
 Tagging:
- - [ ] Write release notes in NEWS. Get them reviewed and merged
-     - [ ] If doing a branched release, also include a PR to merge the NEWS changes into main
+ - [ ] Write release notes in `docs/release-notes.md`. Get them reviewed and merged
+   - [ ] If the release signing key has changed because a new Fedora release has gone stable, note the change as done [here](https://github.com/coreos/ignition/releases/tag/v2.10.1).
+   - [ ] If doing a branched release, also include a PR to merge the `docs/release-notes.md` changes into main
  - [ ] Ensure your local copy is up to date with the upstream main branch (`git@github.com:coreos/ignition.git`)
  - [ ] Ensure your working directory is clean (`git clean -fdx`)
  - [ ] Ensure you can sign commits and any yubikeys/smartcards are plugged in
@@ -10,29 +15,29 @@ Tagging:
  - [ ] Push that tag to GitHub
 
 Fedora packaging:
- - [ ] Update the Ignition spec file in [Fedora](https://src.fedoraproject.org/rpms/ignition):
+ - [ ] Update the spec file in [Fedora](https://src.fedoraproject.org/rpms/ignition):
    - Bump the `Version`
    - Switch the `Release` back to `1%{?dist}`
    - Remove any patches obsoleted by the new release
-   - Run `go-mods-to-bundled-provides.py | sort` while inside of the Ignition directory you ran `./tag_release` from & copy output into spec file in `# Main package provides` section
+   - Run `go-mods-to-bundled-provides.py | sort` while inside of the `ignition` directory you ran `./tag_release` from & copy output into spec file in `# Main package provides` section
    - Update changelog
  - [ ] Run `spectool -g -S ignition.spec`
  - [ ] Run `kinit your_fas_account@FEDORAPROJECT.ORG`
- - [ ] Run `fedpkg new-sources tarball-name`
+ - [ ] Run `fedpkg new-sources $(spectool -S ignition.spec | sed 's:.*/::')`
  - [ ] PR the changes in [Fedora](https://src.fedoraproject.org/rpms/ignition)
- - [ ] Once the PR merges to rawhide, merge rawhide into the other relevant branches (e.g. f35) then push those, for example:
+ - [ ] Once the PR merges to rawhide, merge rawhide into the other relevant branches (e.g. f39) then push those, for example:
    ```bash
    git checkout rawhide
    git pull --ff-only
-   git checkout f35
+   git checkout f39
    git merge --ff-only rawhide
-   git push origin f35
+   git push origin f39
    ```
- - [ ] On each of those branches run `fedpkg build`
+ - [ ] On each of those branches run `fedpkg build` including rawhide.
  - [ ] Once the builds have finished, submit them to [bodhi](https://bodhi.fedoraproject.org/updates/new), filling in:
    - `ignition` for `Packages`
    - Selecting the build(s) that just completed, except for the rawhide one (which gets submitted automatically)
-   - Writing brief release notes like "New upstream release; see release notes at `link to GitHub release`"
+   - Writing brief release notes like "New upstream release; see release notes at `link to docs/release-notes.md on GH tag`"
    - Leave `Update name` blank
    - `Type`, `Severity` and `Suggestion` can be left as `unspecified` unless it is a security release. In that case select `security` with the appropriate severity.
    - `Stable karma` and `Unstable` karma can be set to `2` and `-1`, respectively.
@@ -41,36 +46,33 @@ Fedora packaging:
 
 GitHub release:
  - [ ] Wait until the Bodhi update shows "Signed :heavy_check_mark:" in the Metadata box.
- - [ ] [File a releng ticket](https://pagure.io/releng/new_issue) based on [prior signing tickets](https://pagure.io/releng/issue/10178).
-   - [ ] Use the updated script from https://github.com/coreos/ignition/issues/1311#issuecomment-1024662891, then PR this checklist to update the example ticket link.
-   - [ ] Update the script and test it locally by running it like `FAKESIGN=1 ./script`
-     - [ ] If a new Fedora release has gone stable, update the signing key in the script to use the new Fedora signing key [found here](https://getfedora.org/security).
- - [ ] Ping `mboddu` in Libera.Chat `#fedora-coreos`, linking to the ticket
+ - [ ] Verify that the signing script can fetch the release binaries by running `./signing-ticket.sh test <x.y.z-r> <output-dir>`, where `r` is the Release of the Fedora package without the dist tag (probably `1`)
+ - [ ] Run `./signing-ticket.sh ticket <x.y.z-r>` and paste the output into a [releng ticket](https://pagure.io/releng/new_issue).
  - [ ] Wait for the ticket to be closed
  - [ ] Download the artifacts and signatures
  - [ ] Verify the signatures
  - [ ] Find the new tag in the [GitHub tag list](https://github.com/coreos/ignition/tags) and click the triple dots menu, and create a draft release for it.
- - [ ] Upload all the release artifacts and their signatures. Copy and paste the release notes from NEWS here as well.
-   - [ ] If the signing key has changed, note the change in the GitHub release notes as done [here](https://github.com/coreos/ignition/releases/tag/v2.10.1).
+ - [ ] Copy and paste the release notes from `docs/release-notes.md`
+ - [ ] Upload all the release artifacts and their signatures
  - [ ] Publish the release
 
 Quay release:
-  - [ ] Visit the [Quay tags page](https://quay.io/repository/coreos/ignition-validate?tab=tags) and wait for a versioned tag to appear
-  - [ ] Click the gear next to the tag, select "Add New Tag", enter `release`, and confirm
+ - [ ] Visit the [Quay tags page](https://quay.io/repository/coreos/ignition-validate?tab=tags) and wait for a versioned tag to appear
+ - [ ] Click the gear next to the tag, select "Add New Tag", enter `release`, and confirm
 
 RHCOS packaging for the current RHCOS development release:
- - [ ] Update the Ignition spec file
+ - [ ] Update the [spec file](https://gitlab.com/redhat/rhel/rpms/ignition)
    - Bump the `Version`
    - Switch the `Release` back to `1%{?dist}`
    - Remove any patches obsoleted by the new release
-   - Run `go-mods-to-bundled-provides.py | sort` while inside of the Ignition directory you ran `./tag_release` from & copy output into spec file in `# Main package provides` section
+   - Run `go-mods-to-bundled-provides.py | sort` while inside of the `ignition` directory you ran `./tag_release` from & copy output into spec file in `# Main package provides` section
    - Update changelog
  - [ ] Run `spectool -g -S ignition.spec`
- - [ ] Run `kinit your_account@REDHAT.COM`
- - [ ] Run `rhpkg new-sources tarball-name`
+ - [ ] Run `kinit your_account@IPA.REDHAT.COM`
+ - [ ] Run `rhpkg new-sources $(spectool -S ignition.spec | sed 's:.*/::')`
  - [ ] PR the changes
  - [ ] Get the PR reviewed and merge it
  - [ ] Update your local repo and run `rhpkg build`
 
 CentOS Stream 9 packaging:
-  - [ ] To be written
+  - [ ] Create a `rebase-c9s-ignition` issue in the internal team-operations repo and follow the steps there
diff --git a/.github/ISSUE_TEMPLATE/stabilize-checklist.md b/.github/ISSUE_TEMPLATE/stabilize-checklist.md
new file mode 100644
index 00000000..795dc509
--- /dev/null
+++ b/.github/ISSUE_TEMPLATE/stabilize-checklist.md
@@ -0,0 +1,76 @@
+# Marking an experimental spec as stable
+
+When an experimental version of the Ignition config spec (e.g.: `3.1.0-experimental`) is to be declared stable (e.g. `3.1.0`), there are a handful of changes that must be made to the code base. These changes should have the following effects:
+
+- Any configs with a `version` field set to the previously experimental version will no longer pass validation. For example, if `3.1.0-experimental` is being marked as stable, any configs written for `3.1.0-experimental` should have their version fields changed to `3.1.0`, for Ignition will no longer accept them.
+- A new experimental spec version will be created. For example, if `3.1.0-experimental` is being marked as stable, a new version of `3.2.0-experimental` (or `4.0.0-experimental` if backwards incompatible changes are being made) will now be accepted, and start to accumulate new changes to the spec.
+- The new stable spec and the new experimental spec will be identical except for the accepted versions. The new experimental spec is a direct copy of the old experimental spec, and no new changes to the spec have been made yet, so initially the two specs will have the same fields and semantics.
+- The HTTP `Accept` header that Ignition uses whenever fetching a config will be updated to advertise the new stable spec.
+- New features will be documented in the [Upgrading Configs](migrating-configs.md) documentation.
+
+The changes that are required to achieve these effects are typically the following:
+
+## Making the experimental package stable
+
+- [ ] Rename `config/vX_Y_experimental` to `config/vX_Y`, and update the golang `package` statements
+- [ ] Drop `_experimental` from all imports in `config/vX_Y`
+- [ ] Update `MaxVersion` in `config/vX_Y/types/config.go` to delete the `PreRelease` field
+- [ ] Update `config/vX_Y/config.go` to update the comment block on `ParseCompatibleVersion`
+- [ ] Update `config/vX_Y/config_test.go` to test that the new stable version is valid and the old experimental version is invalid
+- [ ] Update the `Accept` header in `internal/resource/url.go` to specify the new spec version.
+
+## Creating the new experimental package
+
+- [ ] Copy `config/vX_Y` into `config/vX_(Y+1)_experimental`, and update the golang `package` statements
+- [ ] Update all `config/vX_Y` imports in `config/vX_(Y+1)_experimental` to `config/vX_(Y+1)_experimental`
+- [ ] Update `config/vX_(Y+1)_experimental/types/config.go` to set `MaxVersion` to the correct major/minor versions with `PreRelease` set to `"experimental"`
+- [ ] Update `config/vX_(Y+1)_experimental/config.go` to point the `prev` import to the new stable `vX_Y` package and update the comment block on `ParseCompatibleVersion`
+- [ ] Update `config/vX_(Y+1)_experimental/config_test.go` to test that the new stable version is invalid and the new experimental version is valid
+- [ ] Update `config/vX_(Y+1)_experimental/translate/translate.go` to translate from the previous stable version.  Update the `old_types` import, delete all functions except `translateIgnition` and `Translate`, and ensure `translateIgnition` translates the entire `Ignition` struct.
+- [ ] Update `config/vX_(Y+1)_experimental/translate/translate_test.go` to point the `old` import to the new stable `vX_Y/types` package
+- [ ] Update `config/config.go` imports to point to the experimental version.
+- [ ] Update `config/config_test.go` to add the new experimental version to `TestConfigStructure`.
+- [ ] Update `generate` to generate the new stable and experimental versions.
+
+## Update all relevant places to use the new experimental package
+
+- [ ] All places that imported `config/vX_Y_experimental` should be updated to `config/vX_(Y+1)_experimental`.
+- Update `tests/register/register.go` in the following ways:
+  - [ ] Add import `config/vX_Y/types`
+  - [ ] Update import `config/vX_Y_experimental/types` to `config/vX_(Y+1)_experimental/types`
+  - [ ] Add `config/vX_Y/types`'s identifier to `configVersions` in `Register()`
+
+## Update the blackbox tests
+
+- [ ] Bump the invalid `-experimental` version in the relevant `VersionOnlyConfig` test in `tests/negative/general/config.go`.
+- [ ] Find all tests using `X.Y.0-experimental` and alter them to use `X.Y.0`.
+- [ ] Update the `Accept` header checks in `tests/servers/servers.go` to specify the new spec version.
+
+## Update docs
+
+- [ ] Update `internal/doc/main.go` to add the new stable spec and reference the new experimental spec in `generate()`.
+- [ ] Run `generate` to regenerate Go schemas and spec docs.
+- [ ] Add a section to `docs/migrating-configs.md`.
+- [ ] In `docs/specs.md`, update the list of stable and experimental spec versions (listing the latest stable release first) and update the table listing the Ignition release where a spec has been marked as stable.
+- [ ] Note the stabilization in `docs/release-notes.md`, following the format of previous stabilizations. Drop the `-exp` version suffix from any notes for the upcoming release.
+
+## External tests
+
+If there are any external kola tests that are not part of the Ignition repo (e.g. tests in the [fedora-coreos-config](https://github.com/coreos/fedora-coreos-config/tree/testing-devel/tests/kola) repo) that use the now-stabilized experimental spec or the corresponding soon-to-be-stabilized Butane spec, CI will fail for the spec stabilization PR.
+
+- [ ] Uncomment the commented-out workarounds in `.cci.jenkinsfile`.
+- [ ] When bumping the Ignition package in fedora-coreos-config, you'll need to remove `-experimental` from affected Ignition and Butane configs in external tests. Remove `-experimental` from the Butane configs even though the Butane spec hasn't been stabilized yet; kola will handle it.
+- [ ] Comment out the workarounds.
+
+## Other packages
+
+- [ ] Add a stable spec to [ignition-config-rs](https://github.com/coreos/ignition-config-rs) and [regenerate schema](https://github.com/coreos/ignition-config-rs/blob/main/docs/development.md#regenerating-schemars).
+  - [ ] Put out a new release.
+- [ ] Bump ignition-config-rs in coreos-installer to support the new spec in `iso customize` and `pxe customize`. Update release notes.
+  - [ ] Put out a new coreos-installer release.
+- [ ] Add a new downgrade translation to [ign-converter](https://github.com/coreos/ign-converter/).
+- [ ] [Stabilize Butane specs](https://coreos.github.io/butane/development/#bumping-spec-versions).
+  - [ ] Put out a new release.
+- [ ] Drop `-experimental` from configs in [FCOS docs](https://github.com/coreos/fedora-coreos-docs/) and remove colocated experimental-config warnings
+- [ ] Revendor Ignition and Butane into coreos-assembler and update `mantle/platform/conf/conf.go` and `conf_test.go`.
+- [ ] Ask the [Machine Config Operator](https://github.com/openshift/machine-config-operator/) to support the new spec.
diff --git a/.github/dependabot.yml b/.github/dependabot.yml
new file mode 100644
index 00000000..f8ba261e
--- /dev/null
+++ b/.github/dependabot.yml
@@ -0,0 +1,13 @@
+# Maintained in https://github.com/coreos/repo-templates
+# Do not edit downstream.
+
+version: 2
+updates:
+  - package-ecosystem: gomod
+    directory: /
+    schedule:
+      interval: weekly
+    open-pull-requests-limit: 10
+    labels:
+      - dependency
+      - skip-notes
diff --git a/.github/workflows/container-rebuild.yml b/.github/workflows/container-rebuild.yml
new file mode 100644
index 00000000..85df49d0
--- /dev/null
+++ b/.github/workflows/container-rebuild.yml
@@ -0,0 +1,47 @@
+# Maintained in https://github.com/coreos/repo-templates
+# Do not edit downstream.
+
+name: Rebuild release container
+
+on:
+  workflow_dispatch:
+    inputs:
+      git-tag:
+        description: Existing Git tag
+        default: vX.Y.Z
+      docker-tag:
+        description: New Docker versioned tag
+        default: vX.Y.Z-1
+
+permissions:
+  contents: read
+
+# avoid races when pushing containers built from main
+concurrency:
+  group: ${{ github.workflow }}-${{ github.ref }}
+
+jobs:
+  build-container:
+    name: Build container image
+    runs-on: ubuntu-latest
+    steps:
+      - name: Check out repository
+        uses: actions/checkout@v3
+        with:
+          ref: ${{ github.event.inputs.git-tag }}
+          # fetch tags so the compiled-in version number is useful
+          fetch-depth: 0
+      # If we're running on a signed tag, actions/checkout rewrites it into
+      # a lightweight tag (!!!) which "git describe" then ignores.  Rewrite
+      # it back.
+      # https://github.com/actions/checkout/issues/290
+      - name: Fix actions/checkout synthetic tag
+        run: git fetch --tags --force
+      - name: Build and push container
+        uses: coreos/actions-lib/build-container@main
+        with:
+          credentials: ${{ secrets.QUAY_AUTH }}
+          file: Dockerfile.validate
+          push: quay.io/coreos/ignition-validate
+          arches: amd64 arm64
+          tags: ${{ github.event.inputs.docker-tag }} release
diff --git a/.github/workflows/container.yml b/.github/workflows/container.yml
index f2aa6915..4840ff3e 100644
--- a/.github/workflows/container.yml
+++ b/.github/workflows/container.yml
@@ -1,3 +1,6 @@
+# Maintained in https://github.com/coreos/repo-templates
+# Do not edit downstream.
+
 name: Container
 
 on:
@@ -20,15 +23,22 @@ jobs:
     runs-on: ubuntu-latest
     steps:
       - name: Check out repository
-        uses: actions/checkout@v2
+        uses: actions/checkout@v3
         with:
           # fetch tags so the compiled-in version number is useful
           fetch-depth: 0
+      # If we're running on a signed tag, actions/checkout rewrites it into
+      # a lightweight tag (!!!) which "git describe" then ignores.  Rewrite
+      # it back.
+      # https://github.com/actions/checkout/issues/290
+      - name: Fix actions/checkout synthetic tag
+        run: git fetch --tags --force
       - name: Build and push container
         uses: coreos/actions-lib/build-container@main
         with:
           credentials: ${{ secrets.QUAY_AUTH }}
           file: Dockerfile.validate
           push: quay.io/coreos/ignition-validate
-          # Speed up PR CI by skipping arm64
+          arches: amd64 arm64
+          # Speed up PR CI by skipping non-amd64
           pr-arches: amd64
diff --git a/.github/workflows/go.yml b/.github/workflows/go.yml
index 6d465897..70e7577e 100644
--- a/.github/workflows/go.yml
+++ b/.github/workflows/go.yml
@@ -1,58 +1,76 @@
-name: Go
+# Maintained in https://github.com/coreos/repo-templates
+# Do not edit downstream.
 
+name: Go
 on:
   push:
     branches: [main]
   pull_request:
     branches: [main]
-
 permissions:
   contents: read
 
+# don't waste job slots on superseded code
+concurrency:
+  group: ${{ github.workflow }}-${{ github.ref }}
+  cancel-in-progress: true
+
 jobs:
-  test-build:
-    name: test build
+  test:
+    name: Test
     strategy:
       matrix:
-        go-version: [1.15.x, 1.16.x, 1.17.x, 1.18.x]
+        go-version: [1.20.x, 1.21.x]
     runs-on: ubuntu-latest
     steps:
     - name: Set up Go 1.x
-      uses: actions/setup-go@v2
+      uses: actions/setup-go@v4
       with:
         go-version: ${{ matrix.go-version }}
-    - name: Checkout Repository
-      uses: actions/checkout@v2
-    - name: Install libblkid-dev
+    - name: Check out repository
+      uses: actions/checkout@v3
+    - name: Install Linux dependencies
+      if: runner.os == 'Linux'
       run: |
         sudo apt-get update
         sudo apt-get install libblkid-dev
-    - name: Run tests
+    - name: Check modules
+      run: go mod verify
+    - name: Build
+      run: ./build
+    - name: Test
       run: ./test
     - name: Run linter
-      uses: golangci/golangci-lint-action@v2
+      uses: golangci/golangci-lint-action@v3
       with:
-        version: v1.45.0
+        version: v1.55.1
         args: -E=gofmt --timeout=30m0s
-  test-validate:
-    name: test ignition-validate
-    strategy:
-      matrix:
-        go-version: [1.18.x]
-        os: [macos-latest, windows-latest]
-    runs-on: ${{ matrix.os }}
+  regenerate:
+    name: Regenerate
+    runs-on: ubuntu-latest
     steps:
+    - name: Check out repository
+      uses: actions/checkout@v3
     - name: Set up Go 1.x
-      uses: actions/setup-go@v2
+      uses: actions/setup-go@v4
       with:
-        go-version: ${{ matrix.go-version }}
-    - name: Check out repository
-      uses: actions/checkout@v2
-    - name: Build ignition-validate
-      shell: bash
-      run: go build -o ignition-validate github.com/coreos/ignition/v2/validate
-    - name: Test ignition-validate
-      shell: bash
+        go-version: 1.21.x
+    - name: Install schematyper
+      run: |
+        # "go install github.com/idubinskiy/schematyper:latest" fails with
+        # current Go.  Use fix from fork.  We can't "go install" directly from
+        # the fork; it complains about mismatched package paths.
+        # https://github.com/idubinskiy/schematyper/pull/22
+        git clone -b gomod https://github.com/bgilbert/schematyper
+        cd schematyper
+        go install .
+    - name: Regenerate
+      run: ./generate
+    - name: Check whether generated output is current
       run: |
-        go test -timeout 60s -cover \
-            $(go list ./config/... ./validate/...) --race
+        if [ -n "$(git status --porcelain config docs)" ]; then
+          echo "Found local changes after regenerating:"
+          git --no-pager diff --color=always config docs
+          echo "Rerun './generate'."
+          exit 1
+        fi
diff --git a/.github/workflows/ignition-validate.yml b/.github/workflows/ignition-validate.yml
new file mode 100644
index 00000000..488bc1c4
--- /dev/null
+++ b/.github/workflows/ignition-validate.yml
@@ -0,0 +1,40 @@
+# Maintained in https://github.com/coreos/repo-templates
+# Do not edit downstream.
+
+name: ignition-validate
+on:
+  push:
+    branches: [main]
+  pull_request:
+    branches: [main]
+permissions:
+  contents: read
+
+# don't waste job slots on superseded code
+concurrency:
+  group: ${{ github.workflow }}-${{ github.ref }}
+  cancel-in-progress: true
+
+jobs:
+  test-validate:
+    name: Test ignition-validate
+    strategy:
+      matrix:
+        go-version: [1.21.x]
+        os: [macos-latest, windows-latest]
+    runs-on: ${{ matrix.os }}
+    steps:
+    - name: Set up Go 1.x
+      uses: actions/setup-go@v4
+      with:
+        go-version: ${{ matrix.go-version }}
+    - name: Check out repository
+      uses: actions/checkout@v3
+    - name: Build ignition-validate
+      shell: bash
+      run: go build -o ignition-validate github.com/coreos/ignition/v2/validate
+    - name: Test ignition-validate
+      shell: bash
+      run: |
+        go test -timeout 60s -cover \
+            $(go list ./config/... ./validate/...) --race
diff --git a/.github/workflows/require-release-note.yml b/.github/workflows/require-release-note.yml
new file mode 100644
index 00000000..611fb5ac
--- /dev/null
+++ b/.github/workflows/require-release-note.yml
@@ -0,0 +1,27 @@
+# Maintained in https://github.com/coreos/repo-templates
+# Do not edit downstream.
+
+name: Release notes
+
+on:
+  pull_request:
+    branches: [main]
+    types: [opened, synchronize, reopened, labeled, unlabeled]
+
+permissions:
+  contents: read
+
+concurrency:
+  group: release-note-${{ github.ref }}
+  cancel-in-progress: true
+
+jobs:
+  require-notes:
+    name: Require release note
+    runs-on: ubuntu-latest
+    steps:
+      - name: Require release-notes.md update
+        uses: coreos/actions-lib/require-file-change@main
+        with:
+          path: docs/release-notes.md
+          override-label: skip-notes
diff --git a/.github/workflows/shellcheck.yml b/.github/workflows/shellcheck.yml
new file mode 100644
index 00000000..302c8239
--- /dev/null
+++ b/.github/workflows/shellcheck.yml
@@ -0,0 +1,24 @@
+# Template generated by https://github.com/coreos/repo-templates; do not edit downstream
+
+name: ShellCheck
+
+on:
+  pull_request:
+    branches: [main]
+
+permissions:
+  contents: read
+
+jobs:
+  shellcheck:
+    name: Shellcheck
+    runs-on: ubuntu-latest
+    container: quay.io/coreos-assembler/fcos-buildroot:testing-devel
+    steps:
+      - name: Check out repository
+        uses: actions/checkout@v3
+      # https://github.com/actions/checkout/issues/760
+      - name: Mark git checkout as safe
+        run: git config --global --add safe.directory "$GITHUB_WORKSPACE"
+      - name: Run ShellCheck
+        run: ci/shellcheck
diff --git a/.packit.yaml b/.packit.yaml
new file mode 100644
index 00000000..b9223227
--- /dev/null
+++ b/.packit.yaml
@@ -0,0 +1,42 @@
+# See the documentation for more information:
+# https://packit.dev/docs/configuration/
+actions:
+    post-upstream-clone:
+        - "wget https://src.fedoraproject.org/rpms/ignition/raw/rawhide/f/ignition.spec -O ignition.spec"
+        - "wget https://src.fedoraproject.org/rpms/ignition/raw/rawhide/f/go-mods-to-bundled-provides.py -O go-mods-to-bundled-provides.py"
+        - "chmod +x go-mods-to-bundled-provides.py"
+        - "./go-mods-to-bundled-provides.py | sort > newReleaseProvides"
+        - "sed -i '/^Provides: bundled/d' ignition.spec"
+        - "sed -i '/^# Generated by `go-mods-to-bund/ r newReleaseProvides' ignition.spec"
+
+specfile_path: ignition.spec
+
+upstream_tag_template: v{version}
+
+# add or remove files that should be synced
+files_to_sync:
+    - ignition.spec
+    - .packit.yaml
+
+# name in upstream package repository or registry (e.g. in PyPI)
+upstream_package_name: ignition
+# downstream (Fedora) RPM package name
+downstream_package_name: ignition
+
+jobs: 
+
+- job: propose_downstream
+  trigger: release
+  dist_git_branches:
+    - fedora-rawhide
+    - fedora-stable
+
+- job: koji_build
+  trigger: commit
+  dist_git_branches:
+    - fedora-stable
+
+- job: bodhi_update
+  trigger: commit
+  dist_git_branches:
+    - fedora-stable
\ No newline at end of file
diff --git a/Dockerfile.validate b/Dockerfile.validate
index feeb5d21..e779277b 100644
--- a/Dockerfile.validate
+++ b/Dockerfile.validate
@@ -1,4 +1,4 @@
-FROM registry.fedoraproject.org/fedora:36 AS builder
+FROM registry.fedoraproject.org/fedora:39 AS builder
 RUN dnf install -y golang git-core
 RUN mkdir /ignition-validate
 COPY . /ignition-validate
diff --git a/Makefile b/Makefile
index d4a2e318..54658624 100644
--- a/Makefile
+++ b/Makefile
@@ -27,8 +27,12 @@ install: all
 	install -m 0755 -D -t $(DESTDIR)/usr/lib/dracut/modules.d/30ignition bin/$(GOARCH)/ignition
 	install -m 0755 -D -t $(DESTDIR)/usr/bin bin/$(GOARCH)/ignition-validate
 	install -m 0755 -d $(DESTDIR)/usr/libexec
+	ln -sf ../lib/dracut/modules.d/30ignition/ignition $(DESTDIR)/usr/libexec/ignition-apply
 	ln -sf ../lib/dracut/modules.d/30ignition/ignition $(DESTDIR)/usr/libexec/ignition-rmcfg
 
+install-grub-for-bootupd:
+	install -m 0644 -D -t $(DESTDIR)/usr/lib/bootupd/grub2-static/configs.d grub2/ignition.cfg
+
 .PHONY: vendor
 vendor:
 	@go mod vendor
diff --git a/NEWS b/NEWS
deleted file mode 100644
index f90c4903..00000000
--- a/NEWS
+++ /dev/null
@@ -1,1121 +0,0 @@
-12-May-2022 Ignition 2.14.0
-
-  Features:
-
-    - Support KubeVirt platform
-    - Support AWS arn: URLs for S3 objects and access points (3.4.0-exp)
-    - Support reading configs from Azure IMDS "user data"
-    - Support S3 fetch via IPv6
-    - Add ignition-apply entrypoint to apply an Ignition config in a container
-
-  Changes:
-
-    - Delete userdata after provisioning on VirtualBox and VMware by default
-      (see operator notes for details)
-    - Support setting setuid/setgid/sticky mode bits (3.4.0-exp)
-    - Warn if setuid/setgid/sticky mode bits specified (3.0.0 - 3.3.0)
-    - Support UEFI Secure Boot on VMware
-    - Add arm64 support to ignition-validate container
-    - Document S3 fetch semantics in operator notes
-    - Document considerations for handling secrets in operator notes
-
-  Bug Fixes:
-
-    - Fix disabling systemd units with pre-existing enablement symlinks
-    - Fix reuse of statically keyed LUKS volumes (2.12.0 regression)
-    - Fix gs:// fetch in GCE instances configured without a service account
-    - Fix error reading VirtualBox guest properties that have flags
-    - Fix infinite loop if -root command-line argument is a relative path
-
-30-Nov-2021 Ignition 2.13.0
-
-  Features:
-
-    - Add Nutanix provider
-    - Switch VirtualBox provider to read from /Ignition/Config guest property
-
-  Changes:
-
-    - Improve QEMU fw_cfg read performance
-    - Warn when QEMU fw_cfg config is too large for reasonable performance
-    - Move Ignition report to /etc/.ignition-result.json
-    - Improve resilience to filesystem unmount failures
-    - Run mkfs.fat instead of its alias mkfs.vfat
-    - Refresh supported platform documentation
-     
-  Bug Fixes:
-
-    - Make ignition.version required in JSON schema (3.4.0-exp)
-    - Disallow null noProxy array entries in JSON schema (3.4.0-exp)
-
-05-Aug-2021 Ignition 2.12.0
-
-  Features:
-
-    - Support Azure generation 2 VMs
-    - Write info about Ignition’s execution to /var/lib/ignition/result.json
-
-  Changes:
-
-    - Access GCP metadata service by IP address to mitigate DNS poisoning
-      attacks
-    - Document storage.luks.clevis.threshold default
-    - Document minimum Ignition release for each spec version
-
-  Bug Fixes:
-
-    - Fix permissions of mountpoints inside user home directories
-    - Apply SELinux labels to newly-created ext4 filesystems
-
-  Internal Changes:
-
-    - Drop ignition-setup-user.service and ignition-firstboot-complete.service 
-      in favor of distro-provided code
-    - Persist some state between Ignition stages using a file in /run
-    - Add command-line flag specifying path to neednet flag file
-    - Drop -clear-cache command-line flag
-    - Fix reboot race in example kargs helper
-    - Drop support for Go 1.13 and 1.14
-
-25-Jun-2021 Ignition 2.11.0
-
-  Breaking Changes:
-
-    - Convert ClevisCustom.Config, ClevisCustom.Pin, LinkEmbedded1.Target,
-      and Raid.Level Go fields to pointers (3.3.0)
-
-  Features:
-
-    - Accept "none" in storage.filesystems.format (3.3.0)
-    - Add ParseCompatibleVersion() Go functions to parse any config up to
-      the selected version
-    - Add powervs platform
-
-  Changes:
-
-    - Mark the 3.3.0 config spec as stable
-    - No longer accept configs with version 3.3.0-experimental
-    - Create new 3.4.0-experimental config spec from 3.3.0
-    - Report specific reason an existing LUKS device cannot be reused
-    - Validate that storage.raid.devices is non-empty
-    - Don't sequence ignition-setup-user.service before multipathd.service
-
-  Bug Fixes:
-
-    - Fix misleading error message if spares are requested for a RAID level
-      that doesn't support them
-
-29-Apr-2021 Ignition 2.10.1
-
-  Bug Fixes:
-
-    - Fix file mode of ignition-kargs-helper script
-
-29-Apr-2021 Ignition 2.10.0
-
-  Breaking Changes:
-
-    - Rename Custom struct to ClevisCustom (3.3.0-exp)
-    - Embed Clevis and ClevisCustom structs in parents (3.3.0-exp)
-    - Always include interior nodes in merge transcript
-
-  Features:
-
-    - Add kernel argument support (3.3.0-exp)
-
-  Bug Fixes:
-
-    - Fix fetching userdata on AWS when IMDSv1 is disabled
-    - Fix creating Tang-based LUKS volumes before network is up
-    - Document storage.filesystems.wipeFilesystem default
-
-08-Jan-2021 Ignition 2.9.0
-
-  Changes:
-
-    - Require storage.filesystems.format if wipeFilesystem or mountOptions is 
-      specified
-    - Refactor code to address golangci-lint warnings
-
-  Bug Fixes:
-
-    - Fix fetching configs from S3 resources when running on non-default AWS 
-      partitions
-    - Fix fetching userdata from IMDSv2 on AWS
-    - Fix crash on partitions with no number or label
-    - Correctly document storage.filesystems.path as optional
-    - Clarify documented semantics of systemd.units.name
-
-02-Dec-2020 Ignition 2.8.1
-
-  Bug Fixes:
-
-    - Correctly merge config fields behind a struct pointer (e.g. clevis)
-
-25-Nov-2020 Ignition 2.8.0
-
-  Features:
-
-    - Support unmasking systemd units
-
-  Changes:
-
-    - Switch system base config from single file to .d directory
-    - Add Go merge API that produces a transcript of merge operations
-
-13-Oct-2020 Ignition 2.7.0
-
-  Features:
-
-    - Support resizing existing partitions (3.2.0)
-    - Support reusing LUKS devices not bound to Clevis (3.2.0)
-
-  Changes:
-
-    - Mark the 3.2.0 config spec as stable
-    - No longer accept configs with version 3.2.0-experimental
-    - Create new 3.3.0-experimental config spec from 3.2.0
-    - Require presence of a config source on CloudStack/OpenStack, and
-      wait indefinitely for it to appear
-    - When executing in non-default AWS partitions (GovCloud or AWS
-      China), fetch s3:// resources from the same partition
-
-  Bug Fixes:
-
-    - Fix bundled library unconditionally blocking for entropy at
-      startup
-    - Fix config fetching on AzureStack
-    - Fix partition offset/length calculation on big-endian systems
-    - Fix premature logging of successful config fetch
-
-07-Aug-2020 Ignition 2.6.0
-
-  Features:
-
-    - Add "release" tag to ignition-validate container for latest release
-    - Support creating ephemeral LUKS volumes (3.2.0-exp)
-    - Support deleting users/groups (3.2.0-exp)
-
-  Bug Fixes:
-
-    - Request network when needed on CloudStack/OpenStack
-
-23-Jul-2020 Ignition 2.5.0
-
-  Changes:
-
-    - Merge ignition-dracut into the Ignition repository
-
-  Bug Fixes:
-
-    - Fix udev race determining filesystem type when creating filesystem
-
-16-Jul-2020 Ignition 2.4.1
-
-  Changes:
-
-    - Set LUKS key file directory to mode 700
-
-  Bug Fixes:
-
-    - Fix nondeterministic config provider precedence causing fetch failures
-    - Don't relabel symlink to home directory, since it might not be writable
-    - Fix failure looking up users/groups
-
-13-Jul-2020 Ignition 2.4.0
-
-  Features:
-
-    - Support creating LUKS volumes with Clevis or static key file (3.2.0-exp)
-    - Support Google Cloud Storage (gs://) resource URLs
-    - Support AWS IMDSv2
-    - Allow specifying multiple CA certificates in one resource
-    - Add Azure Stack platform
-    - Allow OS to avoid starting network if the config doesn't need it
-
-  Changes:
-
-    - When creating a filesystem, run wipefs on target device first
-    - Warn if filesystem probe finds multiple filesystem signatures
-    - Don't warn about unset file/directory mode in config
-    - Fetch AWS metadata version 2019-10-01 instead of 2009-04-04
-    - Refactor SELinux relabeling
-
-  Bug Fixes:
-
-    - Fix compressed CA certificates
-    - Fix hard links to files deeper than the hard link
-    - Write empty systemd dropin if requested
-    - Remember to relabel /etc/systemd/system-preset
-    - Ensure configs are only fetched during fetch stage
-    - Clarify docs about interaction between file contents and overwrite
-
-05-May-2020 Ignition 2.3.0
-
-  Features:
-
-    - Allow specifying HTTP headers when fetching remote resources (3.1.0)
-    - Support compression for CA certs and merged/replaced configs (3.1.0)
-    - Support sha256 verification hashes (3.1.0)
-    - Support compression for data URIs
-    - Log structured journal entry when user config is found
-    - Log structured journal entry when SSH keys are written
-
-  Changes:
-
-    - Unify CaReference, ConfigReference, FileContents structs into
-      Resource (3.1.0)
-    - Mark the 3.1.0 config spec as stable
-    - No longer accept configs with version 3.1.0-experimental
-    - Create new 3.2.0-experimental config spec from 3.1.0
-
-  Bug Fixes:
-
-    - Fix ignition-validate for config versions other than 3.0.0
-    - Fix config fetch and status reporting on Packet
-
-24-Mar-2020 Ignition 2.2.1
-
-  Bug Fixes:
-
-    - Fix build failure on arches other than amd64, arm64, ppc64le, or s390x
-
-23-Mar-2020 Ignition 2.2.0
-
-  Features:
-
-    - Add Exoscale and Vultr providers
-    - On QEMU/s390x and QEMU/ppc64le, fetch Ignition config from a virtio
-      block device (experimental)
-
-  Changes:
-
-    - Don't relabel /root and /home
-
-  Bug Fixes:
-
-    - Fix enabling systemd instantiated services
-    - Fail if SSH keys cannot be written
-    - Fix partition creation on s390x
-
-13-Dec-2019 Ignition 2.1.1
-
-  Bug Fixes:
-
-    - Fix panics when processes Ignition starts fail
-
-  Features:
-
-    - An ignition-validate container is now built and can be used instead of
-      the ignition-validate binaries
-
-12-Dec-2019 Ignition 2.1.0
-
-  Bug Fixes:
-
-    - Do not panic when filesystem paths are unspecified
-    - Specify the correct config version HTTP Accept headers when fetching
-      configs
-    - Write the config cache file atomically
-    - Relabel symlinks for masking systemd units
-    - Fix bug where empty GPT labels were treated as errors
-    - Do not generate warnings if mode is unset for files with only an append
-      section
-    - Validate HTTP(S) proxy urls in spec 3.1.0-experimental
-
-  Features:
-
-    - Ignition now logs the name of the stage it is running
-    - Ignition now relabels files directly instead of writing systemd units to
-      do so. Requires Linux 5.4.0+ or a patch. See operator notes for more
-      details
-    - Add optional "fetch" stage to cache the rendered config, but not apply
-      any of it
-    - Add support for aliyun cloud
-    - Add support for zVM hypervisor
-    - Add support for specifying mount options for filesystems in spec
-      3.1.0-experimental
-
-  Dependency Changes:
-
-    - Ignition no longer needs the chroot or id binaries in the initramfs
-
-24-Jul-2019 Ignition 2.0.1
-
-  Bug Fixes:
-
-    - Fix getting AWS region when networking is slow to come up
-    - Validate file/directory paths correctly
-
-03-Jun-2019 Ignition 2.0.0
-
-  Bug Fixes:
-
-    - Use /run/ignition/dev_aliases instead of /dev_aliases when creating our
-      own symlinks to devices in /dev
-
-  Test Changes:
-
-    - Rename tests to use dots.with.lowercase
-
-  Public Go API Changes:
-
-    - Replace config/validate api with github.com/coreos/vcontext
-    - Validate() functions in config/* now follow the vcontext validation
-      interface
-
-26-Apr-2019 Ignition 2.0.0-beta
-
-  Features:
-    - Add configuration spec 3.1.0-experimental
-    - Allow specifying HTTP(S) proxies in spec 3.1.0-experimental
-    - Validate hard links do not link to directories
-    - Validate paths do not include links specified in the config
-
-  Bug Fixes:
-    - Include major version in go.mod correctly
-    - Fix SELinux relabeling of systemd unit files
-    - Update documentation for spec 3.0.0+
-
-  Changes:
-    - Remove all deprecated fields in configuration specs
-    - Remove `ec2` platform id in favor of `aws`
-    - Remove `pxe` platform as it is not a platform
-    - Fail if files, links, and directories conflict after symlink resolution
-    - Do not fail when writing directories or links if overwrite is false and a
-      matching directory or link already exists
-
-25-Mar-2019 Ignition 2.0.0-alpha
-
-  NOTE: This is an alpha release. While the spec is marked as stable (i.e no
-    "-experimental" suffix) we still reserve the right to change it until the
-    stable 2.0.0 release. However, we do not anticipate any backwards
-    incompatible changes aside from removing deprecated fields.
-
-  NOTE: In order to allow types from both the 2.x.y and 3.0.0 specs to be
-    vendored and imported in the same project, we are skipping version 1.0.0.
-    Go mod (and some other tools) treat v0.x and v1.x as the same when
-    importing packages with semantic import versioning.
-
-  Features:
-
-    - Ignition now understands config specification 3.0.0
-    - Configs are now merged instead of appended
-
-  Changes:
-
-    - Configs with version < 3.0.0 are now rejected
-    - Duplicate entries are now disallowed in lists
-    - Removal of almost all deprecated fields
-
-14-Dec-2018 IGNITION v0.30.0
-
-  Features:
-
-    - Parallelize filesystem creation
-
-  Changes:
-
-    - Increase default config fetch timeout to 2 minutes
-
-  Test Changes:
-
-    - Add -list option to list blackbox tests
-    - Skip backward compatibility tests with -test.short
-
-06-Dec-2018 IGNITION v0.29.1
-
-  Bug Fixes:
-
-    - When writing files, directories, or links, do not follow symlinks if they
-      are the last path element
-
-30-Nov-2018 IGNITION v0.29.0
-
-  Features:
-
-    - Add support for ?versionId on s3:// URLs
-
-  Changes:
-
-    - Mark the 2.3.0 config spec as stable
-    - No longer accept configs with version 2.3.0-experimental
-    - Create new 2.4.0-experimental config spec from 2.3.0
-
-  Bug Fixes:
-
-    - Don't allow HTTPS connections to block on system entropy pool
-    - Relabel /var/home and /var/roothome when SELinux is enabled
-    - Fix race where files were relabeled after systemd-sysctl.service
-    - Do not run udevadm settle after the disks stage if the disks stage did
-      nothing
-    - Allow writing relative symlinks
-    - Resolve absolute symlinks relative to specified filesystem instead of the
-      initramfs root
-    - Report status to Packet as "running" instead of "succeeded"
-
-  Test Changes:
-
-    - Fix race with umount when running blackbox tests
-
-22-Aug-2018 IGNITION v0.28.0
-
-  Features:
-
-    - Refactor blackbox tests to allow testing disks with 4k sectors
-
-  Bug Fixes:
-
-    - Correctly detect disks with 4k sectors when scanning existing partitions
-    - Fix race between HTTP backoff tests
-    - Set the minimum config versions in tests to the actual minimum required
-    - Relabel /root when SELinux relabeling is enabled
-
-09-Aug-2018 IGNITION v0.27.0
-
-  Features:
-
-    - Ignition is now built as a Position Independent Executable (PIE)
-    - Blackbox tests now run against all spec versions (within the same major
-      version) greater than their minimum version
-    - Ignition now reports its status when running on Packet
-    - Add a compile-time flag to enable SELinux file relabeling after boot
-
-  Bug Fixes:
-
-    - Directories specified in both base and appended configs are always
-      created with the permissions specified in the appended config
-    - Call `chdir()` after `chroot()` to silence static checkers
-
-11-June-2018 IGNITION v0.26.0
-
-  Features:
-
-    - Support partition matching, specifying that a partition should not 
-      exist, and recreating existing partitions
-    - Fail blackbox tests when Ignition encounters critical-level logs
-
-  Bug Fixes:
-
-    - Fix an issue in timeout logic causing http(s) requests to sometimes fail
-    - Do not log non-critical errors with CRITICAL log level
-
-22-May-2018 IGNITION v0.25.1
-
-  Bug Fixes:
-
-    - Fix an issue in timeout logic causing http(s) requests to sometimes fail
-
-22-May-2018 IGNITION v0.24.1
-
-  Bug Fixes:
-
-    - Fix an issue in timeout logic causing http(s) requests to sometimes fail
-
-17-May-2018 IGNITION v0.25.0
-
-  Features:
-
-     - Blackbox tests can now be run in parallel
-
-  Changes:
-
-     - Remove Oracle Cloud Infrastructure support
-
-  Bug Fixes:
-
-     - No longer leave a stray file when appending to an existing file
-     - Fix multiple blackbox test validation errors
-     - Fix v1 config parsing to return ErrUnknownVersion if version is
-       unrecognized
-
-06-Mar-2018 IGNITION v0.24.0
-
-  Features
-
-    - Warn when adding and enabling a systemd unit and there is no "Install"
-      section in the unit contents
-    - Add highlights to reports generated by "Validate" functions on config
-      structs
-
-  Changes
-
-    - Move a helper validation function to the "config/validate" package
-    - Move unit validation helpers to "config/shared/validations"
-    - Add common error types to "config/shared/errors", refactor "config/v*" to
-      use these errors
-
-12-Mar-2018 IGNITION v0.23.0
-
-  Changes
-
-    - Latest experimental package has been moved from config/types to
-      config/v2_3_experimental.
-    - Each config package's Parse function will now transparently handle any
-      configs of a lesser version than itself (e.g. config/v2_2 will handle a
-      2.0.0 config).
-    - Validation in config/v1 reworked to use config/validate.
-    - Common error types from the config package moved to config/errors.
-
-09-Feb-2018 IGNITION v0.22.0
-
-  Changes
-
-    - Mark the 2.2.0 config spec as stable
-    - No longer accept configs with version 2.2.0-experimental
-    - Create new 2.3.0-experimental config spec from 2.2.0
-
-26-Jan-2018 IGNITION v0.21.0
-
-  Features
-
-    - Add support for networkd drop-ins
-    - Add new program, ignition-validate, for validating Ignition configs
-    - Add "overwrite" field to "files", "directories", and "links" sections for
-      deleting preexisting items at the node's path
-    - Add "options" field to "raid" section for specifying arbitrary mdadm
-      options
-    - Add "append" field to "files" section for appending to preexisting files
-    - Add support for specifying additional certificate authorities to use when
-      fetching objects over HTTPS
-
-  Changes
-
-    - Validate that partition labels don't contain colons, as sgdisk will
-      silently truncate the label
-    - Remove "-validate" flag from Ignition that was introduced in v0.20.0
-    - Warn when the mode for a file or directory is unset
-    - Log retries of HTTP fetches at info loglevel so messages appear on console
-
-  Bug Fixes
-
-    - Fix issue where unspecified fields in an appended config could "unset"
-      fields specified in a config earlier in the chain
-    - Use timeouts specified in a config when fetching other configs referenced
-      by it
-
-12-Jan-2018 IGNITION v0.20.1
-
-  Changes
-
-    - Add support for fetching S3 objects from non-default AWS partitions when
-      running in one such partition
-
-13-Dec-2017 IGNITION v0.20.0
-
-  Features
-
-    - Add validate flag for validating Ignition configs without running any
-      stages
-    - Add support for reading user configs from initramfs
-
-  Changes
-
-    - Move update-ssh-keys from dependency into internal library
-    - Move constants such as paths for invoked binaries into dedicated package
-      to allow for easy overriding at link time
-    - Read base and default configs from initramfs instead of hardcoding them
-    - Use the golang DNS resolver instead of the default glibc DNS resolver
-
-22-Sep-2017 IGNITION v0.19.0
-
-  Features
-
-    - Add support for CloudStack network metadata
-    - Add blackbox tests for TFTP URLs
-    - Remove dependency on kpartx for blackbox tests
-
-  Changes
-
-    - Stop adding extra quotes around GECOS field when creating users
-
-  Bug Fixes
-
-    - Fix regression in validation logic causing inaccurate line and column
-      reporting
-    - Fix regression in validation logic where JSON syntax errors were not
-      reported correctly
-    - Add warning if a non-existent filesystem is specified when creating links
-      and directories
-    - Fix udev race causing systemd units depending on the Ignition disks stage and 
-      a device unit to fail when no filesystems are created
-    - Fix udev race where symlinks are deleted before Ignition can create its own
-      copy
-
-08-Sep-2017 IGNITION v0.18.0
-
-  Features
-
-    - On VMWare allow guest variables to override values specified in the OVF
-      environment
-    - Add partial support for CloudStack
-    - Add blackbox tests
-    - Add support for Oracle OCI provider
-
-  Changes
-
-    - Chmod pre-existing directories to match defined permissions in config
-    - Chown pre-existing links to match defined owner in config
-    - Add "--homehost any" arguments to mdadm raid creation to ensure consistent
-      device name under /dev/md
-    - On GCE, don't bind-mount docker binary into Google Cloud SDK container
-    - On GCE, remove gcutil alias
-
-  Bug Fixes
-
-    - Properly error out when a user or group set by name in the config cannot
-      be resolved to an id
-    - Fix typo in gcloud alias preventing connection to the docker daemon in
-      some cases
-    - Fix partition number validation where multiple partitions on a disk were
-      unable to specify 0 for the next available partition number
-
-28-Jul-2017 IGNITION v0.17.2
-
-  Bug Fixes
-
-    - Fix failure to create files/directories/links on correct filesystem
-    - Fix failure to force filesystem creation when legacy force flag was set
-    - Prevent VFAT filesystem creation from unconditionally overwriting existing
-      filesystem
-    - Fix deprecation warning on enable field in OEM systemd units
-    - Fix failure where hard link targets would be on incorrect filesystem,
-      causing creation to fail
-    - Fix incorrect filesystem UUID check when deciding whether to reuse
-      existing filesystem, causing Ignition to fail
-
-05-Jul-2017 IGNITION v0.17.1
-
-  Bug Fixes
-
-    - Fix failure when user data was not provided on EC2 and GCE
-    - Fix failure to fetch user data on packet.net
-
-30-Jun-2017 IGNITION v0.17.0
-
-  Features
-
-    - Add support for S3 fetching and IAM role credential use in EC2
-    - Add enabled flag to services to allow disabling services
-    - Add new vagrant-virtualbox oem
-
-  Changes
-
-    - Mark 2.1.0 as stable
-    - No longer accept 2.1.0-experimental configs
-    - Create new 2.2.0-experimental spec from 2.1.0
-
-  Bug Fixes
-
-    - Mask user-configdrive.service and user-configvirtfs.service on brightbox
-      and openstack to prevent cloudinit from running a second time
-    - Use value given in root flag everywhere, instead of hard coding /sysroot
-
-16-Jun-2017 IGNITION v0.16.0
-
-  Experimental (2.1.0-experimental)
-
-    - Fix TFTP URL validation
-    - Fix nil pointer dereference when uid or gid for a file is unspecified
-    - Add support for VFAT filesystem creation
-    - Fix raid device validation
-
-  Changes
-
-    - Validate length of filesystem labels
-    - Remove all OEM etcd v0 drop-in units
-    - Remove xendom0 OEM
-
-  Features
-
-    - Add support for VMware's OVF environment
-    - Add support for VirtualBox OEM
-
-23-May-2017 IGNITION v0.15.0
-
-  Experimental (2.1.0-experimental)
-
-    - Define the Ignition Config schema in a JSON Schema file. Generate golang
-      structs from this file
-    - Add partition GUID to the filesystem object, create or modify the
-      partition as appropriate
-    - Add support for swap filesystems
-    - Add support for links, both symbolic and hard
-    - Deprecate the user level create object, add relevant fields directly to
-      the user object
-    - Add support for referencing users and groups by name when creating files,
-      directories, and links
-    - Deprecate the filesystem level create object, add relevant fields directly
-      to the filesystem object
-    - Add support for reusing existing filesystems, toggled via the new
-      `wipeFilesystem` field in the filesystem object
-    - Add filesystem UUID and label to the filesystem object
-    - Correctly handle timeouts, instead of ignoring timeout settings in the
-      Ignition config
-
-  Bug Fixes
-
-    - Fix file path validation on Windows
-    - On Brightbox correctly fetch the config, instead of failing with a noop
-    - Fix a race with udev events which could cause filesystem creation to fail
-
-  Changes
-
-    - Modify existing users, instead of attempting to create them
-
-  Features
-
-    - Support for TFTP URLs
-
-13-Mar-2017 IGNITION v0.14.0
-
-  Changes
-
-    - Update the services for the Azure OEM
-    - Update the services for the BrightBox OEM
-    - Update the services for the EC2 OEM
-    - Update the services for the OpenStack OEM
-    - Update the services for the Packet OEM
-    - Update the services for the VMware OEM
-
-01-Mar-2017 IGNITION v0.13.0
-
-  Bug Fixes
-
-    - Read from both the config-drive and metadata service when using the
-      OpenStack provider
-    - Properly reports errors encountered while creating files
-    - Fix GCE gcloud alias to properly invoke the container
-
-  Features
-
-    - Add support for experimental features via a newer config spec
-    - Allow file provider's config path to be overridden
-    - Perform basic syntactic validation on the contents of systemd units
-
-  Experimental (2.1.0-experimental)
-
-    - Add ability to explicitly create directories
-    - Add configuration for HTTP-related timeouts
-
-14-Dec-2016 IGNITION v0.12.1
-
-  Bug Fixes
-
-    - Enable coreos-metadata-sshkeys on Packet
-    - Assert validity of data URLs during config validation
-
-29-Nov-2016 IGNITION v0.12.0
-
-  Features
-
-    - Allow kernel command-line parameter to override OEM config
-
-07-Oct-2016 IGNITION v0.11.2
-
-  Bug Fixes
-
-    - Correctly set the partition typecode
-
-  Changes
-
-    - Update the services for the GCE OEM
-
-20-Sep-2016 IGNITION v0.11.1
-
-  Bug Fixes
-
-    - Fix potential deadlock when waiting for multiple disks
-
-07-Sep-2016 IGNITION v0.11.0
-
-  Features
-
-    - Add support for DigitalOcean
-    - Add experimental support for OpenStack
-
-26-Aug-2016 IGNITION v0.10.1
-
-  Bug Fixes
-
-    - Fix handling of oem:// URLs
-    - Use stable symlinks when operating on devices
-    - Retry failed requests when fetching Packet userdata
-    - Log the raw configurations instead of the parsed result
-
-23-Aug-2016 IGNITION v0.10.0
-
-  Features
-
-    - Add support for QEMU Firmware Configuration Device
-
-15-Aug-2016 IGNITION v0.9.2
-
-  Bug Fixes
-
-    - Do not retry HTTP requests that result in non-5xx status codes
-
-11-Aug-2016 IGNITION v0.9.1
-
-  Bug Fixes
-
-    - Properly validate data URLs
-
-11-Aug-2016 IGNITION v0.9.0
-
-  Features
-
-    - Add detailed configuration validation
-
-  Bug Fixes
-
-    - Add retry to all HTTP requests
-    - Fix potential panic when parsing certain URLs
-
-26-Jul-2016 IGNITION v0.8.0
-
-  Features
-
-    - Add support for Packet
-
-13-Jul-2016 IGNITION v0.7.1
-
-  Bug Fixes
-
-    - Interpret files without a URL to be empty instead of invalid
-    - HTTP fetches time out while waiting for response header instead of body
-    - Stream remote assets to disk instead of loading them into memory
-
-  Changes
-
-    - Improve configuration validation
-
-15-Jun-2016 IGNITION v0.7.0
-
-  Features
-
-    - Allow HTTPS URLs
-
-  Bug Fixes
-
-    - Don't overwrite existing data when formatting ext4 unless force is set
-    - Ensure service unit in /etc doesn't exist before masking
-    - Capture and log stdout of subprocesses
-
-  Changes
-
-    - Drop YAML tags from the config package
-
-18-May-2016 IGNITION v0.6.0
-
-  Features
-
-    - All URL schemes (currently http, oem, and data) are now supported
-      everywhere a URL can be provided
-    - Add base OEM and default user configurations for GCE
-
-04-May-2016 IGNITION v0.5.0
-
-  Features
-
-    - Add support for GCE
-
-  Bug Fixes
-
-    - Write files after users and home directories are created
-
-  Changes
-
-    - Strip support for EC2 SSH keys (these are handled by coreos-metadata now)
-    - Add OEM-specific base configs and execute even if user config is empty
-
-05-Apr-2016 IGNITION v0.4.0
-
-  Features
-
-    - Update the config spec to v2.0.0 (see the migration guide for more info)
-      - v1 configs will be automatically translated to v2.0.0
-    - Add HTTP "User-Agent" and "Accept" headers to all requests
-
-  Changes
-
-    - Use Go's vendor directory for all dependencies
-    - Split source into a public "config" package and "internal"
-
-25-Mar-2016 IGNITION v0.3.3
-
-  Bug Fixes
-
-    - Fix compilation errors when building for ARM
-    - Properly fetch configs from EC2
-
-17-Mar-2016 IGNITION v0.3.2
-
-  Bug Fixes
-
-    - Properly decode VMware guest variables before parsing config
-
-  Changes
-
-    - Move config structures from config package to config/types
-
-02-Mar-2016 IGNITION v0.3.1
-
-  Bug Fixes
-
-    - Allow building on non-AMD64 architectures
-
-  Changes
-
-    - Major refactoring of the internal processing of OEMs and providers
-
-24-Feb-2016 IGNITION v0.3.0
-
-  Features
-
-    - Add support for VMware
-
-13-Jan-2016 IGNITION v0.2.6
-
-  Features
-
-    - Improve validation of storage.filesystems options
-
-  Bug Fixes
-
-    - Properly zap GPT tables when they are partially valid
-
-06-Jan-2016 IGNITION v0.2.5
-
-  Bug Fixes
-
-    - Recognize and ignore gzipped cloud-configs
-
-19-Nov-2015 IGNITION v0.2.4
-
-  Bug Fixes
-
-    - Correctly escape device unit names
-
-17-Nov-2015 IGNITION v0.2.3
-
-  Features
-
-    - Provide logging to pinpoint JSON errors in invalid configs
-
-  Bug Fixes
-
-    - Ensure that /mnt/oem exists before mounting
-    - Remove /sysroot/ prefix from alternate config path
-
-20-Oct-2015 IGNITION v0.2.2
-
-  Bug Fixes
-
-    - Mount the oem partition for oem:// schemes when needed
-
-15-Oct-2015 IGNITION v0.2.1
-
-  Bug Fixes
-
-    - Allow empty CustomData on Azure
-
-29-Sep-2015 IGNITION v0.2.0
-
-  Features
-
-    - Added support for Azure
-    - Added support for formatting partitions as xfs
-
-  Bug Fixes
-
-    - Removed online timeout for EC2
-
-09-Sep-2015 IGNITION v0.1.6
-
-  Features
-
-    - --fetchtimeout becomes --online-timeout
-    - --online-timeout of 0 now represents infinity
-    - Added recognition of "interoute" OEM
-
-  Documentation
-
-    - Examples have been removed and supported platforms added
-    - Various minor cleanups
-
-  Bug Fixes
-
-    - Ensure added SSH keys are newline terminated
-
-  Build System Changes
-
-    - Fix gofmt invocation from test script to fail when appropriate
-
-28-Aug-2015 IGNITION v0.1.5
-
-  Bug Fixes
-
-    - Disable EC2 provider for now
-
-27-Aug-2015 IGNITION v0.1.4
-
-  Features
-
-    - Add support for oem:// scheme config urls
-
-  Documentation
-
-    - Added guides
-    - Updated config specification
-
-  Bug Fixes
-
-    - Add DefaultDependencies=false to WaitOnDevices() transient unit
-    - Updated JSON configuration keys to match style
-
-  Build System Changes
-
-    - Added script for tagging releases
-
-11-Aug-2015 IGNITION v0.1.3
-
-  Features
-
-    - Add support for ssh keys on EC2
-    - Log version at runtime
-
-  Bug Fixes
-
-    - Log ssh keys as they are added
-    - Various small cleanups
-
-  Build System Changes
-
-    - Derive version from git describe at build time
-    - Use bash build and test scripts instead of make
-
-22-Jul-2015 IGNITION v0.1.2
-
-  Bug Fixes
-
-    - Fix validation of drop-in names
-    - Properly handle a lack of userdata on EC2
-
-22-Jul-2015 IGNITION v0.1.1
-
-  Bug Fixes
-
-    - Ignore empty configs
-    - Ignore unsupported CoreOS OEMs
-    - Panic on incorrect OEM flag configurations
-
-14-Jul-2015 IGNITION v0.1.0
-
-  Features
-
-    - Initial release of Ignition!
-    - Support for disk partitioning, partition formatting, writing files,
-      RAID, systemd units, networkd units, users, and groups.
-    - Supports reading the config from a remote URL (via
-      config.coreos.url) or from the Amazon EC2 metadata service.
diff --git a/NEWS.md b/NEWS.md
new file mode 120000
index 00000000..9f024e93
--- /dev/null
+++ b/NEWS.md
@@ -0,0 +1 @@
+docs/release-notes.md
\ No newline at end of file
diff --git a/README.md b/README.md
index 8d6ed7c5..b3c26460 100644
--- a/README.md
+++ b/README.md
@@ -28,16 +28,6 @@ Example:
 podman run --pull=always --rm -i quay.io/coreos/ignition-validate:release - < myconfig.ign
 ```
 
-## Branches
-
-There are two branches:
-- `main`: the actively maintained version of Ignition, supporting config spec 3.x. Used by Fedora CoreOS and by Red Hat CoreOS starting with version 46.82.
-- `spec2x`: the legacy branch of Ignition, supporting config spec 1 and 2.x. Used by older versions of RHEL CoreOS, alongside the `spec2x` branch of ignition-dracut, and by Flatcar Container Linux. This branch is no longer maintained.
-
-### Legacy ignition-dracut
-
-In Ignition 2.5.0, the old [ignition-dracut](https://github.com/coreos/ignition-dracut) repository, containing scripts and systemd units for boot-time execution, was merged into Ignition itself. CoreOS-specific Dracut modules have moved to the [fedora-coreos-config](https://github.com/coreos/fedora-coreos-config) repository.
-
 [getting started]: docs/getting-started.md
 [issues]: https://github.com/coreos/ignition/issues/new/choose
 [releases]: https://github.com/coreos/ignition/releases
diff --git a/ci/shellcheck b/ci/shellcheck
new file mode 100755
index 00000000..7543bd38
--- /dev/null
+++ b/ci/shellcheck
@@ -0,0 +1,35 @@
+#!/bin/bash
+# Template generated by https://github.com/coreos/repo-templates; do not edit downstream
+
+set -euo pipefail
+
+main() {
+    local found_errors="false"
+    # Let's start with error, then we can do warning, info, style
+    local -r severity="error"
+
+    while IFS= read -r -d '' f; do
+        # Skip non-text files that are very unlikely to be shell scripts
+        if [[ "$(file -b --mime-type "${f}" | sed 's|/.*||')" != "text" ]]; then
+            continue
+        fi
+        shebang="$(head -1 "${f}")"
+        if [[ "${f}" == *.sh ]] || \
+            [[ ${shebang} =~ ^#!/.*/bash.* ]] || \
+            [[ ${shebang} =~ ^#!/.*/env\ bash ]]; then
+            echo "[+] Checking ${f}"
+            shellcheck --external-sources --shell bash --severity="${severity}" "${f}" || found_errors="true"
+            bash -n "${f}" || found_errors="true"
+        fi
+    done< <(find . -path "./.git" -prune -o -path "./vendor" -prune -o -type f -print0)
+
+    if [[ "${found_errors}" != "false" ]]; then
+        echo "[+] Found errors with ShellCheck"
+        exit 1
+    fi
+
+    echo "[+] No error found with ShellCheck"
+    exit 0
+}
+
+main "${@}"
diff --git a/config/config.go b/config/config.go
index 3ded9022..e4a2172d 100644
--- a/config/config.go
+++ b/config/config.go
@@ -15,8 +15,8 @@
 package config
 
 import (
-	exp "github.com/coreos/ignition/v2/config/v3_4_experimental"
-	types_exp "github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	exp "github.com/coreos/ignition/v2/config/v3_5_experimental"
+	types_exp "github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 
 	"github.com/coreos/vcontext/report"
 )
diff --git a/config/config_test.go b/config/config_test.go
index c39f85ca..1e35aee9 100644
--- a/config/config_test.go
+++ b/config/config_test.go
@@ -24,7 +24,8 @@ import (
 	v3_1 "github.com/coreos/ignition/v2/config/v3_1/types"
 	v3_2 "github.com/coreos/ignition/v2/config/v3_2/types"
 	v3_3 "github.com/coreos/ignition/v2/config/v3_3/types"
-	v3_4 "github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	v3_4 "github.com/coreos/ignition/v2/config/v3_4/types"
+	v3_5 "github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 )
 
 type typeSet map[reflect.Type]struct{}
@@ -272,6 +273,7 @@ func TestConfigStructure(t *testing.T) {
 		reflect.TypeOf(v3_2.Config{}),
 		reflect.TypeOf(v3_3.Config{}),
 		reflect.TypeOf(v3_4.Config{}),
+		reflect.TypeOf(v3_5.Config{}),
 	}
 
 	for _, configType := range configs {
diff --git a/config/doc/generate.go b/config/doc/generate.go
new file mode 100644
index 00000000..9dd3e4b7
--- /dev/null
+++ b/config/doc/generate.go
@@ -0,0 +1,153 @@
+// Copyright 2023 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package doc
+
+import (
+	"fmt"
+	"io"
+	"reflect"
+	"strings"
+
+	"github.com/coreos/ignition/v2/config/util"
+)
+
+type generator struct {
+	vers   VariantVersions
+	ignore IgnoreFunc
+	w      io.Writer
+}
+
+func (gen generator) descendNode(node DocNode, typ reflect.Type, path []string) error {
+	if typ.Kind() != reflect.Struct {
+		return fmt.Errorf("not a struct: %v (%v)", typ.Name(), typ.Kind())
+	}
+	fieldsByTag, err := structFieldsByTag(typ)
+	if err != nil {
+		return err
+	}
+	// iterate in order of docs YAML
+	for _, child := range node.Children {
+		field, ok := fieldsByTag[child.Name]
+		if !ok {
+			// have documentation but no struct field
+			continue
+		}
+		// possibly skip
+		if gen.ignore != nil && gen.ignore(append(path, child.Name)) {
+			delete(fieldsByTag, child.Name)
+			continue
+		}
+		// check if the field is required
+		required, err := child.required(gen.vers)
+		if err != nil {
+			return nil
+		}
+		if required == nil {
+			required = util.BoolToPtr(util.IsPrimitive(field.Type.Kind()))
+		}
+		// write the entry
+		var optional string
+		if !*required {
+			optional = "_"
+		}
+		desc, err := child.renderDescription(gen.vers)
+		if err != nil {
+			return err
+		}
+		if _, err := fmt.Fprintf(gen.w, "%s* **%s%s%s** (%s): %s\n", strings.Repeat("  ", len(path)), optional, child.Name, optional, typeName(field.Type), desc); err != nil {
+			return err
+		}
+		// recurse
+		if err := gen.descend(child, field.Type, append(path, child.Name)); err != nil {
+			return err
+		}
+		// delete from map to keep track of fields we've seen
+		delete(fieldsByTag, child.Name)
+	}
+	// check for undocumented fields
+	for _, field := range fieldsByTag {
+		return fmt.Errorf("undocumented field: %v.%v", typ.Name(), field.Name)
+	}
+	return nil
+}
+
+func (gen generator) descend(node DocNode, typ reflect.Type, path []string) error {
+	kind := typ.Kind()
+	switch {
+	case util.IsPrimitive(kind):
+		return nil
+	case kind == reflect.Struct:
+		return gen.descendNode(node, typ, path)
+	case kind == reflect.Slice, kind == reflect.Ptr:
+		return gen.descend(node, typ.Elem(), path)
+	case kind == reflect.Map:
+		if !util.IsPrimitive(typ.Key().Kind()) {
+			return fmt.Errorf("%v is map with non-primitive key type %v", typ.Name(), typ.Key())
+		}
+		return gen.descend(node, typ.Elem(), path)
+	default:
+		return fmt.Errorf("%v has kind %v", typ.Name(), kind)
+	}
+}
+
+func structFieldsByTag(typ reflect.Type) (map[string]reflect.StructField, error) {
+	ret := make(map[string]reflect.StructField, typ.NumField())
+	for i := 0; i < typ.NumField(); i++ {
+		field := typ.Field(i)
+		if field.Anonymous {
+			// anonymous embedded structure; merge its fields
+			sub, err := structFieldsByTag(field.Type)
+			if err != nil {
+				return nil, err
+			}
+			for k, v := range sub {
+				ret[k] = v
+			}
+		} else {
+			tag, ok := field.Tag.Lookup("yaml")
+			if !ok {
+				tag, ok = field.Tag.Lookup("json")
+			}
+			if !ok {
+				return nil, fmt.Errorf("no field tag: %v.%v", typ.Name(), field.Name)
+			}
+			// extract the field name, ignoring omitempty etc.
+			tag = strings.Split(tag, ",")[0]
+			ret[tag] = field
+		}
+	}
+	return ret, nil
+}
+
+func typeName(typ reflect.Type) string {
+	switch typ.Kind() {
+	case reflect.Bool:
+		return "boolean"
+	case reflect.Int:
+		return "integer"
+	case reflect.Map:
+		return "object"
+	case reflect.Pointer:
+		return typeName(typ.Elem())
+	case reflect.Slice:
+		return fmt.Sprintf("list of %ss", typeName(typ.Elem()))
+	case reflect.String:
+		return "string"
+	case reflect.Struct:
+		return "object"
+	default:
+		panic(fmt.Errorf("unknown type kind: %v", typ.Kind()))
+	}
+}
diff --git a/config/doc/ignition.yaml b/config/doc/ignition.yaml
new file mode 100644
index 00000000..a15b2097
--- /dev/null
+++ b/config/doc/ignition.yaml
@@ -0,0 +1,457 @@
+resource:
+  children:
+    - name: source
+      desc: "the URL of the %TYPE%. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified."
+      # source is typically required by validation, but some inclusion sites
+      # will override this
+      required: true
+      transforms:
+        - regex: "`gs`, "
+          replacement: ""
+          if:
+            - variant: ignition
+              max: 3.1.0
+        - regex: "`arn`, "
+          replacement: ""
+          if:
+            - variant: ignition
+              max: 3.3.0
+    - name: compression
+      desc: "the type of compression used on the %TYPE% (null or gzip). Compression cannot be used with S3."
+    - name: httpHeaders
+      desc: a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
+      children:
+        - name: name
+          desc: the header name.
+        - name: value
+          desc: the header contents.
+    - name: verification
+      desc: "options related to the verification of the %TYPE%."
+      children:
+        - name: hash
+          desc: "the hash of the %TYPE%, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed %TYPE%."
+          transforms:
+            - regex: "either `sha512` or `sha256`"
+              replacement: '`sha512`'
+              if:
+                - variant: ignition
+                  max: 3.0.0
+            # Most inclusion sites don't have a compression field in 3.0.0.
+            # The others re-add this line explicitly.
+            - regex: " If `compression` .* %TYPE%."
+              replacement: ""
+              if:
+                - variant: ignition
+                  max: 3.0.0
+
+# Separate component as a convenience to Butane
+tang:
+  name: tang
+  desc: describes a tang server. Every server must have a unique `url`.
+  children:
+    - name: url
+      desc: url of the tang server.
+    - name: thumbprint
+      desc: thumbprint of a trusted signing key.
+      # required by validation
+      required: true
+    - name: advertisement
+      desc: the advertisement JSON. If not specified, the advertisement is fetched from the tang server during provisioning.
+
+root:
+  children:
+    - name: ignition
+      desc: metadata about the configuration itself.
+      # required because ignition.version is
+      required: true
+      children:
+        - name: version
+          desc: "the semantic version number of the spec. The spec version must be compatible with the latest version (`%ignition_version%`). Compatibility requires the major versions to match and the spec version be less than or equal to the latest version. `-experimental` versions compare less than the final version with the same number, and previous experimental versions are not accepted."
+        - name: config
+          desc: options related to the configuration.
+          children:
+            - name: merge
+              use: resource
+              desc: a list of the configs to be merged to the current config.
+              transforms:
+                - regex: "%TYPE%"
+                  replacement: config
+                  descendants: true
+            - name: replace
+              use: resource
+              desc: the config that will replace the current.
+              transforms:
+                - regex: "%TYPE%"
+                  replacement: config
+                  descendants: true
+        - name: timeouts
+          desc: options relating to `http` timeouts when fetching files over `http` or `https`.
+          children:
+            - name: httpResponseHeaders
+              desc: "the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds."
+            - name: httpTotal
+              desc: "the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0."
+        - name: security
+          desc: options relating to network security.
+          children:
+            - name: tls
+              desc: "options relating to TLS when fetching resources over `https`."
+              children:
+                - name: certificateAuthorities
+                  use: resource
+                  desc: the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`.
+                  transforms:
+                    - regex: "%TYPE%"
+                      replacement: certificate bundle
+                      descendants: true
+                  children:
+                    - name: source
+                      transforms:
+                        - regex: "%TYPE%"
+                          replacement: "certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates"
+        - name: proxy
+          desc: options relating to setting an `HTTP(S)` proxy when fetching resources.
+          children:
+            - name: httpProxy
+              desc: will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
+            - name: httpsProxy
+              desc: will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
+            - name: noProxy
+              desc: specifies a list of strings to hosts that should be excluded from proxying. Each value is represented by an `IP address prefix (1.2.3.4)`, `an IP address prefix in CIDR notation (1.2.3.4/8)`, `a domain name`, or `a special DNS label (*)`. An IP address prefix and domain name can also include a literal port number `(1.2.3.4:80)`. A domain name matches that name and all subdomains. A domain name with a leading `.` matches subdomains only. For example `foo.com` matches `foo.com` and `bar.foo.com`; `.y.com` matches `x.y.com` but not `y.com`. A single asterisk `(*)` indicates that no proxying should be done.
+    - name: storage
+      desc: "describes the desired state of the system's storage devices."
+      children:
+        - name: disks
+          desc: the list of disks to be configured and their options. Every entry must have a unique `device`.
+          children:
+            - name: device
+              desc: the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
+            - name: wipeTable
+              desc: whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact.
+            - name: partitions
+              desc: the list of partitions and their configuration for this particular disk. Every partition must have a unique `number`, or if 0 is specified, a unique `label`.
+              children:
+                - name: label
+                  desc: the PARTLABEL for the partition.
+                - name: number
+                  desc: the partition number, which dictates its position in the partition table (one-indexed). If zero, use the next available partition slot.
+                  # non-pointer field, but can default to zero
+                  required: false
+                - name: sizeMiB
+                  desc: the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
+                - name: startMiB
+                  desc: the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
+                - name: typeGuid
+                  desc: the GPT [partition type GUID](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs). If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
+                - name: guid
+                  desc: the GPT unique partition GUID.
+                - name: wipePartitionEntry
+                  desc: if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
+                - name: shouldExist
+                  desc: whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
+                - name: resize
+                  desc: whether or not the existing partition should be resized. If omitted, it defaults to false. If true, Ignition will resize an existing partition if it matches the config in all respects except the partition size.
+        - name: raid
+          desc: the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
+          children:
+            - name: name
+              desc: the name to use for the resulting md device.
+            - name: level
+              desc: the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
+              # not part of the primary key, but required by validation
+              required: true
+            - name: devices
+              desc: the list of devices (referenced by their absolute path) in the array.
+              # required by validation
+              required: true
+            - name: spares
+              desc: the number of spares (if applicable) in the array.
+            - name: options
+              desc: any additional options to be passed to mdadm.
+        - name: filesystems
+          desc: the list of filesystems to be configured. `device` and `format` need to be specified. Every filesystem must have a unique `device`.
+          children:
+            - name: device
+              desc: the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
+            - name: format
+              desc: the filesystem format (ext4, btrfs, xfs, vfat, swap, or none).
+              # not part of the primary key, but required by validation
+              required: true
+              transforms:
+                - regex: "swap, or none"
+                  replacement: "or swap"
+                  if:
+                    - variant: ignition
+                      max: 3.2.0
+            - name: path
+              desc: the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
+            - name: wipeFilesystem
+              desc: "whether or not to wipe the device before filesystem creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information. Defaults to false."
+            - name: label
+              desc: the label of the filesystem.
+            - name: uuid
+              desc: the uuid of the filesystem.
+            - name: options
+              desc: any additional options to be passed to the format-specific mkfs utility.
+            - name: mountOptions
+              desc: any special options to be passed to the mount command.
+        - name: files
+          desc: the list of files to be written. Every file, directory and link must have a unique `path`.
+          children:
+            - name: path
+              desc: the absolute path to the file.
+            - name: overwrite
+              desc: whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
+            - name: contents
+              use: resource
+              desc: options related to the contents of the file.
+              transforms:
+                - regex: "%TYPE%"
+                  replacement: file
+                  descendants: true
+              children:
+                - name: source
+                  # empty file if source not specified
+                  required: false
+                  transforms:
+                    - regex: "haven't been modified."
+                      replacement: "$0 If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created."
+                - name: verification
+                  children:
+                    - name: hash
+                      transforms:
+                      # There is a compression field in 3.0 so re-add the
+                      # compression caveat
+                      - regex: $
+                        replacement: " If `compression` is specified, the hash describes the decompressed file."
+                        if:
+                          - variant: ignition
+                            max: 3.0.0
+            - name: append
+              use: resource
+              desc: list of fragments to be appended to the file. Follows the same structure as `contents`.
+              transforms:
+                - regex: "%TYPE%"
+                  replacement: fragment
+                  descendants: true
+              children:
+                - name: source
+                  required: false
+                - name: verification
+                  children:
+                    - name: hash
+                      transforms:
+                      # There is a compression field in 3.0 so re-add the
+                      # compression caveat
+                      - regex: $
+                        replacement: " If `compression` is specified, the hash describes the decompressed fragment."
+                        if:
+                          - variant: ignition
+                            max: 3.0.0
+            - name: mode
+              desc: the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
+              transforms:
+                - regex: are supported
+                  replacement: are not supported
+                  if:
+                    - variant: ignition
+                      max: 3.3.0
+            - name: user
+              desc: "specifies the file's owner."
+              children:
+                - name: id
+                  desc: the user ID of the owner.
+                - name: name
+                  desc: the user name of the owner.
+            - name: group
+              desc: "specifies the file's group."
+              children:
+                - name: id
+                  desc: the group ID of the group.
+                - name: name
+                  desc: the group name of the group.
+        - name: directories
+          desc: the list of directories to be created. Every file, directory, and link must have a unique `path`.
+          children:
+            - name: path
+              desc: the absolute path to the directory.
+            - name: overwrite
+              desc: whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
+            - name: mode
+              desc: "the directory's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0755 -> 493). Setuid/setgid/sticky bits are supported. If not specified, the permission mode for directories defaults to 0755 or the mode of an existing directory if `overwrite` is false and a directory already exists at the path."
+              transforms:
+                - regex: are supported
+                  replacement: are not supported
+                  if:
+                    - variant: ignition
+                      max: 3.3.0
+            - name: user
+              desc: "specifies the directory's owner."
+              children:
+                - name: id
+                  desc: the user ID of the owner.
+                - name: name
+                  desc: the user name of the owner.
+            - name: group
+              desc: "specifies the directory's group."
+              children:
+                - name: id
+                  desc: the group ID of the group.
+                - name: name
+                  desc: the group name of the group.
+        - name: links
+          desc: the list of links to be created. Every file, directory, and link must have a unique `path`.
+          children:
+            - name: path
+              desc: the absolute path to the link
+            - name: overwrite
+              desc: whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
+            - name: user
+              desc: specifies the owner for a symbolic link. Ignored for hard links.
+              children:
+                - name: id
+                  desc: the user ID of the owner.
+                - name: name
+                  desc: the user name of the owner.
+            - name: group
+              desc: specifies the group for a symbolic link. Ignored for hard links.
+              children:
+                - name: id
+                  desc: the group ID of the group.
+                - name: name
+                  desc: the group name of the group.
+            - name: target
+              desc: the target path of the link
+              # not part of the primary key, but required by validation
+              required: true
+            - name: hard
+              desc: a symbolic link is created if this is false, a hard one if this is true.
+        - name: luks
+          desc: the list of luks devices to be created. Every device must have a unique `name`.
+          children:
+            - name: name
+              desc: the name of the luks device.
+            - name: device
+              desc: the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
+              # not part of the primary key, but required by validation
+              required: true
+            - name: keyFile
+              use: resource
+              desc: options related to the contents of the key file.
+              transforms:
+                - regex: "%TYPE%"
+                  replacement: key file
+                  descendants: true
+              children:
+                - name: source
+                  # key file autogenerated if source not specified
+                  required: false
+            - name: label
+              desc: the label of the luks device.
+            - name: uuid
+              desc: the uuid of the luks device.
+            - name: options
+              desc: any additional options to be passed to `cryptsetup luksFormat`.
+            - name: discard
+              desc: whether to issue discard commands to the underlying block device when blocks are freed. Enabling this improves performance and device longevity on SSDs and space utilization on thinly provisioned SAN devices, but leaks information about which disk blocks contain data. If omitted, it defaults to false.
+            - name: openOptions
+              desc: any additional options to be passed to `cryptsetup luksOpen`. Supported options will be persistently written to the luks volume.
+            - name: wipeVolume
+              desc: "whether or not to wipe the device before volume creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information."
+            - name: clevis
+              desc: describes the clevis configuration for the luks device.
+              children:
+                - name: tang
+                  use: tang
+                - name: tpm2
+                  desc: whether or not to use a tpm2 device.
+                - name: threshold
+                  desc: sets the minimum number of pieces required to decrypt the device. Default is 1.
+                - name: custom
+                  desc: overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
+                  children:
+                    - name: pin
+                      desc: the clevis pin.
+                      # required by validation
+                      required: true
+                    - name: config
+                      desc: the clevis configuration JSON.
+                      # required by validation
+                      required: true
+                    - name: needsNetwork
+                      desc: whether or not the device requires networking.
+    - name: systemd
+      desc: describes the desired state of the systemd units.
+      children:
+        - name: units
+          desc: the list of systemd units. Every unit must have a unique `name`.
+          children:
+            - name: name
+              desc: the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service").
+            - name: enabled
+              desc: whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section.
+            - name: mask
+              desc: whether or not the service shall be masked. When true, the service is masked by symlinking it to `/dev/null`. When false, the service is unmasked by deleting the symlink to `/dev/null` if it exists.
+            - name: contents
+              desc: the contents of the unit.
+            - name: dropins
+              desc: the list of drop-ins for the unit. Every drop-in must have a unique `name`.
+              children:
+                - name: name
+                  desc: the name of the drop-in. This must be suffixed with ".conf".
+                - name: contents
+                  desc: the contents of the drop-in.
+    - name: passwd
+      desc: describes the desired additions to the passwd database.
+      children:
+        - name: users
+          desc: the list of accounts that shall exist. All users must have a unique `name`.
+          children:
+            - name: name
+              desc: the username for the account.
+            - name: passwordHash
+              desc: the hashed password for the account.
+            - name: sshAuthorizedKeys
+              desc: "a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique."
+            - name: uid
+              desc: the user ID of the account.
+            - name: gecos
+              desc: the GECOS field of the account.
+            - name: homeDir
+              desc: the home directory of the account.
+            - name: noCreateHome
+              desc: whether or not to create the user's home directory. This only has an effect if the account doesn't exist yet.
+            - name: primaryGroup
+              desc: the name of the primary group of the account.
+            - name: groups
+              desc: the list of supplementary groups of the account.
+            - name: noUserGroup
+              desc: "whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet."
+            - name: noLogInit
+              desc: "whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet."
+            - name: shell
+              desc: the login shell of the new account.
+            - name: shouldExist
+              desc: whether or not the user with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified user.
+            - name: system
+              desc: "whether or not this account should be a system account. This only has an effect if the account doesn't exist yet."
+        - name: groups
+          desc: the list of groups to be added. All groups must have a unique `name`.
+          children:
+            - name: name
+              desc: the name of the group.
+            - name: gid
+              desc: the group ID of the new group.
+            - name: passwordHash
+              desc: the hashed password of the new group.
+            - name: shouldExist
+              desc: whether or not the group with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified group.
+            - name: system
+              desc: "whether or not the group should be a system group. This only has an effect if the group doesn't exist yet."
+    - name: kernelArguments
+      desc: describes the desired kernel arguments.
+      children:
+        - name: shouldExist
+          desc: the list of kernel arguments that should exist.
+        - name: shouldNotExist
+          desc: the list of kernel arguments that should not exist.
diff --git a/config/doc/schema.go b/config/doc/schema.go
new file mode 100644
index 00000000..222ad601
--- /dev/null
+++ b/config/doc/schema.go
@@ -0,0 +1,346 @@
+// Copyright 2023 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package doc
+
+import (
+	"bytes"
+	_ "embed"
+	"fmt"
+	"io"
+	"reflect"
+	"regexp"
+	"strings"
+
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/go-semver/semver"
+	"github.com/mitchellh/copystructure"
+	"gopkg.in/yaml.v3"
+)
+
+//go:embed ignition.yaml
+var ignitionDocs []byte
+
+const IGNITION_VARIANT = "ignition"
+const ROOT_COMPONENT = "root"
+
+type Components map[string]DocNode
+
+type DocNode struct {
+	Name        string      `yaml:"name"`
+	Description string      `yaml:"desc"`
+	Required    *bool       `yaml:"required"`
+	RequiredIf  Constraints `yaml:"required-if"`
+	Transforms  []Transform `yaml:"transforms"`
+	Children    []DocNode   `yaml:"children"`
+
+	Component string `yaml:"use"`
+	After     string `yaml:"after"`
+
+	// populated after component resolution
+	Parent *DocNode
+}
+
+type Transform struct {
+	Regex       string      `yaml:"regex"`
+	Replacement string      `yaml:"replacement"`
+	Constraints Constraints `yaml:"if"`
+	Descendants bool        `yaml:"descendants"`
+}
+
+type Constraints []Constraint
+
+type Constraint struct {
+	Variant string  `yaml:"variant"`
+	MinVer  *string `yaml:"min"`
+	MaxVer  *string `yaml:"max"`
+}
+
+type VariantVersions map[string]semver.Version
+
+// takes a slice of path elements, returns whether to ignore the subtree
+type IgnoreFunc func([]string) bool
+
+func IgnitionComponents() (Components, error) {
+	return ParseComponents(bytes.NewBuffer(ignitionDocs))
+}
+
+func ParseComponents(r io.Reader) (Components, error) {
+	decoder := yaml.NewDecoder(r)
+	decoder.KnownFields(true)
+	var comps Components
+	if err := decoder.Decode(&comps); err != nil {
+		return comps, fmt.Errorf("parsing components: %w", err)
+	}
+	return comps, nil
+}
+
+func (comps Components) Generate(vers VariantVersions, config any, ignore IgnoreFunc, w io.Writer) error {
+	root, err := comps.resolve()
+	if err != nil {
+		return err
+	}
+	gen := generator{
+		vers:   vers,
+		ignore: ignore,
+		w:      w,
+	}
+	return gen.descendNode(root, reflect.TypeOf(config), nil)
+}
+
+func (comps Components) resolve() (DocNode, error) {
+	root, ok := comps[ROOT_COMPONENT]
+	if !ok {
+		return DocNode{}, fmt.Errorf("missing component %q", ROOT_COMPONENT)
+	}
+	root = copystructure.Must(copystructure.Copy(root)).(DocNode)
+	if err := comps.resolveComponents(&root); err != nil {
+		return DocNode{}, err
+	}
+	root.setParentLinks()
+	return root, nil
+}
+
+func (comps Components) resolveComponents(node *DocNode) error {
+	// recursively insert the subtree of any component reference
+	if node.Component != "" {
+		comp, ok := comps[node.Component]
+		if !ok {
+			return fmt.Errorf("field %q: no such component %q", node.Name, node.Component)
+		}
+		if comp.Component != "" {
+			return fmt.Errorf("component %q cannot itself refer to a component", node.Component)
+		}
+		comp = copystructure.Must(copystructure.Copy(comp)).(DocNode)
+		if err := comp.merge(*node); err != nil {
+			return err
+		}
+		comp.Component = ""
+		*node = comp
+	}
+	// now that all merging has happened, any remaining After field is
+	// incorrect
+	if node.After != "" {
+		return fmt.Errorf("field %q: stray `after` parameter %q", node.Name, node.After)
+	}
+	// descend children
+	for i := range node.Children {
+		if err := comps.resolveComponents(&node.Children[i]); err != nil {
+			return err
+		}
+	}
+	return nil
+}
+
+func (comps Components) Merge(override Components) error {
+	for name, comp := range comps {
+		overrideComp, ok := override[name]
+		if !ok {
+			// no override
+			continue
+		}
+		// present in both
+		if err := comp.merge(overrideComp); err != nil {
+			return fmt.Errorf("merging component %q: %w", name, err)
+		}
+		comps[name] = comp
+	}
+	for name, comp := range override {
+		if _, ok := comps[name]; ok {
+			// present in both
+			continue
+		}
+		// only present in override; add to current
+		comps[name] = comp
+	}
+	return nil
+}
+
+func (node *DocNode) setParentLinks() {
+	for i := range node.Children {
+		child := &node.Children[i]
+		child.Parent = node
+		child.setParentLinks()
+	}
+}
+
+func (node *DocNode) renderDescription(vers VariantVersions) (string, error) {
+	desc := node.Description
+	for _, xfrm := range node.transforms() {
+		matches, err := xfrm.Constraints.matches(vers)
+		if err != nil {
+			return "", fmt.Errorf("field %q: %w", node.Name, err)
+		}
+		if util.IsFalse(matches) {
+			continue
+		}
+		re, err := regexp.Compile(xfrm.Regex)
+		if err != nil {
+			return "", fmt.Errorf("field %q: compiling %q: %w", node.Name, xfrm.Regex, err)
+		}
+		new := re.ReplaceAllString(desc, xfrm.Replacement)
+		if !xfrm.Descendants && new == desc {
+			return "", fmt.Errorf("field %q: applying %q: transform didn't change anything", node.Name, xfrm.Regex)
+		}
+		desc = new
+	}
+	// substitute version variables last, so transforms can add them
+	for variant, ver := range vers {
+		desc = strings.ReplaceAll(desc, fmt.Sprintf("%%%s_version%%", variant), ver.String())
+	}
+	return desc, nil
+}
+
+func (node *DocNode) required(vers VariantVersions) (*bool, error) {
+	conditional, err := node.RequiredIf.matches(vers)
+	if err != nil {
+		return nil, err
+	}
+	if conditional != nil {
+		return conditional, nil
+	}
+	return node.Required, nil
+}
+
+func (node *DocNode) transforms() []Transform {
+	var ret []Transform
+	var descend func(node *DocNode, inheritedOnly bool)
+	descend = func(node *DocNode, inheritedOnly bool) {
+		for _, xfrm := range node.Transforms {
+			if inheritedOnly && !xfrm.Descendants {
+				continue
+			}
+			ret = append(ret, xfrm)
+		}
+		if node.Parent != nil {
+			descend(node.Parent, true)
+		}
+	}
+	descend(node, false)
+	return ret
+}
+
+func (node *DocNode) merge(override DocNode) error {
+	// merge fields
+	if override.Name != "" {
+		node.Name = override.Name
+	}
+	if override.Description != "" {
+		node.Description = override.Description
+	}
+	if override.Required != nil {
+		node.Required = override.Required
+		node.RequiredIf = nil
+	}
+	if len(override.RequiredIf) > 0 {
+		node.Required = nil
+		node.RequiredIf = append(node.RequiredIf, override.RequiredIf...)
+	}
+	node.Transforms = append(node.Transforms, override.Transforms...)
+	if override.Component != "" {
+		node.Component = override.Component
+	}
+	if override.After != "" {
+		node.After = override.After
+	}
+
+	// insertions and overrides for children
+	unseenOverrides := make(map[string]DocNode)
+	overrideByName := make(map[string]DocNode)
+	insertionsByPredecessor := make(map[string][]DocNode)
+	for _, child := range override.Children {
+		unseenOverrides[child.Name] = child
+		overrideByName[child.Name] = child
+		if child.After != "" {
+			insertionsByPredecessor[child.After] = append(insertionsByPredecessor[child.After], child)
+		}
+	}
+	var children []DocNode
+	insert := func(predecessor string) {
+		for _, child := range insertionsByPredecessor[predecessor] {
+			child.After = ""
+			children = append(children, child)
+			delete(unseenOverrides, child.Name)
+		}
+	}
+	insert("^")
+	for _, child := range node.Children {
+		if override, ok := overrideByName[child.Name]; ok {
+			if override.After != "" {
+				return fmt.Errorf("field %q: override %q sets `after` and also matches existing field", node.Name, child.Name)
+			}
+			if err := child.merge(override); err != nil {
+				return err
+			}
+			delete(unseenOverrides, child.Name)
+		}
+		children = append(children, child)
+		insert(child.Name)
+	}
+	insert("$")
+	node.Children = children
+
+	// find unused overrides
+	for _, child := range unseenOverrides {
+		if child.After != "" {
+			return fmt.Errorf("field %q: child %q: `after` field %q not found", node.Name, child.Name, child.After)
+		} else {
+			return fmt.Errorf("field %q: override %q not found; did you mean to set `after`?", node.Name, child.Name)
+		}
+	}
+
+	return nil
+}
+
+func (cons Constraints) matches(vers VariantVersions) (*bool, error) {
+	if len(cons) == 0 {
+		// no constraints
+		return nil, nil
+	}
+	for _, con := range cons {
+		if con.Variant == "" {
+			return nil, fmt.Errorf("missing `variant` in constraint")
+		}
+		ver, ok := vers[con.Variant]
+		if !ok {
+			// constraint isn't relevant to us
+			continue
+		}
+		if con.MinVer != nil {
+			min, err := semver.NewVersion(*con.MinVer)
+			if err != nil {
+				return nil, fmt.Errorf("parsing min %q: %w", *con.MinVer, err)
+			}
+			if ver.LessThan(*min) {
+				// constraint failed; try others
+				continue
+			}
+		}
+		if con.MaxVer != nil {
+			max, err := semver.NewVersion(*con.MaxVer)
+			if err != nil {
+				return nil, fmt.Errorf("parsing max %q: %w", *con.MaxVer, err)
+			}
+			if max.LessThan(ver) {
+				// constraint failed; try others
+				continue
+			}
+		}
+		// one constraint matched; accept
+		return util.BoolToPtr(true), nil
+	}
+	// no constraints matched; reject
+	return util.BoolToPtr(false), nil
+}
diff --git a/config/merge/merge_test.go b/config/merge/merge_test.go
index 4555a7a9..e1dbd936 100644
--- a/config/merge/merge_test.go
+++ b/config/merge/merge_test.go
@@ -19,7 +19,7 @@ import (
 
 	"github.com/coreos/ignition/v2/config/util"
 	v3_2 "github.com/coreos/ignition/v2/config/v3_2/types"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 
 	"github.com/coreos/vcontext/path"
 	"github.com/stretchr/testify/assert"
diff --git a/config/shared/errors/errors.go b/config/shared/errors/errors.go
index 492fd7e6..8e2d24d5 100644
--- a/config/shared/errors/errors.go
+++ b/config/shared/errors/errors.go
@@ -39,6 +39,7 @@ var (
 	ErrLinkUsedSymlink           = errors.New("link path includes link in config")
 	ErrLinkTargetRequired        = errors.New("link target is required")
 	ErrHardLinkToDirectory       = errors.New("hard link target is a directory")
+	ErrHardLinkSpecifiesOwner    = errors.New("user/group ignored for hard link")
 	ErrDiskDeviceRequired        = errors.New("disk device is required")
 	ErrPartitionNumbersCollide   = errors.New("partition numbers collide")
 	ErrPartitionsOverlap         = errors.New("partitions overlap")
@@ -61,6 +62,7 @@ var (
 	ErrClevisConfigRequired      = errors.New("missing required custom clevis config")
 	ErrClevisCustomWithOthers    = errors.New("cannot use custom clevis config with tpm2, tang, or threshold")
 	ErrTangThumbprintRequired    = errors.New("thumbprint is required")
+	ErrInvalidTangAdvertisement  = errors.New("advertisement is not valid JSON")
 	ErrFileIllegalMode           = errors.New("illegal file mode")
 	ErrModeSpecialBits           = errors.New("setuid/setgid/sticky bits are not supported in spec versions older than 3.4.0")
 	ErrBothIDAndNameSet          = errors.New("cannot set both id and name")
@@ -70,6 +72,8 @@ var (
 	ErrNoPath                    = errors.New("path not specified")
 	ErrPathRelative              = errors.New("path not absolute")
 	ErrDirtyPath                 = errors.New("path is not fully simplified")
+	ErrPartitionsOverwritten     = errors.New("filesystem overwrites partitioned device")
+	ErrFilesystemImplicitWipe    = errors.New("device matches disk with wipeTable enabled; filesystem will be wiped")
 	ErrRaidLevelRequired         = errors.New("raid level is required")
 	ErrSparesUnsupportedForLevel = errors.New("spares unsupported for linear and raid0 arrays")
 	ErrUnrecognizedRaidLevel     = errors.New("unrecognized raid level")
@@ -80,6 +84,7 @@ var (
 	ErrDuplicateLabels           = errors.New("cannot use the same partition label twice")
 	ErrInvalidProxy              = errors.New("proxies must be http(s)")
 	ErrInsecureProxy             = errors.New("insecure plaintext HTTP proxy specified for HTTPS resources")
+	ErrPathConflictsSystemd      = errors.New("path conflicts with systemd unit or dropin")
 
 	// Systemd section errors
 	ErrInvalidSystemdExt       = errors.New("invalid systemd unit extension")
@@ -113,3 +118,9 @@ var (
 func NewNoInstallSectionError(name string) error {
 	return fmt.Errorf("unit %q is enabled, but has no install section so enable does nothing", name)
 }
+
+// NewNoInstallSectionForInstantiableUnitError produces an error indicating the
+// given instantiable unit for an instance unit is missing an Install section.
+func NewNoInstallSectionForInstantiableUnitError(instantiable, instance string) error {
+	return fmt.Errorf("template unit %q for %q doesn't have Install section", instantiable, instance)
+}
diff --git a/config/shared/parse/unit.go b/config/shared/parse/unit.go
new file mode 100644
index 00000000..7dcd1891
--- /dev/null
+++ b/config/shared/parse/unit.go
@@ -0,0 +1,37 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// Package parse contains a function for parsing unit contents shared between
+// multiple config versions.
+package parse
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/coreos/go-systemd/v22/unit"
+)
+
+// ParseUnitContents parses the content of a given unit
+func ParseUnitContents(content *string) ([]*unit.UnitOption, error) {
+	if content == nil {
+		return []*unit.UnitOption{}, nil
+	}
+	c := strings.NewReader(*content)
+	opts, err := unit.Deserialize(c)
+	if err != nil {
+		return nil, fmt.Errorf("invalid unit content: %s", err)
+	}
+	return opts, nil
+}
diff --git a/config/util/config.go b/config/util/config.go
index 85cd7fa7..0b676698 100644
--- a/config/util/config.go
+++ b/config/util/config.go
@@ -11,6 +11,7 @@
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
+
 package util
 
 import (
diff --git a/config/v3_0/types/config.go b/config/v3_0/types/config.go
index a98062a1..1ac29594 100644
--- a/config/v3_0/types/config.go
+++ b/config/v3_0/types/config.go
@@ -15,7 +15,12 @@
 package types
 
 import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
 	"github.com/coreos/go-semver/semver"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
 )
 
 var (
@@ -24,3 +29,36 @@ var (
 		Minor: 0,
 	}
 )
+
+func (cfg Config) Validate(c path.ContextPath) (r report.Report) {
+	systemdPath := "/etc/systemd/system/"
+	unitPaths := map[string]struct{}{}
+	for _, unit := range cfg.Systemd.Units {
+		if !util.NilOrEmpty(unit.Contents) {
+			pathString := systemdPath + unit.Name
+			unitPaths[pathString] = struct{}{}
+		}
+		for _, dropin := range unit.Dropins {
+			if !util.NilOrEmpty(dropin.Contents) {
+				pathString := systemdPath + unit.Name + ".d/" + dropin.Name
+				unitPaths[pathString] = struct{}{}
+			}
+		}
+	}
+	for i, f := range cfg.Storage.Files {
+		if _, exists := unitPaths[f.Path]; exists {
+			r.AddOnError(c.Append("storage", "files", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, d := range cfg.Storage.Directories {
+		if _, exists := unitPaths[d.Path]; exists {
+			r.AddOnError(c.Append("storage", "directories", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, l := range cfg.Storage.Links {
+		if _, exists := unitPaths[l.Path]; exists {
+			r.AddOnError(c.Append("storage", "links", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	return
+}
diff --git a/config/v3_0/types/config_test.go b/config/v3_0/types/config_test.go
new file mode 100644
index 00000000..da8cfa26
--- /dev/null
+++ b/config/v3_0/types/config_test.go
@@ -0,0 +1,260 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestConfigValidation(t *testing.T) {
+	tests := []struct {
+		in  Config
+		out error
+		at  path.ContextPath
+	}{
+		// test 0: file conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 1: file conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 2: directory conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 3: directory conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 4: link conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/qux.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 5: link conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/qux.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 6: non-conflicting scenarios
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service.d/baz.conf"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/qux.conf"},
+						},
+					},
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/qux.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/qux.conf"},
+						},
+						{
+							Node:          Node{Path: "/etc/systemd/system/quux.service.d/foo.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/foo.conf"},
+						},
+					},
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/quux.service.d"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+						{
+							Name: "bar.service",
+							Dropins: []Dropin{
+								{
+									Name: "baz.conf",
+								},
+							},
+							Enabled: util.BoolToPtr(true),
+						},
+						{
+							Name: "qux.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+								},
+							},
+						},
+						{
+							Name:     "quux.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+		},
+	}
+	for i, test := range tests {
+		r := test.in.Validate(path.New("json"))
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad error: expected : %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_0/types/storage.go b/config/v3_0/types/storage.go
index eac98e74..24668954 100644
--- a/config/v3_0/types/storage.go
+++ b/config/v3_0/types/storage.go
@@ -34,6 +34,14 @@ func (s Storage) MergedKeys() map[string]string {
 }
 
 func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
+	s.validateDirectories(c, &r)
+	s.validateFiles(c, &r)
+	s.validateLinks(c, &r)
+	s.validateFilesystems(c, &r)
+	return
+}
+
+func (s Storage) validateDirectories(c vpath.ContextPath, r *report.Report) {
 	for i, d := range s.Directories {
 		for _, l := range s.Links {
 			if strings.HasPrefix(d.Path, l.Path+"/") {
@@ -41,6 +49,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateFiles(c vpath.ContextPath, r *report.Report) {
 	for i, f := range s.Files {
 		for _, l := range s.Links {
 			if strings.HasPrefix(f.Path, l.Path+"/") {
@@ -48,6 +59,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateLinks(c vpath.ContextPath, r *report.Report) {
 	for i, l1 := range s.Links {
 		for _, l2 := range s.Links {
 			if strings.HasPrefix(l1.Path, l2.Path+"/") {
@@ -66,6 +80,32 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
 			}
 		}
+		ownerCheck := func(ok bool, path vpath.ContextPath) {
+			if !ok {
+				r.AddOnWarn(path, errors.ErrHardLinkSpecifiesOwner)
+			}
+		}
+		ownerCheck(l1.User.ID == nil, c.Append("links", i, "user", "id"))
+		ownerCheck(l1.User.Name == nil, c.Append("links", i, "user", "name"))
+		ownerCheck(l1.Group.ID == nil, c.Append("links", i, "group", "id"))
+		ownerCheck(l1.Group.Name == nil, c.Append("links", i, "group", "name"))
+	}
+}
+
+func (s Storage) validateFilesystems(c vpath.ContextPath, r *report.Report) {
+	disks := make(map[string]Disk)
+	for _, d := range s.Disks {
+		disks[d.Device] = d
+	}
+
+	for i, f := range s.Filesystems {
+		disk, exist := disks[f.Device]
+		if exist {
+			if len(disk.Partitions) > 0 {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrPartitionsOverwritten)
+			} else if !util.IsTrue(f.WipeFilesystem) && util.IsTrue(disk.WipeTable) {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrFilesystemImplicitWipe)
+			}
+		}
 	}
-	return
 }
diff --git a/config/v3_0/types/storage_test.go b/config/v3_0/types/storage_test.go
index 00c5861a..f106deb8 100644
--- a/config/v3_0/types/storage_test.go
+++ b/config/v3_0/types/storage_test.go
@@ -25,16 +25,18 @@ import (
 	"github.com/coreos/vcontext/report"
 )
 
-func TestStorageValidate(t *testing.T) {
+func TestStorageValidateErrors(t *testing.T) {
 	tests := []struct {
-		in  Storage
-		at  path.ContextPath
-		out error
+		in   Storage
+		at   path.ContextPath
+		err  error
+		warn error
 	}{
+		// test empty storage config returns nil
 		{
-			in:  Storage{},
-			out: nil,
+			in: Storage{},
 		},
+		// test a storage config with no conflicting paths returns nil
 		{
 			in: Storage{
 				Links: []Link{
@@ -56,8 +58,8 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: nil,
 		},
+		// test when a file uses a configured symlink path returns ErrFileUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -71,9 +73,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrFileUsedSymlink,
+			err: errors.ErrFileUsedSymlink,
 			at:  path.New("", "files", 0),
 		},
+		// test when a directory uses a configured symlink path returns ErrDirectoryUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -87,9 +90,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrDirectoryUsedSymlink,
+			err: errors.ErrDirectoryUsedSymlink,
 			at:  path.New("", "directories", 0),
 		},
+		// test the same path listed for two separate symlinks returns ErrLinkUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -101,9 +105,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrLinkUsedSymlink,
+			err: errors.ErrLinkUsedSymlink,
 			at:  path.New("", "links", 1),
 		},
+		// test that two symlinks can be configured at a time
 		{
 			in: Storage{
 				Links: []Link{
@@ -115,8 +120,8 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: nil,
 		},
+		// test when a directory uses a configured symlink with the 'Hard:= true' returns ErrHardLinkToDirectory
 		{
 			in: Storage{
 				Links: []Link{
@@ -134,15 +139,185 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrHardLinkToDirectory,
+			err: errors.ErrHardLinkToDirectory,
 			at:  path.New("", "links", 0),
 		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "name"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "name"),
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.err)
+		expected.AddOnWarn(test.at, test.warn)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
+
+func TestStorageValidateWarnings(t *testing.T) {
+	tests := []struct {
+		in  Storage
+		at  path.ContextPath
+		out error
+	}{
+		// test a disk with partitions with the same 'device' as a filesystem returns ErrPartitionsOverwritten
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sda",
+						Partitions: []Partition{
+							{}, {},
+						},
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrPartitionsOverwritten,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=true' as a configured filesystem returns ErrFilesystemImplicitWipe
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(true),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrFilesystemImplicitWipe,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=false' as a configured filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(false),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: nil,
+		},
+		// test a disk with no partitions with the same 'device' as a filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+			},
+			out: nil,
+		},
 	}
 
 	for i, test := range tests {
 		r := test.in.Validate(path.ContextPath{})
 		expected := report.Report{}
-		expected.AddOnError(test.at, test.out)
+		expected.AddOnWarn(test.at, test.out)
 		if !reflect.DeepEqual(expected, r) {
 			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
 		}
diff --git a/config/v3_0/types/systemd.go b/config/v3_0/types/systemd.go
new file mode 100644
index 00000000..ac521ba7
--- /dev/null
+++ b/config/v3_0/types/systemd.go
@@ -0,0 +1,61 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"regexp"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
+	"github.com/coreos/ignition/v2/config/util"
+
+	vpath "github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (s Systemd) Validate(c vpath.ContextPath) (r report.Report) {
+	units := make(map[string]Unit)
+	checkInstanceUnit := regexp.MustCompile(`^(.+?)@(.+?)\.service$`)
+	for _, d := range s.Units {
+		units[d.Name] = d
+	}
+	for index, unit := range s.Units {
+		if checkInstanceUnit.MatchString(unit.Name) && util.IsTrue(unit.Enabled) {
+			instUnitSlice := checkInstanceUnit.FindSubmatch([]byte(unit.Name))
+			instantiableUnit := string(instUnitSlice[1]) + "@.service"
+			if _, ok := units[instantiableUnit]; ok && util.NotEmpty(units[instantiableUnit].Contents) {
+				foundInstallSection := false
+				// we're doing a separate validation pass on each unit to identify
+				// if an instantiable unit has the install section. So logging an
+				// `AddOnError` will produce duplicate errors on bad unit contents
+				// because we're already doing that while validating a unit separately.
+				opts, err := parse.ParseUnitContents(units[instantiableUnit].Contents)
+				if err != nil {
+					continue
+				}
+				for _, section := range opts {
+					if section.Section == "Install" {
+						foundInstallSection = true
+						break
+					}
+				}
+				if !foundInstallSection {
+					r.AddOnWarn(c.Append("units", index, "contents"), errors.NewNoInstallSectionForInstantiableUnitError(instantiableUnit, unit.Name))
+				}
+			}
+		}
+	}
+	return
+}
diff --git a/config/v3_0/types/systemd_test.go b/config/v3_0/types/systemd_test.go
new file mode 100644
index 00000000..798eb10f
--- /dev/null
+++ b/config/v3_0/types/systemd_test.go
@@ -0,0 +1,105 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestSystemdValidate(t *testing.T) {
+	tests := []struct {
+		in  Systemd
+		out error
+	}{
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			errors.NewNoInstallSectionForInstantiableUnitError("test@.service", "test@foo.service"),
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service"},
+					{Name: "test@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+	}
+
+	for i, test := range tests {
+		t.Run(fmt.Sprintf("validate %d", i), func(t *testing.T) {
+			actual := test.in.Validate(path.ContextPath{})
+			expected := report.Report{}
+			expected.AddOnWarn(path.ContextPath{}.Append("units", 1, "contents"), test.out)
+			assert.Equal(t, expected, actual, "bad report")
+		})
+	}
+}
diff --git a/config/v3_0/types/unit.go b/config/v3_0/types/unit.go
index e0e5c50a..786debae 100644
--- a/config/v3_0/types/unit.go
+++ b/config/v3_0/types/unit.go
@@ -15,15 +15,13 @@
 package types
 
 import (
-	"fmt"
 	"path"
-	"strings"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
 	"github.com/coreos/ignition/v2/config/shared/validations"
 	"github.com/coreos/ignition/v2/config/util"
 
-	"github.com/coreos/go-systemd/v22/unit"
 	cpath "github.com/coreos/vcontext/path"
 	"github.com/coreos/vcontext/report"
 )
@@ -39,7 +37,7 @@ func (d Dropin) Key() string {
 func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
 	r.AddOnError(c.Append("name"), validateName(u.Name))
 	c = c.Append("contents")
-	opts, err := validateUnitContent(u.Contents)
+	opts, err := parse.ParseUnitContents(u.Contents)
 	r.AddOnError(c, err)
 
 	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, util.IsTrue(u.Enabled), util.NilOrEmpty(u.Contents), opts))
@@ -57,7 +55,7 @@ func validateName(name string) error {
 }
 
 func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
-	_, err := validateUnitContent(d.Contents)
+	_, err := parse.ParseUnitContents(d.Contents)
 	r.AddOnError(c.Append("contents"), err)
 
 	switch path.Ext(d.Name) {
@@ -68,15 +66,3 @@ func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
 
 	return
 }
-
-func validateUnitContent(content *string) ([]*unit.UnitOption, error) {
-	if content == nil {
-		return []*unit.UnitOption{}, nil
-	}
-	c := strings.NewReader(*content)
-	opts, err := unit.Deserialize(c)
-	if err != nil {
-		return nil, fmt.Errorf("invalid unit content: %s", err)
-	}
-	return opts, nil
-}
diff --git a/config/v3_1/types/config.go b/config/v3_1/types/config.go
index 23ba8dd1..3cebde7f 100644
--- a/config/v3_1/types/config.go
+++ b/config/v3_1/types/config.go
@@ -15,7 +15,12 @@
 package types
 
 import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
 	"github.com/coreos/go-semver/semver"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
 )
 
 var (
@@ -24,3 +29,36 @@ var (
 		Minor: 1,
 	}
 )
+
+func (cfg Config) Validate(c path.ContextPath) (r report.Report) {
+	systemdPath := "/etc/systemd/system/"
+	unitPaths := map[string]struct{}{}
+	for _, unit := range cfg.Systemd.Units {
+		if !util.NilOrEmpty(unit.Contents) {
+			pathString := systemdPath + unit.Name
+			unitPaths[pathString] = struct{}{}
+		}
+		for _, dropin := range unit.Dropins {
+			if !util.NilOrEmpty(dropin.Contents) {
+				pathString := systemdPath + unit.Name + ".d/" + dropin.Name
+				unitPaths[pathString] = struct{}{}
+			}
+		}
+	}
+	for i, f := range cfg.Storage.Files {
+		if _, exists := unitPaths[f.Path]; exists {
+			r.AddOnError(c.Append("storage", "files", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, d := range cfg.Storage.Directories {
+		if _, exists := unitPaths[d.Path]; exists {
+			r.AddOnError(c.Append("storage", "directories", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, l := range cfg.Storage.Links {
+		if _, exists := unitPaths[l.Path]; exists {
+			r.AddOnError(c.Append("storage", "links", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	return
+}
diff --git a/config/v3_1/types/config_test.go b/config/v3_1/types/config_test.go
new file mode 100644
index 00000000..da8cfa26
--- /dev/null
+++ b/config/v3_1/types/config_test.go
@@ -0,0 +1,260 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestConfigValidation(t *testing.T) {
+	tests := []struct {
+		in  Config
+		out error
+		at  path.ContextPath
+	}{
+		// test 0: file conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 1: file conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 2: directory conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 3: directory conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 4: link conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/qux.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 5: link conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/qux.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 6: non-conflicting scenarios
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service.d/baz.conf"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/qux.conf"},
+						},
+					},
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/qux.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/qux.conf"},
+						},
+						{
+							Node:          Node{Path: "/etc/systemd/system/quux.service.d/foo.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/foo.conf"},
+						},
+					},
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/quux.service.d"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+						{
+							Name: "bar.service",
+							Dropins: []Dropin{
+								{
+									Name: "baz.conf",
+								},
+							},
+							Enabled: util.BoolToPtr(true),
+						},
+						{
+							Name: "qux.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+								},
+							},
+						},
+						{
+							Name:     "quux.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+		},
+	}
+	for i, test := range tests {
+		r := test.in.Validate(path.New("json"))
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad error: expected : %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_1/types/storage.go b/config/v3_1/types/storage.go
index eac98e74..24668954 100644
--- a/config/v3_1/types/storage.go
+++ b/config/v3_1/types/storage.go
@@ -34,6 +34,14 @@ func (s Storage) MergedKeys() map[string]string {
 }
 
 func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
+	s.validateDirectories(c, &r)
+	s.validateFiles(c, &r)
+	s.validateLinks(c, &r)
+	s.validateFilesystems(c, &r)
+	return
+}
+
+func (s Storage) validateDirectories(c vpath.ContextPath, r *report.Report) {
 	for i, d := range s.Directories {
 		for _, l := range s.Links {
 			if strings.HasPrefix(d.Path, l.Path+"/") {
@@ -41,6 +49,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateFiles(c vpath.ContextPath, r *report.Report) {
 	for i, f := range s.Files {
 		for _, l := range s.Links {
 			if strings.HasPrefix(f.Path, l.Path+"/") {
@@ -48,6 +59,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateLinks(c vpath.ContextPath, r *report.Report) {
 	for i, l1 := range s.Links {
 		for _, l2 := range s.Links {
 			if strings.HasPrefix(l1.Path, l2.Path+"/") {
@@ -66,6 +80,32 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
 			}
 		}
+		ownerCheck := func(ok bool, path vpath.ContextPath) {
+			if !ok {
+				r.AddOnWarn(path, errors.ErrHardLinkSpecifiesOwner)
+			}
+		}
+		ownerCheck(l1.User.ID == nil, c.Append("links", i, "user", "id"))
+		ownerCheck(l1.User.Name == nil, c.Append("links", i, "user", "name"))
+		ownerCheck(l1.Group.ID == nil, c.Append("links", i, "group", "id"))
+		ownerCheck(l1.Group.Name == nil, c.Append("links", i, "group", "name"))
+	}
+}
+
+func (s Storage) validateFilesystems(c vpath.ContextPath, r *report.Report) {
+	disks := make(map[string]Disk)
+	for _, d := range s.Disks {
+		disks[d.Device] = d
+	}
+
+	for i, f := range s.Filesystems {
+		disk, exist := disks[f.Device]
+		if exist {
+			if len(disk.Partitions) > 0 {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrPartitionsOverwritten)
+			} else if !util.IsTrue(f.WipeFilesystem) && util.IsTrue(disk.WipeTable) {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrFilesystemImplicitWipe)
+			}
+		}
 	}
-	return
 }
diff --git a/config/v3_1/types/storage_test.go b/config/v3_1/types/storage_test.go
index 00c5861a..f106deb8 100644
--- a/config/v3_1/types/storage_test.go
+++ b/config/v3_1/types/storage_test.go
@@ -25,16 +25,18 @@ import (
 	"github.com/coreos/vcontext/report"
 )
 
-func TestStorageValidate(t *testing.T) {
+func TestStorageValidateErrors(t *testing.T) {
 	tests := []struct {
-		in  Storage
-		at  path.ContextPath
-		out error
+		in   Storage
+		at   path.ContextPath
+		err  error
+		warn error
 	}{
+		// test empty storage config returns nil
 		{
-			in:  Storage{},
-			out: nil,
+			in: Storage{},
 		},
+		// test a storage config with no conflicting paths returns nil
 		{
 			in: Storage{
 				Links: []Link{
@@ -56,8 +58,8 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: nil,
 		},
+		// test when a file uses a configured symlink path returns ErrFileUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -71,9 +73,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrFileUsedSymlink,
+			err: errors.ErrFileUsedSymlink,
 			at:  path.New("", "files", 0),
 		},
+		// test when a directory uses a configured symlink path returns ErrDirectoryUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -87,9 +90,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrDirectoryUsedSymlink,
+			err: errors.ErrDirectoryUsedSymlink,
 			at:  path.New("", "directories", 0),
 		},
+		// test the same path listed for two separate symlinks returns ErrLinkUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -101,9 +105,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrLinkUsedSymlink,
+			err: errors.ErrLinkUsedSymlink,
 			at:  path.New("", "links", 1),
 		},
+		// test that two symlinks can be configured at a time
 		{
 			in: Storage{
 				Links: []Link{
@@ -115,8 +120,8 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: nil,
 		},
+		// test when a directory uses a configured symlink with the 'Hard:= true' returns ErrHardLinkToDirectory
 		{
 			in: Storage{
 				Links: []Link{
@@ -134,15 +139,185 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrHardLinkToDirectory,
+			err: errors.ErrHardLinkToDirectory,
 			at:  path.New("", "links", 0),
 		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "name"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "name"),
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.err)
+		expected.AddOnWarn(test.at, test.warn)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
+
+func TestStorageValidateWarnings(t *testing.T) {
+	tests := []struct {
+		in  Storage
+		at  path.ContextPath
+		out error
+	}{
+		// test a disk with partitions with the same 'device' as a filesystem returns ErrPartitionsOverwritten
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sda",
+						Partitions: []Partition{
+							{}, {},
+						},
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrPartitionsOverwritten,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=true' as a configured filesystem returns ErrFilesystemImplicitWipe
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(true),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrFilesystemImplicitWipe,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=false' as a configured filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(false),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: nil,
+		},
+		// test a disk with no partitions with the same 'device' as a filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+			},
+			out: nil,
+		},
 	}
 
 	for i, test := range tests {
 		r := test.in.Validate(path.ContextPath{})
 		expected := report.Report{}
-		expected.AddOnError(test.at, test.out)
+		expected.AddOnWarn(test.at, test.out)
 		if !reflect.DeepEqual(expected, r) {
 			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
 		}
diff --git a/config/v3_1/types/systemd.go b/config/v3_1/types/systemd.go
new file mode 100644
index 00000000..ac521ba7
--- /dev/null
+++ b/config/v3_1/types/systemd.go
@@ -0,0 +1,61 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"regexp"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
+	"github.com/coreos/ignition/v2/config/util"
+
+	vpath "github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (s Systemd) Validate(c vpath.ContextPath) (r report.Report) {
+	units := make(map[string]Unit)
+	checkInstanceUnit := regexp.MustCompile(`^(.+?)@(.+?)\.service$`)
+	for _, d := range s.Units {
+		units[d.Name] = d
+	}
+	for index, unit := range s.Units {
+		if checkInstanceUnit.MatchString(unit.Name) && util.IsTrue(unit.Enabled) {
+			instUnitSlice := checkInstanceUnit.FindSubmatch([]byte(unit.Name))
+			instantiableUnit := string(instUnitSlice[1]) + "@.service"
+			if _, ok := units[instantiableUnit]; ok && util.NotEmpty(units[instantiableUnit].Contents) {
+				foundInstallSection := false
+				// we're doing a separate validation pass on each unit to identify
+				// if an instantiable unit has the install section. So logging an
+				// `AddOnError` will produce duplicate errors on bad unit contents
+				// because we're already doing that while validating a unit separately.
+				opts, err := parse.ParseUnitContents(units[instantiableUnit].Contents)
+				if err != nil {
+					continue
+				}
+				for _, section := range opts {
+					if section.Section == "Install" {
+						foundInstallSection = true
+						break
+					}
+				}
+				if !foundInstallSection {
+					r.AddOnWarn(c.Append("units", index, "contents"), errors.NewNoInstallSectionForInstantiableUnitError(instantiableUnit, unit.Name))
+				}
+			}
+		}
+	}
+	return
+}
diff --git a/config/v3_1/types/systemd_test.go b/config/v3_1/types/systemd_test.go
new file mode 100644
index 00000000..798eb10f
--- /dev/null
+++ b/config/v3_1/types/systemd_test.go
@@ -0,0 +1,105 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestSystemdValidate(t *testing.T) {
+	tests := []struct {
+		in  Systemd
+		out error
+	}{
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			errors.NewNoInstallSectionForInstantiableUnitError("test@.service", "test@foo.service"),
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service"},
+					{Name: "test@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+	}
+
+	for i, test := range tests {
+		t.Run(fmt.Sprintf("validate %d", i), func(t *testing.T) {
+			actual := test.in.Validate(path.ContextPath{})
+			expected := report.Report{}
+			expected.AddOnWarn(path.ContextPath{}.Append("units", 1, "contents"), test.out)
+			assert.Equal(t, expected, actual, "bad report")
+		})
+	}
+}
diff --git a/config/v3_1/types/unit.go b/config/v3_1/types/unit.go
index e0e5c50a..786debae 100644
--- a/config/v3_1/types/unit.go
+++ b/config/v3_1/types/unit.go
@@ -15,15 +15,13 @@
 package types
 
 import (
-	"fmt"
 	"path"
-	"strings"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
 	"github.com/coreos/ignition/v2/config/shared/validations"
 	"github.com/coreos/ignition/v2/config/util"
 
-	"github.com/coreos/go-systemd/v22/unit"
 	cpath "github.com/coreos/vcontext/path"
 	"github.com/coreos/vcontext/report"
 )
@@ -39,7 +37,7 @@ func (d Dropin) Key() string {
 func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
 	r.AddOnError(c.Append("name"), validateName(u.Name))
 	c = c.Append("contents")
-	opts, err := validateUnitContent(u.Contents)
+	opts, err := parse.ParseUnitContents(u.Contents)
 	r.AddOnError(c, err)
 
 	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, util.IsTrue(u.Enabled), util.NilOrEmpty(u.Contents), opts))
@@ -57,7 +55,7 @@ func validateName(name string) error {
 }
 
 func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
-	_, err := validateUnitContent(d.Contents)
+	_, err := parse.ParseUnitContents(d.Contents)
 	r.AddOnError(c.Append("contents"), err)
 
 	switch path.Ext(d.Name) {
@@ -68,15 +66,3 @@ func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
 
 	return
 }
-
-func validateUnitContent(content *string) ([]*unit.UnitOption, error) {
-	if content == nil {
-		return []*unit.UnitOption{}, nil
-	}
-	c := strings.NewReader(*content)
-	opts, err := unit.Deserialize(c)
-	if err != nil {
-		return nil, fmt.Errorf("invalid unit content: %s", err)
-	}
-	return opts, nil
-}
diff --git a/config/v3_2/types/config.go b/config/v3_2/types/config.go
index 4b18d537..0e2fc370 100644
--- a/config/v3_2/types/config.go
+++ b/config/v3_2/types/config.go
@@ -15,7 +15,12 @@
 package types
 
 import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
 	"github.com/coreos/go-semver/semver"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
 )
 
 var (
@@ -24,3 +29,36 @@ var (
 		Minor: 2,
 	}
 )
+
+func (cfg Config) Validate(c path.ContextPath) (r report.Report) {
+	systemdPath := "/etc/systemd/system/"
+	unitPaths := map[string]struct{}{}
+	for _, unit := range cfg.Systemd.Units {
+		if !util.NilOrEmpty(unit.Contents) {
+			pathString := systemdPath + unit.Name
+			unitPaths[pathString] = struct{}{}
+		}
+		for _, dropin := range unit.Dropins {
+			if !util.NilOrEmpty(dropin.Contents) {
+				pathString := systemdPath + unit.Name + ".d/" + dropin.Name
+				unitPaths[pathString] = struct{}{}
+			}
+		}
+	}
+	for i, f := range cfg.Storage.Files {
+		if _, exists := unitPaths[f.Path]; exists {
+			r.AddOnError(c.Append("storage", "files", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, d := range cfg.Storage.Directories {
+		if _, exists := unitPaths[d.Path]; exists {
+			r.AddOnError(c.Append("storage", "directories", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, l := range cfg.Storage.Links {
+		if _, exists := unitPaths[l.Path]; exists {
+			r.AddOnError(c.Append("storage", "links", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	return
+}
diff --git a/config/v3_2/types/config_test.go b/config/v3_2/types/config_test.go
new file mode 100644
index 00000000..da8cfa26
--- /dev/null
+++ b/config/v3_2/types/config_test.go
@@ -0,0 +1,260 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestConfigValidation(t *testing.T) {
+	tests := []struct {
+		in  Config
+		out error
+		at  path.ContextPath
+	}{
+		// test 0: file conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 1: file conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 2: directory conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 3: directory conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 4: link conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/qux.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 5: link conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/qux.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 6: non-conflicting scenarios
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service.d/baz.conf"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/qux.conf"},
+						},
+					},
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/qux.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/qux.conf"},
+						},
+						{
+							Node:          Node{Path: "/etc/systemd/system/quux.service.d/foo.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: "/foo.conf"},
+						},
+					},
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/quux.service.d"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+						{
+							Name: "bar.service",
+							Dropins: []Dropin{
+								{
+									Name: "baz.conf",
+								},
+							},
+							Enabled: util.BoolToPtr(true),
+						},
+						{
+							Name: "qux.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+								},
+							},
+						},
+						{
+							Name:     "quux.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+		},
+	}
+	for i, test := range tests {
+		r := test.in.Validate(path.New("json"))
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad error: expected : %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_2/types/storage.go b/config/v3_2/types/storage.go
index fd1b8cec..5cec008d 100644
--- a/config/v3_2/types/storage.go
+++ b/config/v3_2/types/storage.go
@@ -34,6 +34,14 @@ func (s Storage) MergedKeys() map[string]string {
 }
 
 func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
+	s.validateDirectories(c, &r)
+	s.validateFiles(c, &r)
+	s.validateLinks(c, &r)
+	s.validateFilesystems(c, &r)
+	return
+}
+
+func (s Storage) validateDirectories(c vpath.ContextPath, r *report.Report) {
 	for i, d := range s.Directories {
 		for _, l := range s.Links {
 			if strings.HasPrefix(d.Path, l.Path+"/") {
@@ -41,6 +49,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateFiles(c vpath.ContextPath, r *report.Report) {
 	for i, f := range s.Files {
 		for _, l := range s.Links {
 			if strings.HasPrefix(f.Path, l.Path+"/") {
@@ -48,6 +59,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateLinks(c vpath.ContextPath, r *report.Report) {
 	for i, l1 := range s.Links {
 		for _, l2 := range s.Links {
 			if strings.HasPrefix(l1.Path, l2.Path+"/") {
@@ -66,6 +80,32 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
 			}
 		}
+		ownerCheck := func(ok bool, path vpath.ContextPath) {
+			if !ok {
+				r.AddOnWarn(path, errors.ErrHardLinkSpecifiesOwner)
+			}
+		}
+		ownerCheck(l1.User.ID == nil, c.Append("links", i, "user", "id"))
+		ownerCheck(l1.User.Name == nil, c.Append("links", i, "user", "name"))
+		ownerCheck(l1.Group.ID == nil, c.Append("links", i, "group", "id"))
+		ownerCheck(l1.Group.Name == nil, c.Append("links", i, "group", "name"))
+	}
+}
+
+func (s Storage) validateFilesystems(c vpath.ContextPath, r *report.Report) {
+	disks := make(map[string]Disk)
+	for _, d := range s.Disks {
+		disks[d.Device] = d
+	}
+
+	for i, f := range s.Filesystems {
+		disk, exist := disks[f.Device]
+		if exist {
+			if len(disk.Partitions) > 0 {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrPartitionsOverwritten)
+			} else if !util.IsTrue(f.WipeFilesystem) && util.IsTrue(disk.WipeTable) {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrFilesystemImplicitWipe)
+			}
+		}
 	}
-	return
 }
diff --git a/config/v3_2/types/storage_test.go b/config/v3_2/types/storage_test.go
index 7d27bd55..4667b8d2 100644
--- a/config/v3_2/types/storage_test.go
+++ b/config/v3_2/types/storage_test.go
@@ -25,16 +25,18 @@ import (
 	"github.com/coreos/vcontext/report"
 )
 
-func TestStorageValidate(t *testing.T) {
+func TestStorageValidateErrors(t *testing.T) {
 	tests := []struct {
-		in  Storage
-		at  path.ContextPath
-		out error
+		in   Storage
+		at   path.ContextPath
+		err  error
+		warn error
 	}{
+		// test empty storage config returns nil
 		{
-			in:  Storage{},
-			out: nil,
+			in: Storage{},
 		},
+		// test a storage config with no conflicting paths returns nil
 		{
 			in: Storage{
 				Links: []Link{
@@ -56,8 +58,8 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: nil,
 		},
+		// test when a file uses a configured symlink path returns ErrFileUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -71,9 +73,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrFileUsedSymlink,
+			err: errors.ErrFileUsedSymlink,
 			at:  path.New("", "files", 0),
 		},
+		// test when a directory uses a configured symlink path returns ErrDirectoryUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -87,9 +90,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrDirectoryUsedSymlink,
+			err: errors.ErrDirectoryUsedSymlink,
 			at:  path.New("", "directories", 0),
 		},
+		// test the same path listed for two separate symlinks returns ErrLinkUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -101,9 +105,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrLinkUsedSymlink,
+			err: errors.ErrLinkUsedSymlink,
 			at:  path.New("", "links", 1),
 		},
+		// test that two symlinks can be configured at a time
 		{
 			in: Storage{
 				Links: []Link{
@@ -115,8 +120,8 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: nil,
 		},
+		// test when a directory uses a configured symlink with the 'Hard:= true' returns ErrHardLinkToDirectory
 		{
 			in: Storage{
 				Links: []Link{
@@ -134,15 +139,185 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrHardLinkToDirectory,
+			err: errors.ErrHardLinkToDirectory,
 			at:  path.New("", "links", 0),
 		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "name"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: "/foo/bar",
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "name"),
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.err)
+		expected.AddOnWarn(test.at, test.warn)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
+
+func TestStorageValidateWarnings(t *testing.T) {
+	tests := []struct {
+		in  Storage
+		at  path.ContextPath
+		out error
+	}{
+		// test a disk with partitions with the same 'device' as a filesystem returns ErrPartitionsOverwritten
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sda",
+						Partitions: []Partition{
+							{}, {},
+						},
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrPartitionsOverwritten,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=true' as a configured filesystem returns ErrFilesystemImplicitWipe
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(true),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrFilesystemImplicitWipe,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=false' as a configured filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(false),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: nil,
+		},
+		// test a disk with no partitions with the same 'device' as a filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+			},
+			out: nil,
+		},
 	}
 
 	for i, test := range tests {
 		r := test.in.Validate(path.ContextPath{})
 		expected := report.Report{}
-		expected.AddOnError(test.at, test.out)
+		expected.AddOnWarn(test.at, test.out)
 		if !reflect.DeepEqual(expected, r) {
 			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
 		}
diff --git a/config/v3_2/types/systemd.go b/config/v3_2/types/systemd.go
new file mode 100644
index 00000000..ac521ba7
--- /dev/null
+++ b/config/v3_2/types/systemd.go
@@ -0,0 +1,61 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"regexp"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
+	"github.com/coreos/ignition/v2/config/util"
+
+	vpath "github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (s Systemd) Validate(c vpath.ContextPath) (r report.Report) {
+	units := make(map[string]Unit)
+	checkInstanceUnit := regexp.MustCompile(`^(.+?)@(.+?)\.service$`)
+	for _, d := range s.Units {
+		units[d.Name] = d
+	}
+	for index, unit := range s.Units {
+		if checkInstanceUnit.MatchString(unit.Name) && util.IsTrue(unit.Enabled) {
+			instUnitSlice := checkInstanceUnit.FindSubmatch([]byte(unit.Name))
+			instantiableUnit := string(instUnitSlice[1]) + "@.service"
+			if _, ok := units[instantiableUnit]; ok && util.NotEmpty(units[instantiableUnit].Contents) {
+				foundInstallSection := false
+				// we're doing a separate validation pass on each unit to identify
+				// if an instantiable unit has the install section. So logging an
+				// `AddOnError` will produce duplicate errors on bad unit contents
+				// because we're already doing that while validating a unit separately.
+				opts, err := parse.ParseUnitContents(units[instantiableUnit].Contents)
+				if err != nil {
+					continue
+				}
+				for _, section := range opts {
+					if section.Section == "Install" {
+						foundInstallSection = true
+						break
+					}
+				}
+				if !foundInstallSection {
+					r.AddOnWarn(c.Append("units", index, "contents"), errors.NewNoInstallSectionForInstantiableUnitError(instantiableUnit, unit.Name))
+				}
+			}
+		}
+	}
+	return
+}
diff --git a/config/v3_2/types/systemd_test.go b/config/v3_2/types/systemd_test.go
new file mode 100644
index 00000000..798eb10f
--- /dev/null
+++ b/config/v3_2/types/systemd_test.go
@@ -0,0 +1,105 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestSystemdValidate(t *testing.T) {
+	tests := []struct {
+		in  Systemd
+		out error
+	}{
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			errors.NewNoInstallSectionForInstantiableUnitError("test@.service", "test@foo.service"),
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service"},
+					{Name: "test@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+	}
+
+	for i, test := range tests {
+		t.Run(fmt.Sprintf("validate %d", i), func(t *testing.T) {
+			actual := test.in.Validate(path.ContextPath{})
+			expected := report.Report{}
+			expected.AddOnWarn(path.ContextPath{}.Append("units", 1, "contents"), test.out)
+			assert.Equal(t, expected, actual, "bad report")
+		})
+	}
+}
diff --git a/config/v3_2/types/unit.go b/config/v3_2/types/unit.go
index bc2d3299..c5ee1e8e 100644
--- a/config/v3_2/types/unit.go
+++ b/config/v3_2/types/unit.go
@@ -15,15 +15,13 @@
 package types
 
 import (
-	"fmt"
 	"path"
-	"strings"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
 	"github.com/coreos/ignition/v2/config/shared/validations"
 	"github.com/coreos/ignition/v2/config/util"
 
-	"github.com/coreos/go-systemd/v22/unit"
 	cpath "github.com/coreos/vcontext/path"
 	"github.com/coreos/vcontext/report"
 )
@@ -39,7 +37,7 @@ func (d Dropin) Key() string {
 func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
 	r.AddOnError(c.Append("name"), validateName(u.Name))
 	c = c.Append("contents")
-	opts, err := validateUnitContent(u.Contents)
+	opts, err := parse.ParseUnitContents(u.Contents)
 	r.AddOnError(c, err)
 
 	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, util.IsTrue(u.Enabled), util.NilOrEmpty(u.Contents), opts))
@@ -57,7 +55,7 @@ func validateName(name string) error {
 }
 
 func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
-	_, err := validateUnitContent(d.Contents)
+	_, err := parse.ParseUnitContents(d.Contents)
 	r.AddOnError(c.Append("contents"), err)
 
 	switch path.Ext(d.Name) {
@@ -68,15 +66,3 @@ func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
 
 	return
 }
-
-func validateUnitContent(content *string) ([]*unit.UnitOption, error) {
-	if content == nil {
-		return []*unit.UnitOption{}, nil
-	}
-	c := strings.NewReader(*content)
-	opts, err := unit.Deserialize(c)
-	if err != nil {
-		return nil, fmt.Errorf("invalid unit content: %s", err)
-	}
-	return opts, nil
-}
diff --git a/config/v3_3/types/config.go b/config/v3_3/types/config.go
index fdccc194..9158e7f0 100644
--- a/config/v3_3/types/config.go
+++ b/config/v3_3/types/config.go
@@ -15,7 +15,12 @@
 package types
 
 import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
 	"github.com/coreos/go-semver/semver"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
 )
 
 var (
@@ -24,3 +29,36 @@ var (
 		Minor: 3,
 	}
 )
+
+func (cfg Config) Validate(c path.ContextPath) (r report.Report) {
+	systemdPath := "/etc/systemd/system/"
+	unitPaths := map[string]struct{}{}
+	for _, unit := range cfg.Systemd.Units {
+		if !util.NilOrEmpty(unit.Contents) {
+			pathString := systemdPath + unit.Name
+			unitPaths[pathString] = struct{}{}
+		}
+		for _, dropin := range unit.Dropins {
+			if !util.NilOrEmpty(dropin.Contents) {
+				pathString := systemdPath + unit.Name + ".d/" + dropin.Name
+				unitPaths[pathString] = struct{}{}
+			}
+		}
+	}
+	for i, f := range cfg.Storage.Files {
+		if _, exists := unitPaths[f.Path]; exists {
+			r.AddOnError(c.Append("storage", "files", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, d := range cfg.Storage.Directories {
+		if _, exists := unitPaths[d.Path]; exists {
+			r.AddOnError(c.Append("storage", "directories", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, l := range cfg.Storage.Links {
+		if _, exists := unitPaths[l.Path]; exists {
+			r.AddOnError(c.Append("storage", "links", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	return
+}
diff --git a/config/v3_3/types/config_test.go b/config/v3_3/types/config_test.go
new file mode 100644
index 00000000..3d82627b
--- /dev/null
+++ b/config/v3_3/types/config_test.go
@@ -0,0 +1,260 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestConfigValidation(t *testing.T) {
+	tests := []struct {
+		in  Config
+		out error
+		at  path.ContextPath
+	}{
+		// test 0: file conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 1: file conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 2: directory conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 3: directory conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 4: link conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/qux.conf")},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 5: link conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/qux.conf")},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 6: non-conflicting scenarios
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service.d/baz.conf"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/qux.conf"},
+						},
+					},
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/qux.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/qux.conf")},
+						},
+						{
+							Node:          Node{Path: "/etc/systemd/system/quux.service.d/foo.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo.conf")},
+						},
+					},
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/quux.service.d"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+						{
+							Name: "bar.service",
+							Dropins: []Dropin{
+								{
+									Name: "baz.conf",
+								},
+							},
+							Enabled: util.BoolToPtr(true),
+						},
+						{
+							Name: "qux.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+								},
+							},
+						},
+						{
+							Name:     "quux.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+		},
+	}
+	for i, test := range tests {
+		r := test.in.Validate(path.New("json"))
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad error: expected : %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_3/types/storage.go b/config/v3_3/types/storage.go
index 02108613..20cb7304 100644
--- a/config/v3_3/types/storage.go
+++ b/config/v3_3/types/storage.go
@@ -34,6 +34,14 @@ func (s Storage) MergedKeys() map[string]string {
 }
 
 func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
+	s.validateDirectories(c, &r)
+	s.validateFiles(c, &r)
+	s.validateLinks(c, &r)
+	s.validateFilesystems(c, &r)
+	return
+}
+
+func (s Storage) validateDirectories(c vpath.ContextPath, r *report.Report) {
 	for i, d := range s.Directories {
 		for _, l := range s.Links {
 			if strings.HasPrefix(d.Path, l.Path+"/") {
@@ -41,6 +49,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateFiles(c vpath.ContextPath, r *report.Report) {
 	for i, f := range s.Files {
 		for _, l := range s.Links {
 			if strings.HasPrefix(f.Path, l.Path+"/") {
@@ -48,6 +59,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateLinks(c vpath.ContextPath, r *report.Report) {
 	for i, l1 := range s.Links {
 		for _, l2 := range s.Links {
 			if strings.HasPrefix(l1.Path, l2.Path+"/") {
@@ -70,6 +84,32 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
 			}
 		}
+		ownerCheck := func(ok bool, path vpath.ContextPath) {
+			if !ok {
+				r.AddOnWarn(path, errors.ErrHardLinkSpecifiesOwner)
+			}
+		}
+		ownerCheck(l1.User.ID == nil, c.Append("links", i, "user", "id"))
+		ownerCheck(l1.User.Name == nil, c.Append("links", i, "user", "name"))
+		ownerCheck(l1.Group.ID == nil, c.Append("links", i, "group", "id"))
+		ownerCheck(l1.Group.Name == nil, c.Append("links", i, "group", "name"))
+	}
+}
+
+func (s Storage) validateFilesystems(c vpath.ContextPath, r *report.Report) {
+	disks := make(map[string]Disk)
+	for _, d := range s.Disks {
+		disks[d.Device] = d
+	}
+
+	for i, f := range s.Filesystems {
+		disk, exist := disks[f.Device]
+		if exist {
+			if len(disk.Partitions) > 0 {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrPartitionsOverwritten)
+			} else if !util.IsTrue(f.WipeFilesystem) && util.IsTrue(disk.WipeTable) {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrFilesystemImplicitWipe)
+			}
+		}
 	}
-	return
 }
diff --git a/config/v3_3/types/storage_test.go b/config/v3_3/types/storage_test.go
index cb9256cf..551688a2 100644
--- a/config/v3_3/types/storage_test.go
+++ b/config/v3_3/types/storage_test.go
@@ -25,16 +25,18 @@ import (
 	"github.com/coreos/vcontext/report"
 )
 
-func TestStorageValidate(t *testing.T) {
+func TestStorageValidateErrors(t *testing.T) {
 	tests := []struct {
-		in  Storage
-		at  path.ContextPath
-		out error
+		in   Storage
+		at   path.ContextPath
+		err  error
+		warn error
 	}{
+		// test empty storage config returns nil
 		{
-			in:  Storage{},
-			out: nil,
+			in: Storage{},
 		},
+		// test a storage config with no conflicting paths returns nil
 		{
 			in: Storage{
 				Links: []Link{
@@ -58,8 +60,8 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: nil,
 		},
+		// test when a file uses a configured symlink path returns ErrFileUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -74,9 +76,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrFileUsedSymlink,
+			err: errors.ErrFileUsedSymlink,
 			at:  path.New("", "files", 0),
 		},
+		// test when a directory uses a configured symlink path returns ErrDirectoryUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -91,9 +94,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrDirectoryUsedSymlink,
+			err: errors.ErrDirectoryUsedSymlink,
 			at:  path.New("", "directories", 0),
 		},
+		// test the same path listed for two separate symlinks returns ErrLinkUsedSymlink
 		{
 			in: Storage{
 				Links: []Link{
@@ -107,9 +111,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrLinkUsedSymlink,
+			err: errors.ErrLinkUsedSymlink,
 			at:  path.New("", "links", 1),
 		},
+		// test a configured symlink with no target returns ErrLinkTargetRequired
 		{
 			in: Storage{
 				Links: []Link{
@@ -119,9 +124,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrLinkTargetRequired,
+			err: errors.ErrLinkTargetRequired,
 			at:  path.New("", "links", 0, "target"),
 		},
+		// test a configured symlink with a nil target returns ErrLinkTargetRequired
 		{
 			in: Storage{
 				Links: []Link{
@@ -131,9 +137,10 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrLinkTargetRequired,
+			err: errors.ErrLinkTargetRequired,
 			at:  path.New("", "links", 0, "target"),
 		},
+		// test that two symlinks can be configured at a time
 		{
 			in: Storage{
 				Links: []Link{
@@ -147,8 +154,8 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: nil,
 		},
+		// test when a directory uses a configured symlink with the 'Hard:= true' returns ErrHardLinkToDirectory
 		{
 			in: Storage{
 				Links: []Link{
@@ -166,15 +173,185 @@ func TestStorageValidate(t *testing.T) {
 					},
 				},
 			},
-			out: errors.ErrHardLinkToDirectory,
+			err: errors.ErrHardLinkToDirectory,
 			at:  path.New("", "links", 0),
 		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "name"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "name"),
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.err)
+		expected.AddOnWarn(test.at, test.warn)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
+
+func TestStorageValidateWarnings(t *testing.T) {
+	tests := []struct {
+		in  Storage
+		at  path.ContextPath
+		out error
+	}{
+		// test a disk with partitions with the same 'device' as a filesystem returns ErrPartitionsOverwritten
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sda",
+						Partitions: []Partition{
+							{}, {},
+						},
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrPartitionsOverwritten,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=true' as a configured filesystem returns ErrFilesystemImplicitWipe
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(true),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrFilesystemImplicitWipe,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=false' as a configured filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(false),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: nil,
+		},
+		// test a disk with no partitions with the same 'device' as a filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+			},
+			out: nil,
+		},
 	}
 
 	for i, test := range tests {
 		r := test.in.Validate(path.ContextPath{})
 		expected := report.Report{}
-		expected.AddOnError(test.at, test.out)
+		expected.AddOnWarn(test.at, test.out)
 		if !reflect.DeepEqual(expected, r) {
 			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
 		}
diff --git a/config/v3_3/types/systemd.go b/config/v3_3/types/systemd.go
new file mode 100644
index 00000000..ac521ba7
--- /dev/null
+++ b/config/v3_3/types/systemd.go
@@ -0,0 +1,61 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"regexp"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
+	"github.com/coreos/ignition/v2/config/util"
+
+	vpath "github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (s Systemd) Validate(c vpath.ContextPath) (r report.Report) {
+	units := make(map[string]Unit)
+	checkInstanceUnit := regexp.MustCompile(`^(.+?)@(.+?)\.service$`)
+	for _, d := range s.Units {
+		units[d.Name] = d
+	}
+	for index, unit := range s.Units {
+		if checkInstanceUnit.MatchString(unit.Name) && util.IsTrue(unit.Enabled) {
+			instUnitSlice := checkInstanceUnit.FindSubmatch([]byte(unit.Name))
+			instantiableUnit := string(instUnitSlice[1]) + "@.service"
+			if _, ok := units[instantiableUnit]; ok && util.NotEmpty(units[instantiableUnit].Contents) {
+				foundInstallSection := false
+				// we're doing a separate validation pass on each unit to identify
+				// if an instantiable unit has the install section. So logging an
+				// `AddOnError` will produce duplicate errors on bad unit contents
+				// because we're already doing that while validating a unit separately.
+				opts, err := parse.ParseUnitContents(units[instantiableUnit].Contents)
+				if err != nil {
+					continue
+				}
+				for _, section := range opts {
+					if section.Section == "Install" {
+						foundInstallSection = true
+						break
+					}
+				}
+				if !foundInstallSection {
+					r.AddOnWarn(c.Append("units", index, "contents"), errors.NewNoInstallSectionForInstantiableUnitError(instantiableUnit, unit.Name))
+				}
+			}
+		}
+	}
+	return
+}
diff --git a/config/v3_3/types/systemd_test.go b/config/v3_3/types/systemd_test.go
new file mode 100644
index 00000000..798eb10f
--- /dev/null
+++ b/config/v3_3/types/systemd_test.go
@@ -0,0 +1,105 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestSystemdValidate(t *testing.T) {
+	tests := []struct {
+		in  Systemd
+		out error
+	}{
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			errors.NewNoInstallSectionForInstantiableUnitError("test@.service", "test@foo.service"),
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service"},
+					{Name: "test@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+	}
+
+	for i, test := range tests {
+		t.Run(fmt.Sprintf("validate %d", i), func(t *testing.T) {
+			actual := test.in.Validate(path.ContextPath{})
+			expected := report.Report{}
+			expected.AddOnWarn(path.ContextPath{}.Append("units", 1, "contents"), test.out)
+			assert.Equal(t, expected, actual, "bad report")
+		})
+	}
+}
diff --git a/config/v3_3/types/unit.go b/config/v3_3/types/unit.go
index bc2d3299..c5ee1e8e 100644
--- a/config/v3_3/types/unit.go
+++ b/config/v3_3/types/unit.go
@@ -15,15 +15,13 @@
 package types
 
 import (
-	"fmt"
 	"path"
-	"strings"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
 	"github.com/coreos/ignition/v2/config/shared/validations"
 	"github.com/coreos/ignition/v2/config/util"
 
-	"github.com/coreos/go-systemd/v22/unit"
 	cpath "github.com/coreos/vcontext/path"
 	"github.com/coreos/vcontext/report"
 )
@@ -39,7 +37,7 @@ func (d Dropin) Key() string {
 func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
 	r.AddOnError(c.Append("name"), validateName(u.Name))
 	c = c.Append("contents")
-	opts, err := validateUnitContent(u.Contents)
+	opts, err := parse.ParseUnitContents(u.Contents)
 	r.AddOnError(c, err)
 
 	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, util.IsTrue(u.Enabled), util.NilOrEmpty(u.Contents), opts))
@@ -57,7 +55,7 @@ func validateName(name string) error {
 }
 
 func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
-	_, err := validateUnitContent(d.Contents)
+	_, err := parse.ParseUnitContents(d.Contents)
 	r.AddOnError(c.Append("contents"), err)
 
 	switch path.Ext(d.Name) {
@@ -68,15 +66,3 @@ func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
 
 	return
 }
-
-func validateUnitContent(content *string) ([]*unit.UnitOption, error) {
-	if content == nil {
-		return []*unit.UnitOption{}, nil
-	}
-	c := strings.NewReader(*content)
-	opts, err := unit.Deserialize(c)
-	if err != nil {
-		return nil, fmt.Errorf("invalid unit content: %s", err)
-	}
-	return opts, nil
-}
diff --git a/config/v3_4_experimental/config.go b/config/v3_4/config.go
similarity index 90%
rename from config/v3_4_experimental/config.go
rename to config/v3_4/config.go
index a8836488..e83abb0b 100644
--- a/config/v3_4_experimental/config.go
+++ b/config/v3_4/config.go
@@ -12,15 +12,15 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package v3_4_experimental
+package v3_4
 
 import (
 	"github.com/coreos/ignition/v2/config/merge"
 	"github.com/coreos/ignition/v2/config/shared/errors"
 	"github.com/coreos/ignition/v2/config/util"
 	prev "github.com/coreos/ignition/v2/config/v3_3"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/translate"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_4/translate"
+	"github.com/coreos/ignition/v2/config/v3_4/types"
 	"github.com/coreos/ignition/v2/config/validate"
 
 	"github.com/coreos/go-semver/semver"
@@ -58,8 +58,8 @@ func Parse(rawConfig []byte) (types.Config, report.Report, error) {
 	return config, rpt, nil
 }
 
-// ParseCompatibleVersion parses the raw config of version 3.4.0-experimental or
-// lesser into a 3.4-exp types.Config struct and generates a report of any errors,
+// ParseCompatibleVersion parses the raw config of version 3.4.0 or
+// lesser into a 3.4 types.Config struct and generates a report of any errors,
 // warnings, info, and deprecations it encountered
 func ParseCompatibleVersion(raw []byte) (types.Config, report.Report, error) {
 	version, rpt, err := util.GetConfigVersion(raw)
diff --git a/config/v3_4_experimental/config_test.go b/config/v3_4/config_test.go
similarity index 91%
rename from config/v3_4_experimental/config_test.go
rename to config/v3_4/config_test.go
index 97253860..0ee908d7 100644
--- a/config/v3_4_experimental/config_test.go
+++ b/config/v3_4/config_test.go
@@ -12,13 +12,13 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-package v3_4_experimental
+package v3_4
 
 import (
 	"testing"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_4/types"
 	"github.com/stretchr/testify/assert"
 )
 
@@ -79,6 +79,10 @@ func TestParse(t *testing.T) {
 			in:  in{config: []byte(`{"ignition": {"version": "3.3.0"}}`)},
 			out: out{err: errors.ErrUnknownVersion},
 		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.4.0"}}`)},
+			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
+		},
 		{
 			in:  in{config: []byte(`{"ignition": {"version": "2.0.0-experimental"}}`)},
 			out: out{err: errors.ErrUnknownVersion},
@@ -121,7 +125,7 @@ func TestParse(t *testing.T) {
 		},
 		{
 			in:  in{config: []byte(`{"ignition": {"version": "3.4.0-experimental"}}`)},
-			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
+			out: out{err: errors.ErrUnknownVersion},
 		},
 		{
 			in:  in{config: []byte(`{"ignition": {"version": "2.0.0"},}`)},
@@ -140,7 +144,7 @@ func TestParse(t *testing.T) {
 			out: out{err: errors.ErrEmpty},
 		},
 		{
-			in:  in{config: []byte(`{"ignition": {"version": "3.4.0-experimental"}, "storage": {"filesystems": [{"format": "ext4", "label": "zzzzzzzzzzzzzzzzzzzzzzzzzzz"}]}}`)},
+			in:  in{config: []byte(`{"ignition": {"version": "3.4.0"}, "storage": {"filesystems": [{"format": "ext4", "label": "zzzzzzzzzzzzzzzzzzzzzzzzzzz"}]}}`)},
 			out: out{err: errors.ErrInvalid},
 		},
 	}
@@ -166,9 +170,13 @@ func TestParse(t *testing.T) {
 			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
 		},
 		{
-			in:  in{config: []byte(`{"ignition": {"version": "3.4.0-experimental"}}`)},
+			in:  in{config: []byte(`{"ignition": {"version": "3.4.0"}}`)},
 			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
 		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.4.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
 		{
 			in:  in{config: []byte(`{"ignition": {"version": "3.5.0"}}`)},
 			out: out{err: errors.ErrUnknownVersion},
@@ -182,7 +190,7 @@ func TestParse(t *testing.T) {
 			out: out{err: errors.ErrInvalid},
 		},
 		{
-			in:  in{config: []byte(`{"ignition": {"version": "3.4.0-experimental"}, "storage": {"filesystems": [{"format": "ext4", "label": "zzzzzzzzzzzzzzzzzzzzzzzzzzz"}]}}`)},
+			in:  in{config: []byte(`{"ignition": {"version": "3.4.0"}, "storage": {"filesystems": [{"format": "ext4", "label": "zzzzzzzzzzzzzzzzzzzzzzzzzzz"}]}}`)},
 			out: out{err: errors.ErrInvalid},
 		},
 	}
diff --git a/config/v3_4_experimental/schema/ignition.json b/config/v3_4/schema/ignition.json
similarity index 98%
rename from config/v3_4_experimental/schema/ignition.json
rename to config/v3_4/schema/ignition.json
index d93ce6c2..740125bb 100644
--- a/config/v3_4_experimental/schema/ignition.json
+++ b/config/v3_4/schema/ignition.json
@@ -271,6 +271,15 @@
               "items": {
                 "type": "string"
               }
+            },
+            "discard": {
+              "type": ["boolean", "null"]
+            },
+            "openOptions": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
             }
           },
           "required": [
@@ -319,6 +328,9 @@
             },
             "thumbprint": {
               "type": ["string", "null"]
+            },
+            "advertisement": {
+              "type": ["string", "null"]
             }
           }
         },
diff --git a/config/v3_4_experimental/translate/translate.go b/config/v3_4/translate/translate.go
similarity index 74%
rename from config/v3_4_experimental/translate/translate.go
rename to config/v3_4/translate/translate.go
index 2539c8f4..5d748d82 100644
--- a/config/v3_4_experimental/translate/translate.go
+++ b/config/v3_4/translate/translate.go
@@ -18,7 +18,7 @@ import (
 	"github.com/coreos/ignition/v2/config/translate"
 	"github.com/coreos/ignition/v2/config/util"
 	old_types "github.com/coreos/ignition/v2/config/v3_3/types"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_4/types"
 )
 
 func translateIgnition(old old_types.Ignition) (ret types.Ignition) {
@@ -53,11 +53,33 @@ func translateDirectoryEmbedded1(old old_types.DirectoryEmbedded1) (ret types.Di
 	return
 }
 
+func translateLuks(old old_types.Luks) (ret types.Luks) {
+	tr := translate.NewTranslator()
+	tr.AddCustomTranslator(translateTang)
+	tr.Translate(&old.Clevis, &ret.Clevis)
+	tr.Translate(&old.Device, &ret.Device)
+	tr.Translate(&old.KeyFile, &ret.KeyFile)
+	tr.Translate(&old.Label, &ret.Label)
+	tr.Translate(&old.Name, &ret.Name)
+	tr.Translate(&old.Options, &ret.Options)
+	tr.Translate(&old.UUID, &ret.UUID)
+	tr.Translate(&old.WipeVolume, &ret.WipeVolume)
+	return
+}
+
+func translateTang(old old_types.Tang) (ret types.Tang) {
+	tr := translate.NewTranslator()
+	tr.Translate(&old.Thumbprint, &ret.Thumbprint)
+	tr.Translate(&old.URL, &ret.URL)
+	return
+}
+
 func Translate(old old_types.Config) (ret types.Config) {
 	tr := translate.NewTranslator()
 	tr.AddCustomTranslator(translateIgnition)
 	tr.AddCustomTranslator(translateDirectoryEmbedded1)
 	tr.AddCustomTranslator(translateFileEmbedded1)
+	tr.AddCustomTranslator(translateLuks)
 	tr.Translate(&old, &ret)
 	return
 }
diff --git a/config/v3_4_experimental/translate/translate_test.go b/config/v3_4/translate/translate_test.go
similarity index 100%
rename from config/v3_4_experimental/translate/translate_test.go
rename to config/v3_4/translate/translate_test.go
diff --git a/config/v3_4_experimental/types/clevis.go b/config/v3_4/types/clevis.go
similarity index 100%
rename from config/v3_4_experimental/types/clevis.go
rename to config/v3_4/types/clevis.go
diff --git a/config/v3_4_experimental/types/clevis_test.go b/config/v3_4/types/clevis_test.go
similarity index 100%
rename from config/v3_4_experimental/types/clevis_test.go
rename to config/v3_4/types/clevis_test.go
diff --git a/config/v3_4/types/config.go b/config/v3_4/types/config.go
new file mode 100644
index 00000000..4f51f3c6
--- /dev/null
+++ b/config/v3_4/types/config.go
@@ -0,0 +1,64 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/go-semver/semver"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+var (
+	MaxVersion = semver.Version{
+		Major: 3,
+		Minor: 4,
+	}
+)
+
+func (cfg Config) Validate(c path.ContextPath) (r report.Report) {
+	systemdPath := "/etc/systemd/system/"
+	unitPaths := map[string]struct{}{}
+	for _, unit := range cfg.Systemd.Units {
+		if !util.NilOrEmpty(unit.Contents) {
+			pathString := systemdPath + unit.Name
+			unitPaths[pathString] = struct{}{}
+		}
+		for _, dropin := range unit.Dropins {
+			if !util.NilOrEmpty(dropin.Contents) {
+				pathString := systemdPath + unit.Name + ".d/" + dropin.Name
+				unitPaths[pathString] = struct{}{}
+			}
+		}
+	}
+	for i, f := range cfg.Storage.Files {
+		if _, exists := unitPaths[f.Path]; exists {
+			r.AddOnError(c.Append("storage", "files", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, d := range cfg.Storage.Directories {
+		if _, exists := unitPaths[d.Path]; exists {
+			r.AddOnError(c.Append("storage", "directories", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, l := range cfg.Storage.Links {
+		if _, exists := unitPaths[l.Path]; exists {
+			r.AddOnError(c.Append("storage", "links", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	return
+}
diff --git a/config/v3_4/types/config_test.go b/config/v3_4/types/config_test.go
new file mode 100644
index 00000000..3d82627b
--- /dev/null
+++ b/config/v3_4/types/config_test.go
@@ -0,0 +1,260 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestConfigValidation(t *testing.T) {
+	tests := []struct {
+		in  Config
+		out error
+		at  path.ContextPath
+	}{
+		// test 0: file conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 1: file conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 2: directory conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 3: directory conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 4: link conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/qux.conf")},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 5: link conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/qux.conf")},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 6: non-conflicting scenarios
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service.d/baz.conf"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/qux.conf"},
+						},
+					},
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/qux.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/qux.conf")},
+						},
+						{
+							Node:          Node{Path: "/etc/systemd/system/quux.service.d/foo.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo.conf")},
+						},
+					},
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/quux.service.d"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+						{
+							Name: "bar.service",
+							Dropins: []Dropin{
+								{
+									Name: "baz.conf",
+								},
+							},
+							Enabled: util.BoolToPtr(true),
+						},
+						{
+							Name: "qux.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+								},
+							},
+						},
+						{
+							Name:     "quux.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+		},
+	}
+	for i, test := range tests {
+		r := test.in.Validate(path.New("json"))
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad error: expected : %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_4_experimental/types/device.go b/config/v3_4/types/device.go
similarity index 100%
rename from config/v3_4_experimental/types/device.go
rename to config/v3_4/types/device.go
diff --git a/config/v3_4_experimental/types/directory.go b/config/v3_4/types/directory.go
similarity index 100%
rename from config/v3_4_experimental/types/directory.go
rename to config/v3_4/types/directory.go
diff --git a/config/v3_4_experimental/types/disk.go b/config/v3_4/types/disk.go
similarity index 100%
rename from config/v3_4_experimental/types/disk.go
rename to config/v3_4/types/disk.go
diff --git a/config/v3_4_experimental/types/file.go b/config/v3_4/types/file.go
similarity index 100%
rename from config/v3_4_experimental/types/file.go
rename to config/v3_4/types/file.go
diff --git a/config/v3_4_experimental/types/file_test.go b/config/v3_4/types/file_test.go
similarity index 100%
rename from config/v3_4_experimental/types/file_test.go
rename to config/v3_4/types/file_test.go
diff --git a/config/v3_4_experimental/types/filesystem.go b/config/v3_4/types/filesystem.go
similarity index 100%
rename from config/v3_4_experimental/types/filesystem.go
rename to config/v3_4/types/filesystem.go
diff --git a/config/v3_4_experimental/types/filesystem_test.go b/config/v3_4/types/filesystem_test.go
similarity index 100%
rename from config/v3_4_experimental/types/filesystem_test.go
rename to config/v3_4/types/filesystem_test.go
diff --git a/config/v3_4_experimental/types/headers.go b/config/v3_4/types/headers.go
similarity index 100%
rename from config/v3_4_experimental/types/headers.go
rename to config/v3_4/types/headers.go
diff --git a/config/v3_4_experimental/types/headers_test.go b/config/v3_4/types/headers_test.go
similarity index 100%
rename from config/v3_4_experimental/types/headers_test.go
rename to config/v3_4/types/headers_test.go
diff --git a/config/v3_4_experimental/types/ignition.go b/config/v3_4/types/ignition.go
similarity index 100%
rename from config/v3_4_experimental/types/ignition.go
rename to config/v3_4/types/ignition.go
diff --git a/config/v3_4_experimental/types/ignition_test.go b/config/v3_4/types/ignition_test.go
similarity index 100%
rename from config/v3_4_experimental/types/ignition_test.go
rename to config/v3_4/types/ignition_test.go
diff --git a/config/v3_4_experimental/types/kargs.go b/config/v3_4/types/kargs.go
similarity index 100%
rename from config/v3_4_experimental/types/kargs.go
rename to config/v3_4/types/kargs.go
diff --git a/config/v3_4_experimental/types/kargs_test.go b/config/v3_4/types/kargs_test.go
similarity index 100%
rename from config/v3_4_experimental/types/kargs_test.go
rename to config/v3_4/types/kargs_test.go
diff --git a/config/v3_4_experimental/types/luks.go b/config/v3_4/types/luks.go
similarity index 100%
rename from config/v3_4_experimental/types/luks.go
rename to config/v3_4/types/luks.go
diff --git a/config/v3_4_experimental/types/mode.go b/config/v3_4/types/mode.go
similarity index 100%
rename from config/v3_4_experimental/types/mode.go
rename to config/v3_4/types/mode.go
diff --git a/config/v3_4_experimental/types/mode_test.go b/config/v3_4/types/mode_test.go
similarity index 100%
rename from config/v3_4_experimental/types/mode_test.go
rename to config/v3_4/types/mode_test.go
diff --git a/config/v3_4_experimental/types/node.go b/config/v3_4/types/node.go
similarity index 100%
rename from config/v3_4_experimental/types/node.go
rename to config/v3_4/types/node.go
diff --git a/config/v3_4_experimental/types/node_test.go b/config/v3_4/types/node_test.go
similarity index 100%
rename from config/v3_4_experimental/types/node_test.go
rename to config/v3_4/types/node_test.go
diff --git a/config/v3_4_experimental/types/partition.go b/config/v3_4/types/partition.go
similarity index 100%
rename from config/v3_4_experimental/types/partition.go
rename to config/v3_4/types/partition.go
diff --git a/config/v3_4_experimental/types/partition_test.go b/config/v3_4/types/partition_test.go
similarity index 100%
rename from config/v3_4_experimental/types/partition_test.go
rename to config/v3_4/types/partition_test.go
diff --git a/config/v3_4_experimental/types/passwd.go b/config/v3_4/types/passwd.go
similarity index 100%
rename from config/v3_4_experimental/types/passwd.go
rename to config/v3_4/types/passwd.go
diff --git a/config/v3_4_experimental/types/path.go b/config/v3_4/types/path.go
similarity index 100%
rename from config/v3_4_experimental/types/path.go
rename to config/v3_4/types/path.go
diff --git a/config/v3_4_experimental/types/path_test.go b/config/v3_4/types/path_test.go
similarity index 100%
rename from config/v3_4_experimental/types/path_test.go
rename to config/v3_4/types/path_test.go
diff --git a/config/v3_4_experimental/types/proxy.go b/config/v3_4/types/proxy.go
similarity index 100%
rename from config/v3_4_experimental/types/proxy.go
rename to config/v3_4/types/proxy.go
diff --git a/config/v3_4_experimental/types/proxy_test.go b/config/v3_4/types/proxy_test.go
similarity index 100%
rename from config/v3_4_experimental/types/proxy_test.go
rename to config/v3_4/types/proxy_test.go
diff --git a/config/v3_4_experimental/types/raid.go b/config/v3_4/types/raid.go
similarity index 100%
rename from config/v3_4_experimental/types/raid.go
rename to config/v3_4/types/raid.go
diff --git a/config/v3_4_experimental/types/raid_test.go b/config/v3_4/types/raid_test.go
similarity index 100%
rename from config/v3_4_experimental/types/raid_test.go
rename to config/v3_4/types/raid_test.go
diff --git a/config/v3_4_experimental/types/resource.go b/config/v3_4/types/resource.go
similarity index 100%
rename from config/v3_4_experimental/types/resource.go
rename to config/v3_4/types/resource.go
diff --git a/config/v3_4/types/schema.go b/config/v3_4/types/schema.go
new file mode 100644
index 00000000..74a9e122
--- /dev/null
+++ b/config/v3_4/types/schema.go
@@ -0,0 +1,259 @@
+package types
+
+// generated by "schematyper --package=types config/v3_4/schema/ignition.json -o config/v3_4/types/schema.go --root-type=Config" -- DO NOT EDIT
+
+type Clevis struct {
+	Custom    ClevisCustom `json:"custom,omitempty"`
+	Tang      []Tang       `json:"tang,omitempty"`
+	Threshold *int         `json:"threshold,omitempty"`
+	Tpm2      *bool        `json:"tpm2,omitempty"`
+}
+
+type ClevisCustom struct {
+	Config       *string `json:"config,omitempty"`
+	NeedsNetwork *bool   `json:"needsNetwork,omitempty"`
+	Pin          *string `json:"pin,omitempty"`
+}
+
+type Config struct {
+	Ignition        Ignition        `json:"ignition"`
+	KernelArguments KernelArguments `json:"kernelArguments,omitempty"`
+	Passwd          Passwd          `json:"passwd,omitempty"`
+	Storage         Storage         `json:"storage,omitempty"`
+	Systemd         Systemd         `json:"systemd,omitempty"`
+}
+
+type Device string
+
+type Directory struct {
+	Node
+	DirectoryEmbedded1
+}
+
+type DirectoryEmbedded1 struct {
+	Mode *int `json:"mode,omitempty"`
+}
+
+type Disk struct {
+	Device     string      `json:"device"`
+	Partitions []Partition `json:"partitions,omitempty"`
+	WipeTable  *bool       `json:"wipeTable,omitempty"`
+}
+
+type Dropin struct {
+	Contents *string `json:"contents,omitempty"`
+	Name     string  `json:"name"`
+}
+
+type File struct {
+	Node
+	FileEmbedded1
+}
+
+type FileEmbedded1 struct {
+	Append   []Resource `json:"append,omitempty"`
+	Contents Resource   `json:"contents,omitempty"`
+	Mode     *int       `json:"mode,omitempty"`
+}
+
+type Filesystem struct {
+	Device         string             `json:"device"`
+	Format         *string            `json:"format,omitempty"`
+	Label          *string            `json:"label,omitempty"`
+	MountOptions   []MountOption      `json:"mountOptions,omitempty"`
+	Options        []FilesystemOption `json:"options,omitempty"`
+	Path           *string            `json:"path,omitempty"`
+	UUID           *string            `json:"uuid,omitempty"`
+	WipeFilesystem *bool              `json:"wipeFilesystem,omitempty"`
+}
+
+type FilesystemOption string
+
+type Group string
+
+type HTTPHeader struct {
+	Name  string  `json:"name"`
+	Value *string `json:"value,omitempty"`
+}
+
+type HTTPHeaders []HTTPHeader
+
+type Ignition struct {
+	Config   IgnitionConfig `json:"config,omitempty"`
+	Proxy    Proxy          `json:"proxy,omitempty"`
+	Security Security       `json:"security,omitempty"`
+	Timeouts Timeouts       `json:"timeouts,omitempty"`
+	Version  string         `json:"version"`
+}
+
+type IgnitionConfig struct {
+	Merge   []Resource `json:"merge,omitempty"`
+	Replace Resource   `json:"replace,omitempty"`
+}
+
+type KernelArgument string
+
+type KernelArguments struct {
+	ShouldExist    []KernelArgument `json:"shouldExist,omitempty"`
+	ShouldNotExist []KernelArgument `json:"shouldNotExist,omitempty"`
+}
+
+type Link struct {
+	Node
+	LinkEmbedded1
+}
+
+type LinkEmbedded1 struct {
+	Hard   *bool   `json:"hard,omitempty"`
+	Target *string `json:"target,omitempty"`
+}
+
+type Luks struct {
+	Clevis      Clevis       `json:"clevis,omitempty"`
+	Device      *string      `json:"device,omitempty"`
+	Discard     *bool        `json:"discard,omitempty"`
+	KeyFile     Resource     `json:"keyFile,omitempty"`
+	Label       *string      `json:"label,omitempty"`
+	Name        string       `json:"name"`
+	OpenOptions []OpenOption `json:"openOptions,omitempty"`
+	Options     []LuksOption `json:"options,omitempty"`
+	UUID        *string      `json:"uuid,omitempty"`
+	WipeVolume  *bool        `json:"wipeVolume,omitempty"`
+}
+
+type LuksOption string
+
+type MountOption string
+
+type NoProxyItem string
+
+type Node struct {
+	Group     NodeGroup `json:"group,omitempty"`
+	Overwrite *bool     `json:"overwrite,omitempty"`
+	Path      string    `json:"path"`
+	User      NodeUser  `json:"user,omitempty"`
+}
+
+type NodeGroup struct {
+	ID   *int    `json:"id,omitempty"`
+	Name *string `json:"name,omitempty"`
+}
+
+type NodeUser struct {
+	ID   *int    `json:"id,omitempty"`
+	Name *string `json:"name,omitempty"`
+}
+
+type OpenOption string
+
+type Partition struct {
+	GUID               *string `json:"guid,omitempty"`
+	Label              *string `json:"label,omitempty"`
+	Number             int     `json:"number,omitempty"`
+	Resize             *bool   `json:"resize,omitempty"`
+	ShouldExist        *bool   `json:"shouldExist,omitempty"`
+	SizeMiB            *int    `json:"sizeMiB,omitempty"`
+	StartMiB           *int    `json:"startMiB,omitempty"`
+	TypeGUID           *string `json:"typeGuid,omitempty"`
+	WipePartitionEntry *bool   `json:"wipePartitionEntry,omitempty"`
+}
+
+type Passwd struct {
+	Groups []PasswdGroup `json:"groups,omitempty"`
+	Users  []PasswdUser  `json:"users,omitempty"`
+}
+
+type PasswdGroup struct {
+	Gid          *int    `json:"gid,omitempty"`
+	Name         string  `json:"name"`
+	PasswordHash *string `json:"passwordHash,omitempty"`
+	ShouldExist  *bool   `json:"shouldExist,omitempty"`
+	System       *bool   `json:"system,omitempty"`
+}
+
+type PasswdUser struct {
+	Gecos             *string            `json:"gecos,omitempty"`
+	Groups            []Group            `json:"groups,omitempty"`
+	HomeDir           *string            `json:"homeDir,omitempty"`
+	Name              string             `json:"name"`
+	NoCreateHome      *bool              `json:"noCreateHome,omitempty"`
+	NoLogInit         *bool              `json:"noLogInit,omitempty"`
+	NoUserGroup       *bool              `json:"noUserGroup,omitempty"`
+	PasswordHash      *string            `json:"passwordHash,omitempty"`
+	PrimaryGroup      *string            `json:"primaryGroup,omitempty"`
+	SSHAuthorizedKeys []SSHAuthorizedKey `json:"sshAuthorizedKeys,omitempty"`
+	Shell             *string            `json:"shell,omitempty"`
+	ShouldExist       *bool              `json:"shouldExist,omitempty"`
+	System            *bool              `json:"system,omitempty"`
+	UID               *int               `json:"uid,omitempty"`
+}
+
+type Proxy struct {
+	HTTPProxy  *string       `json:"httpProxy,omitempty"`
+	HTTPSProxy *string       `json:"httpsProxy,omitempty"`
+	NoProxy    []NoProxyItem `json:"noProxy,omitempty"`
+}
+
+type Raid struct {
+	Devices []Device     `json:"devices,omitempty"`
+	Level   *string      `json:"level,omitempty"`
+	Name    string       `json:"name"`
+	Options []RaidOption `json:"options,omitempty"`
+	Spares  *int         `json:"spares,omitempty"`
+}
+
+type RaidOption string
+
+type Resource struct {
+	Compression  *string      `json:"compression,omitempty"`
+	HTTPHeaders  HTTPHeaders  `json:"httpHeaders,omitempty"`
+	Source       *string      `json:"source,omitempty"`
+	Verification Verification `json:"verification,omitempty"`
+}
+
+type SSHAuthorizedKey string
+
+type Security struct {
+	TLS TLS `json:"tls,omitempty"`
+}
+
+type Storage struct {
+	Directories []Directory  `json:"directories,omitempty"`
+	Disks       []Disk       `json:"disks,omitempty"`
+	Files       []File       `json:"files,omitempty"`
+	Filesystems []Filesystem `json:"filesystems,omitempty"`
+	Links       []Link       `json:"links,omitempty"`
+	Luks        []Luks       `json:"luks,omitempty"`
+	Raid        []Raid       `json:"raid,omitempty"`
+}
+
+type Systemd struct {
+	Units []Unit `json:"units,omitempty"`
+}
+
+type TLS struct {
+	CertificateAuthorities []Resource `json:"certificateAuthorities,omitempty"`
+}
+
+type Tang struct {
+	Advertisement *string `json:"advertisement,omitempty"`
+	Thumbprint    *string `json:"thumbprint,omitempty"`
+	URL           string  `json:"url,omitempty"`
+}
+
+type Timeouts struct {
+	HTTPResponseHeaders *int `json:"httpResponseHeaders,omitempty"`
+	HTTPTotal           *int `json:"httpTotal,omitempty"`
+}
+
+type Unit struct {
+	Contents *string  `json:"contents,omitempty"`
+	Dropins  []Dropin `json:"dropins,omitempty"`
+	Enabled  *bool    `json:"enabled,omitempty"`
+	Mask     *bool    `json:"mask,omitempty"`
+	Name     string   `json:"name"`
+}
+
+type Verification struct {
+	Hash *string `json:"hash,omitempty"`
+}
diff --git a/config/v3_4_experimental/types/storage.go b/config/v3_4/types/storage.go
similarity index 61%
rename from config/v3_4_experimental/types/storage.go
rename to config/v3_4/types/storage.go
index 02108613..20cb7304 100644
--- a/config/v3_4_experimental/types/storage.go
+++ b/config/v3_4/types/storage.go
@@ -34,6 +34,14 @@ func (s Storage) MergedKeys() map[string]string {
 }
 
 func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
+	s.validateDirectories(c, &r)
+	s.validateFiles(c, &r)
+	s.validateLinks(c, &r)
+	s.validateFilesystems(c, &r)
+	return
+}
+
+func (s Storage) validateDirectories(c vpath.ContextPath, r *report.Report) {
 	for i, d := range s.Directories {
 		for _, l := range s.Links {
 			if strings.HasPrefix(d.Path, l.Path+"/") {
@@ -41,6 +49,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateFiles(c vpath.ContextPath, r *report.Report) {
 	for i, f := range s.Files {
 		for _, l := range s.Links {
 			if strings.HasPrefix(f.Path, l.Path+"/") {
@@ -48,6 +59,9 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 			}
 		}
 	}
+}
+
+func (s Storage) validateLinks(c vpath.ContextPath, r *report.Report) {
 	for i, l1 := range s.Links {
 		for _, l2 := range s.Links {
 			if strings.HasPrefix(l1.Path, l2.Path+"/") {
@@ -70,6 +84,32 @@ func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
 				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
 			}
 		}
+		ownerCheck := func(ok bool, path vpath.ContextPath) {
+			if !ok {
+				r.AddOnWarn(path, errors.ErrHardLinkSpecifiesOwner)
+			}
+		}
+		ownerCheck(l1.User.ID == nil, c.Append("links", i, "user", "id"))
+		ownerCheck(l1.User.Name == nil, c.Append("links", i, "user", "name"))
+		ownerCheck(l1.Group.ID == nil, c.Append("links", i, "group", "id"))
+		ownerCheck(l1.Group.Name == nil, c.Append("links", i, "group", "name"))
+	}
+}
+
+func (s Storage) validateFilesystems(c vpath.ContextPath, r *report.Report) {
+	disks := make(map[string]Disk)
+	for _, d := range s.Disks {
+		disks[d.Device] = d
+	}
+
+	for i, f := range s.Filesystems {
+		disk, exist := disks[f.Device]
+		if exist {
+			if len(disk.Partitions) > 0 {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrPartitionsOverwritten)
+			} else if !util.IsTrue(f.WipeFilesystem) && util.IsTrue(disk.WipeTable) {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrFilesystemImplicitWipe)
+			}
+		}
 	}
-	return
 }
diff --git a/config/v3_4/types/storage_test.go b/config/v3_4/types/storage_test.go
new file mode 100644
index 00000000..551688a2
--- /dev/null
+++ b/config/v3_4/types/storage_test.go
@@ -0,0 +1,359 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestStorageValidateErrors(t *testing.T) {
+	tests := []struct {
+		in   Storage
+		at   path.ContextPath
+		err  error
+		warn error
+	}{
+		// test empty storage config returns nil
+		{
+			in: Storage{},
+		},
+		// test a storage config with no conflicting paths returns nil
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+					{
+						Node:          Node{Path: "/quux"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/quux-t")},
+					},
+				},
+				Files: []File{
+					{
+						Node: Node{Path: "/bar"},
+					},
+				},
+				Directories: []Directory{
+					{
+						Node: Node{Path: "/baz"},
+					},
+				},
+			},
+		},
+		// test when a file uses a configured symlink path returns ErrFileUsedSymlink
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+				},
+				Files: []File{
+					{
+						Node: Node{Path: "/foo/bar"},
+					},
+				},
+			},
+			err: errors.ErrFileUsedSymlink,
+			at:  path.New("", "files", 0),
+		},
+		// test when a directory uses a configured symlink path returns ErrDirectoryUsedSymlink
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+				},
+				Directories: []Directory{
+					{
+						Node: Node{Path: "/foo/bar"},
+					},
+				},
+			},
+			err: errors.ErrDirectoryUsedSymlink,
+			at:  path.New("", "directories", 0),
+		},
+		// test the same path listed for two separate symlinks returns ErrLinkUsedSymlink
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+					{
+						Node:          Node{Path: "/foo/bar"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-bar-t")},
+					},
+				},
+			},
+			err: errors.ErrLinkUsedSymlink,
+			at:  path.New("", "links", 1),
+		},
+		// test a configured symlink with no target returns ErrLinkTargetRequired
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Hard: util.BoolToPtr(true)},
+					},
+				},
+			},
+			err: errors.ErrLinkTargetRequired,
+			at:  path.New("", "links", 0, "target"),
+		},
+		// test a configured symlink with a nil target returns ErrLinkTargetRequired
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("")},
+					},
+				},
+			},
+			err: errors.ErrLinkTargetRequired,
+			at:  path.New("", "links", 0, "target"),
+		},
+		// test that two symlinks can be configured at a time
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+					{
+						Node:          Node{Path: "/foob/bar"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foob-bar-t")},
+					},
+				},
+			},
+		},
+		// test when a directory uses a configured symlink with the 'Hard:= true' returns ErrHardLinkToDirectory
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{Path: "/quux"},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+				Directories: []Directory{
+					{
+						Node: Node{Path: "/foo/bar"},
+					},
+				},
+			},
+			err: errors.ErrHardLinkToDirectory,
+			at:  path.New("", "links", 0),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "name"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "name"),
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.err)
+		expected.AddOnWarn(test.at, test.warn)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
+
+func TestStorageValidateWarnings(t *testing.T) {
+	tests := []struct {
+		in  Storage
+		at  path.ContextPath
+		out error
+	}{
+		// test a disk with partitions with the same 'device' as a filesystem returns ErrPartitionsOverwritten
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sda",
+						Partitions: []Partition{
+							{}, {},
+						},
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrPartitionsOverwritten,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=true' as a configured filesystem returns ErrFilesystemImplicitWipe
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(true),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrFilesystemImplicitWipe,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=false' as a configured filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(false),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: nil,
+		},
+		// test a disk with no partitions with the same 'device' as a filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+			},
+			out: nil,
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnWarn(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_4/types/systemd.go b/config/v3_4/types/systemd.go
new file mode 100644
index 00000000..ac521ba7
--- /dev/null
+++ b/config/v3_4/types/systemd.go
@@ -0,0 +1,61 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"regexp"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
+	"github.com/coreos/ignition/v2/config/util"
+
+	vpath "github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (s Systemd) Validate(c vpath.ContextPath) (r report.Report) {
+	units := make(map[string]Unit)
+	checkInstanceUnit := regexp.MustCompile(`^(.+?)@(.+?)\.service$`)
+	for _, d := range s.Units {
+		units[d.Name] = d
+	}
+	for index, unit := range s.Units {
+		if checkInstanceUnit.MatchString(unit.Name) && util.IsTrue(unit.Enabled) {
+			instUnitSlice := checkInstanceUnit.FindSubmatch([]byte(unit.Name))
+			instantiableUnit := string(instUnitSlice[1]) + "@.service"
+			if _, ok := units[instantiableUnit]; ok && util.NotEmpty(units[instantiableUnit].Contents) {
+				foundInstallSection := false
+				// we're doing a separate validation pass on each unit to identify
+				// if an instantiable unit has the install section. So logging an
+				// `AddOnError` will produce duplicate errors on bad unit contents
+				// because we're already doing that while validating a unit separately.
+				opts, err := parse.ParseUnitContents(units[instantiableUnit].Contents)
+				if err != nil {
+					continue
+				}
+				for _, section := range opts {
+					if section.Section == "Install" {
+						foundInstallSection = true
+						break
+					}
+				}
+				if !foundInstallSection {
+					r.AddOnWarn(c.Append("units", index, "contents"), errors.NewNoInstallSectionForInstantiableUnitError(instantiableUnit, unit.Name))
+				}
+			}
+		}
+	}
+	return
+}
diff --git a/config/v3_4/types/systemd_test.go b/config/v3_4/types/systemd_test.go
new file mode 100644
index 00000000..798eb10f
--- /dev/null
+++ b/config/v3_4/types/systemd_test.go
@@ -0,0 +1,105 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestSystemdValidate(t *testing.T) {
+	tests := []struct {
+		in  Systemd
+		out error
+	}{
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			errors.NewNoInstallSectionForInstantiableUnitError("test@.service", "test@foo.service"),
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service"},
+					{Name: "test@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+	}
+
+	for i, test := range tests {
+		t.Run(fmt.Sprintf("validate %d", i), func(t *testing.T) {
+			actual := test.in.Validate(path.ContextPath{})
+			expected := report.Report{}
+			expected.AddOnWarn(path.ContextPath{}.Append("units", 1, "contents"), test.out)
+			assert.Equal(t, expected, actual, "bad report")
+		})
+	}
+}
diff --git a/config/v3_4_experimental/types/tang.go b/config/v3_4/types/tang.go
similarity index 80%
rename from config/v3_4_experimental/types/tang.go
rename to config/v3_4/types/tang.go
index 86ab79c9..1839d6cc 100644
--- a/config/v3_4_experimental/types/tang.go
+++ b/config/v3_4/types/tang.go
@@ -15,6 +15,7 @@
 package types
 
 import (
+	"encoding/json"
 	"net/url"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
@@ -33,6 +34,7 @@ func (t Tang) Validate(c path.ContextPath) (r report.Report) {
 	if util.NilOrEmpty(t.Thumbprint) {
 		r.AddOnError(c.Append("thumbprint"), errors.ErrTangThumbprintRequired)
 	}
+	r.AddOnError(c.Append("advertisement"), validateTangAdvertisement(t.Advertisement))
 	return
 }
 
@@ -49,3 +51,15 @@ func validateTangURL(s string) error {
 		return errors.ErrInvalidScheme
 	}
 }
+
+func validateTangAdvertisement(s *string) error {
+	if util.NotEmpty(s) {
+		var adv any
+		err := json.Unmarshal([]byte(*s), &adv)
+		if err != nil {
+			return errors.ErrInvalidTangAdvertisement
+		}
+	}
+
+	return nil
+}
diff --git a/config/v3_4/types/tang_test.go b/config/v3_4/types/tang_test.go
new file mode 100644
index 00000000..fb57b1e4
--- /dev/null
+++ b/config/v3_4/types/tang_test.go
@@ -0,0 +1,104 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestTangValidation(t *testing.T) {
+	tests := []struct {
+		in  Tang
+		out error
+		at  path.ContextPath
+	}{
+		// happy path with no advertisement and healthy url
+		{
+			in: Tang{
+				URL:        "http://example.com",
+				Thumbprint: util.StrToPtr("abc"),
+			},
+			out: nil,
+		},
+		// test 1: invalid url scheme
+		{
+			in: Tang{
+				URL:        "httasfdsafadsf",
+				Thumbprint: util.StrToPtr("abc"),
+			},
+			out: errors.ErrInvalidScheme,
+			at:  path.New("foo", "url"),
+		},
+		// null url
+		{
+			in: Tang{
+				Thumbprint: util.StrToPtr("abc"),
+			},
+			out: errors.ErrInvalidScheme,
+			at:  path.New("foo", "url"),
+		},
+		// null thumbprint
+		{
+			in: Tang{
+				URL:        "http://example.com",
+				Thumbprint: nil,
+			},
+			out: errors.ErrTangThumbprintRequired,
+			at:  path.New("foo", "thumbprint"),
+		},
+		// Advertisement is valid json
+		{
+			in: Tang{
+				URL:           "http://example.com",
+				Thumbprint:    util.StrToPtr("abc"),
+				Advertisement: util.StrToPtr("{\"payload\": \"eyJrZXlzIjogW3siYWxnIjogIkVTNTEyIiwgImt0eSI6ICJFQyIsICJjcnYiOiAiUC01MjEiLCAieCI6ICJBRGFNajJmazNob21CWTF5WElSQ21uRk92cmUzOFZjdHMwTnNHeDZ6RWNxdEVXcjh5ekhUMkhfa2hjNGpSa19FQWFLdjNrd2RjZ05sOTBLcGhfMGYyQ190IiwgInkiOiAiQUZ2d1UyeGJ5T1RydWo0V1NtcVlqN2wtcUVTZmhWakdCNTI1Q2d6d0NoZUZRRTBvb1o3STYyamt3NkRKQ05yS3VPUDRsSEhicm8tYXhoUk9MSXNJVExvNCIsICJrZXlfb3BzIjogWyJ2ZXJpZnkiXX0sIHsiYWxnIjogIkVDTVIiLCAia3R5IjogIkVDIiwgImNydiI6ICJQLTUyMSIsICJ4IjogIkFOZDVYcTFvZklUbTdNWG16OUY0VVRSYmRNZFNIMl9XNXczTDVWZ0w3b3hwdmpyM0hkLXNLNUVqd3A1V2swMnJMb3NXVUJjYkZyZEhjZFJTTVJoZlVFTFIiLCAieSI6ICJBRVVaVlVZWkFBY2hVcmdoX3poaTV3SUUzeTEycGwzeWhqUk5LcGpSdW9tUFhKaDhRaFhXRmRWZEtMUlEwX1lwUjNOMjNSUk1pU1lvWlg0Qm42QnlrQVBMIiwgImtleV9vcHMiOiBbImRlcml2ZUtleSJdfV19\", \"protected\": \"eyJhbGciOiJFUzUxMiIsImN0eSI6Imp3ay1zZXQranNvbiJ9\", \"signature\": \"APHfSyVzLwELwG0pMJyIP74gWvhHUvDtv0SESBxA2uOdSXq76IdWHW2xvCZDdlNan8pnqUvEedPZjf_vdKBw9MTXAPMkRxVnu64HepKwlrzzm_zG2R4CHpoCOsGgjH9-acYxg-Vha63oMojv3_bV0VHg-NbzNLaxietgYplstvcNIwkv\"}"),
+			},
+			out: nil,
+		},
+		// Advertisement is empty string
+		{
+			in: Tang{
+				URL:           "http://example.com",
+				Thumbprint:    util.StrToPtr("abc"),
+				Advertisement: util.StrToPtr(""),
+			},
+			out: nil,
+		},
+		// Advertisement is not valid json
+		{
+			in: Tang{
+				URL:           "http://example.com",
+				Thumbprint:    util.StrToPtr("abc"),
+				Advertisement: util.StrToPtr("{{"),
+			},
+			out: errors.ErrInvalidTangAdvertisement,
+			at:  path.New("foo", "advertisement"),
+		},
+	}
+	for i, test := range tests {
+		r := test.in.Validate(path.New("foo"))
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad error: expected : %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_4_experimental/types/tls.go b/config/v3_4/types/tls.go
similarity index 100%
rename from config/v3_4_experimental/types/tls.go
rename to config/v3_4/types/tls.go
diff --git a/config/v3_4_experimental/types/tls_test.go b/config/v3_4/types/tls_test.go
similarity index 100%
rename from config/v3_4_experimental/types/tls_test.go
rename to config/v3_4/types/tls_test.go
diff --git a/config/v3_4_experimental/types/unit.go b/config/v3_4/types/unit.go
similarity index 79%
rename from config/v3_4_experimental/types/unit.go
rename to config/v3_4/types/unit.go
index bc2d3299..c5ee1e8e 100644
--- a/config/v3_4_experimental/types/unit.go
+++ b/config/v3_4/types/unit.go
@@ -15,15 +15,13 @@
 package types
 
 import (
-	"fmt"
 	"path"
-	"strings"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
 	"github.com/coreos/ignition/v2/config/shared/validations"
 	"github.com/coreos/ignition/v2/config/util"
 
-	"github.com/coreos/go-systemd/v22/unit"
 	cpath "github.com/coreos/vcontext/path"
 	"github.com/coreos/vcontext/report"
 )
@@ -39,7 +37,7 @@ func (d Dropin) Key() string {
 func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
 	r.AddOnError(c.Append("name"), validateName(u.Name))
 	c = c.Append("contents")
-	opts, err := validateUnitContent(u.Contents)
+	opts, err := parse.ParseUnitContents(u.Contents)
 	r.AddOnError(c, err)
 
 	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, util.IsTrue(u.Enabled), util.NilOrEmpty(u.Contents), opts))
@@ -57,7 +55,7 @@ func validateName(name string) error {
 }
 
 func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
-	_, err := validateUnitContent(d.Contents)
+	_, err := parse.ParseUnitContents(d.Contents)
 	r.AddOnError(c.Append("contents"), err)
 
 	switch path.Ext(d.Name) {
@@ -68,15 +66,3 @@ func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
 
 	return
 }
-
-func validateUnitContent(content *string) ([]*unit.UnitOption, error) {
-	if content == nil {
-		return []*unit.UnitOption{}, nil
-	}
-	c := strings.NewReader(*content)
-	opts, err := unit.Deserialize(c)
-	if err != nil {
-		return nil, fmt.Errorf("invalid unit content: %s", err)
-	}
-	return opts, nil
-}
diff --git a/config/v3_4_experimental/types/unit_test.go b/config/v3_4/types/unit_test.go
similarity index 100%
rename from config/v3_4_experimental/types/unit_test.go
rename to config/v3_4/types/unit_test.go
diff --git a/config/v3_4_experimental/types/url.go b/config/v3_4/types/url.go
similarity index 100%
rename from config/v3_4_experimental/types/url.go
rename to config/v3_4/types/url.go
diff --git a/config/v3_4_experimental/types/url_test.go b/config/v3_4/types/url_test.go
similarity index 100%
rename from config/v3_4_experimental/types/url_test.go
rename to config/v3_4/types/url_test.go
diff --git a/config/v3_4_experimental/types/verification.go b/config/v3_4/types/verification.go
similarity index 100%
rename from config/v3_4_experimental/types/verification.go
rename to config/v3_4/types/verification.go
diff --git a/config/v3_4_experimental/types/verification_test.go b/config/v3_4/types/verification_test.go
similarity index 100%
rename from config/v3_4_experimental/types/verification_test.go
rename to config/v3_4/types/verification_test.go
diff --git a/config/v3_4_experimental/types/storage_test.go b/config/v3_4_experimental/types/storage_test.go
deleted file mode 100644
index cb9256cf..00000000
--- a/config/v3_4_experimental/types/storage_test.go
+++ /dev/null
@@ -1,182 +0,0 @@
-// Copyright 2020 Red Hat, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package types
-
-import (
-	"reflect"
-	"testing"
-
-	"github.com/coreos/ignition/v2/config/shared/errors"
-	"github.com/coreos/ignition/v2/config/util"
-
-	"github.com/coreos/vcontext/path"
-	"github.com/coreos/vcontext/report"
-)
-
-func TestStorageValidate(t *testing.T) {
-	tests := []struct {
-		in  Storage
-		at  path.ContextPath
-		out error
-	}{
-		{
-			in:  Storage{},
-			out: nil,
-		},
-		{
-			in: Storage{
-				Links: []Link{
-					{
-						Node:          Node{Path: "/foo"},
-						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
-					},
-					{
-						Node:          Node{Path: "/quux"},
-						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/quux-t")},
-					},
-				},
-				Files: []File{
-					{
-						Node: Node{Path: "/bar"},
-					},
-				},
-				Directories: []Directory{
-					{
-						Node: Node{Path: "/baz"},
-					},
-				},
-			},
-			out: nil,
-		},
-		{
-			in: Storage{
-				Links: []Link{
-					{
-						Node:          Node{Path: "/foo"},
-						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
-					},
-				},
-				Files: []File{
-					{
-						Node: Node{Path: "/foo/bar"},
-					},
-				},
-			},
-			out: errors.ErrFileUsedSymlink,
-			at:  path.New("", "files", 0),
-		},
-		{
-			in: Storage{
-				Links: []Link{
-					{
-						Node:          Node{Path: "/foo"},
-						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
-					},
-				},
-				Directories: []Directory{
-					{
-						Node: Node{Path: "/foo/bar"},
-					},
-				},
-			},
-			out: errors.ErrDirectoryUsedSymlink,
-			at:  path.New("", "directories", 0),
-		},
-		{
-			in: Storage{
-				Links: []Link{
-					{
-						Node:          Node{Path: "/foo"},
-						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
-					},
-					{
-						Node:          Node{Path: "/foo/bar"},
-						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-bar-t")},
-					},
-				},
-			},
-			out: errors.ErrLinkUsedSymlink,
-			at:  path.New("", "links", 1),
-		},
-		{
-			in: Storage{
-				Links: []Link{
-					{
-						Node:          Node{Path: "/foo"},
-						LinkEmbedded1: LinkEmbedded1{Hard: util.BoolToPtr(true)},
-					},
-				},
-			},
-			out: errors.ErrLinkTargetRequired,
-			at:  path.New("", "links", 0, "target"),
-		},
-		{
-			in: Storage{
-				Links: []Link{
-					{
-						Node:          Node{Path: "/foo"},
-						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("")},
-					},
-				},
-			},
-			out: errors.ErrLinkTargetRequired,
-			at:  path.New("", "links", 0, "target"),
-		},
-		{
-			in: Storage{
-				Links: []Link{
-					{
-						Node:          Node{Path: "/foo"},
-						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
-					},
-					{
-						Node:          Node{Path: "/foob/bar"},
-						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foob-bar-t")},
-					},
-				},
-			},
-			out: nil,
-		},
-		{
-			in: Storage{
-				Links: []Link{
-					{
-						Node: Node{Path: "/quux"},
-						LinkEmbedded1: LinkEmbedded1{
-							Target: util.StrToPtr("/foo/bar"),
-							Hard:   util.BoolToPtr(true),
-						},
-					},
-				},
-				Directories: []Directory{
-					{
-						Node: Node{Path: "/foo/bar"},
-					},
-				},
-			},
-			out: errors.ErrHardLinkToDirectory,
-			at:  path.New("", "links", 0),
-		},
-	}
-
-	for i, test := range tests {
-		r := test.in.Validate(path.ContextPath{})
-		expected := report.Report{}
-		expected.AddOnError(test.at, test.out)
-		if !reflect.DeepEqual(expected, r) {
-			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
-		}
-	}
-}
diff --git a/config/v3_5_experimental/config.go b/config/v3_5_experimental/config.go
new file mode 100644
index 00000000..9a92bf2a
--- /dev/null
+++ b/config/v3_5_experimental/config.go
@@ -0,0 +1,78 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v3_5_experimental
+
+import (
+	"github.com/coreos/ignition/v2/config/merge"
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+	prev "github.com/coreos/ignition/v2/config/v3_4"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/translate"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/config/validate"
+
+	"github.com/coreos/go-semver/semver"
+	"github.com/coreos/vcontext/report"
+)
+
+func Merge(parent, child types.Config) types.Config {
+	res, _ := merge.MergeStructTranscribe(parent, child)
+	return res.(types.Config)
+}
+
+// Parse parses the raw config into a types.Config struct and generates a report of any
+// errors, warnings, info, and deprecations it encountered
+func Parse(rawConfig []byte) (types.Config, report.Report, error) {
+	if len(rawConfig) == 0 {
+		return types.Config{}, report.Report{}, errors.ErrEmpty
+	}
+
+	var config types.Config
+	if rpt, err := util.HandleParseErrors(rawConfig, &config); err != nil {
+		return types.Config{}, rpt, err
+	}
+
+	version, err := semver.NewVersion(config.Ignition.Version)
+
+	if err != nil || *version != types.MaxVersion {
+		return types.Config{}, report.Report{}, errors.ErrUnknownVersion
+	}
+
+	rpt := validate.ValidateWithContext(config, rawConfig)
+	if rpt.IsFatal() {
+		return types.Config{}, rpt, errors.ErrInvalid
+	}
+
+	return config, rpt, nil
+}
+
+// ParseCompatibleVersion parses the raw config of version 3.5.0-experimental or
+// lesser into a 3.5-exp types.Config struct and generates a report of any errors,
+// warnings, info, and deprecations it encountered
+func ParseCompatibleVersion(raw []byte) (types.Config, report.Report, error) {
+	version, rpt, err := util.GetConfigVersion(raw)
+	if err != nil {
+		return types.Config{}, rpt, err
+	}
+
+	if version == types.MaxVersion {
+		return Parse(raw)
+	}
+	prevCfg, r, err := prev.ParseCompatibleVersion(raw)
+	if err != nil {
+		return types.Config{}, r, err
+	}
+	return translate.Translate(prevCfg), r, nil
+}
diff --git a/config/v3_5_experimental/config_test.go b/config/v3_5_experimental/config_test.go
new file mode 100644
index 00000000..a56b4b3a
--- /dev/null
+++ b/config/v3_5_experimental/config_test.go
@@ -0,0 +1,226 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package v3_5_experimental
+
+import (
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestParse(t *testing.T) {
+	type in struct {
+		config []byte
+	}
+	type out struct {
+		config types.Config
+		err    error
+	}
+
+	tests := []struct {
+		in  in
+		out out
+	}{
+		{
+			in:  in{config: []byte(`{"ignitionVersion": 1}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "1.0.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.0.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.1.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.2.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.3.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.4.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.0.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.1.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.2.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.3.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.4.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.0.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.1.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.2.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.3.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.4.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.5.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.0.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.1.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.2.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.3.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.4.0-experimental"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.5.0-experimental"}}`)},
+			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "2.0.0"},}`)},
+			out: out{err: errors.ErrInvalid},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "invalid.semver"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte{}},
+			out: out{err: errors.ErrEmpty},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.5.0-experimental"}, "storage": {"filesystems": [{"format": "ext4", "label": "zzzzzzzzzzzzzzzzzzzzzzzzzzz"}]}}`)},
+			out: out{err: errors.ErrInvalid},
+		},
+	}
+
+	testsCompt := []struct {
+		in  in
+		out out
+	}{
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.0.0"}}`)},
+			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.1.0"}}`)},
+			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.2.0"}}`)},
+			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.3.0"}}`)},
+			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.4.0"}}`)},
+			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.5.0-experimental"}}`)},
+			out: out{config: types.Config{Ignition: types.Ignition{Version: types.MaxVersion.String()}}},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.5.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.6.0"}}`)},
+			out: out{err: errors.ErrUnknownVersion},
+		},
+		{
+			in:  in{config: []byte{}},
+			out: out{err: errors.ErrEmpty},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.0.0"}, "storage": {"filesystems": [{"format": "ext4", "label": "zzzzzzzzzzzzzzzzzzzzzzzzzzz"}]}}`)},
+			out: out{err: errors.ErrInvalid},
+		},
+		{
+			in:  in{config: []byte(`{"ignition": {"version": "3.5.0-experimental"}, "storage": {"filesystems": [{"format": "ext4", "label": "zzzzzzzzzzzzzzzzzzzzzzzzzzz"}]}}`)},
+			out: out{err: errors.ErrInvalid},
+		},
+	}
+
+	for i, test := range tests {
+		config, report, err := Parse(test.in.config)
+		if test.out.err != err {
+			t.Errorf("#%d: bad error: want %v, got %v, report: %+v", i, test.out.err, err, report)
+		}
+		if test.out.err == errors.ErrInvalid && len(report.Entries) == 0 {
+			t.Errorf("#%d: expected report, got none", i)
+		}
+		assert.Equal(t, test.out.config, config, "#%d: bad config, report: %+v", i, report)
+	}
+	for i, test := range testsCompt {
+		config, report, err := ParseCompatibleVersion(test.in.config)
+		if test.out.err != err {
+			t.Errorf("#%d: bad error: want %v, got %v, report: %+v", i, test.out.err, err, report)
+		}
+		if test.out.err == errors.ErrInvalid && len(report.Entries) == 0 {
+			t.Errorf("#%d: expected report, got none", i)
+		}
+		assert.Equal(t, test.out.config, config, "#%d: bad config, report: %+v", i, report)
+	}
+}
diff --git a/config/v3_5_experimental/schema/ignition.json b/config/v3_5_experimental/schema/ignition.json
new file mode 100644
index 00000000..740125bb
--- /dev/null
+++ b/config/v3_5_experimental/schema/ignition.json
@@ -0,0 +1,674 @@
+{
+  "$schema": "http://json-schema.org/draft-04/schema#",
+  "title": "ignition",
+  "type": "object",
+  "properties": {
+    "ignition": {
+      "$ref": "#/definitions/ignition"
+    },
+    "storage": {
+      "$ref": "#/definitions/storage"
+    },
+    "systemd": {
+      "$ref": "#/definitions/systemd"
+    },
+    "passwd": {
+      "$ref": "#/definitions/passwd"
+    },
+    "kernelArguments": {
+      "$ref": "#/definitions/kernelArguments"
+    }
+  },
+  "required": [
+    "ignition"
+  ],
+  "definitions": {
+    "resource": {
+      "type": "object",
+      "properties": {
+        "source": {
+          "type": ["string", "null"]
+        },
+        "compression": {
+          "type": ["string", "null"]
+        },
+        "httpHeaders": {
+          "$ref": "#/definitions/httpHeaders"
+        },
+        "verification": {
+          "$ref": "#/definitions/verification"
+        }
+      }
+    },
+    "verification": {
+      "type": "object",
+      "properties": {
+        "hash": { "type": ["string", "null"] }
+      }
+    },
+    "httpHeaders": {
+      "type": "array",
+      "items": {
+        "type": "object",
+        "properties": {
+          "name": {
+            "type": "string"
+          },
+          "value": {
+            "type": ["string", "null"]
+          }
+        },
+        "required": [
+            "name"
+        ]
+      }
+    },
+    "ignition": {
+      "type": "object",
+      "properties": {
+        "version": {
+          "type": "string"
+        },
+        "config": {
+          "$ref": "#/definitions/ignition/definitions/ignition-config"
+        },
+        "timeouts": {
+          "$ref": "#/definitions/ignition/definitions/timeouts"
+        },
+        "security": {
+          "$ref": "#/definitions/ignition/definitions/security"
+        },
+        "proxy": {
+          "$ref": "#/definitions/ignition/definitions/proxy"
+        }
+      },
+      "definitions": {
+        "ignition-config": {
+          "type": "object",
+          "properties": {
+            "merge": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/resource"
+              }
+            },
+            "replace": {
+              "$ref": "#/definitions/resource"
+            }
+          }
+        },
+        "security": {
+          "type": "object",
+          "properties": {
+            "tls": {
+              "type": "object",
+              "properties": {
+                "certificateAuthorities": {
+                  "type": "array",
+                  "items": {
+                    "$ref": "#/definitions/resource"
+                  }
+                }
+              }
+            }
+          }
+        },
+        "proxy": {
+          "type": "object",
+          "properties": {
+            "httpProxy": {
+              "type": ["string", "null"]
+            },
+            "httpsProxy": {
+              "type": ["string", "null"]
+            },
+            "noProxy": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            }
+          }
+        },
+        "timeouts": {
+          "type": "object",
+          "properties": {
+            "httpResponseHeaders": {
+              "type": ["integer", "null"]
+            },
+            "httpTotal": {
+              "type": ["integer", "null"]
+            }
+          }
+        }
+      },
+      "required": [
+        "version"
+      ]
+    },
+    "storage": {
+      "type": "object",
+      "properties": {
+        "disks": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/storage/definitions/disk"
+          }
+        },
+        "raid": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/storage/definitions/raid"
+          }
+        },
+        "luks": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/storage/definitions/luks"
+          }
+        },
+        "filesystems": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/storage/definitions/filesystem"
+          }
+        },
+        "files": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/storage/definitions/file"
+          }
+        },
+        "directories": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/storage/definitions/directory"
+          }
+        },
+        "links": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/storage/definitions/link"
+          }
+        }
+      },
+      "definitions": {
+        "disk": {
+          "type": "object",
+          "properties": {
+            "device": {
+              "type": "string"
+            },
+            "wipeTable": {
+              "type": ["boolean", "null"]
+            },
+            "partitions": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/storage/definitions/partition"
+              }
+            }
+          },
+          "required": [
+              "device"
+          ]
+        },
+        "raid": {
+          "type": "object",
+          "properties": {
+            "name": {
+              "type": "string"
+            },
+            "level": {
+              "type": ["string", "null"]
+            },
+            "spares": {
+              "type": ["integer", "null"]
+            },
+            "devices": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            },
+            "options": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            }
+          },
+          "required": [
+              "name"
+          ]
+        },
+        "luks": {
+          "type": "object",
+          "properties": {
+            "name": {
+              "type": "string"
+            },
+            "label": {
+              "type": ["string", "null"]
+            },
+            "uuid": {
+              "type": ["string", "null"]
+            },
+            "device": {
+              "type": ["string", "null"]
+            },
+            "keyFile": {
+              "$ref": "#/definitions/resource"
+            },
+            "wipeVolume": {
+              "type": ["boolean", "null"]
+            },
+            "clevis": {
+              "$ref": "#/definitions/storage/definitions/clevis"
+            },
+            "options": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            },
+            "discard": {
+              "type": ["boolean", "null"]
+            },
+            "openOptions": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            }
+          },
+          "required": [
+              "name"
+          ]
+        },
+        "clevis": {
+          "type": "object",
+          "properties": {
+            "custom": {
+              "$ref": "#/definitions/storage/definitions/clevisCustom"
+            },
+            "tpm2": {
+              "type": ["boolean", "null"]
+            },
+            "tang": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/storage/definitions/tang"
+              }
+            },
+            "threshold": {
+              "type": ["integer", "null"]
+            }
+          }
+        },
+        "clevisCustom": {
+          "type": "object",
+          "properties": {
+            "pin": {
+              "type": ["string", "null"]
+            },
+            "config": {
+              "type": ["string", "null"]
+            },
+            "needsNetwork": {
+              "type": ["boolean", "null"]
+            }
+          }
+        },
+        "tang": {
+          "type": "object",
+          "properties": {
+            "url": {
+                "type": "string"
+            },
+            "thumbprint": {
+              "type": ["string", "null"]
+            },
+            "advertisement": {
+              "type": ["string", "null"]
+            }
+          }
+        },
+        "filesystem": {
+          "type": "object",
+          "properties": {
+            "path": {
+              "type": ["string", "null"]
+            },
+            "device": {
+              "type": "string"
+            },
+            "format": {
+              "type": ["string", "null"]
+            },
+            "options": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            },
+            "mountOptions": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            },
+            "wipeFilesystem": {
+              "type": ["boolean", "null"]
+            },
+            "label": {
+              "type": ["string", "null"]
+            },
+            "uuid": {
+              "type": ["string", "null"]
+            }
+          },
+          "required": [
+              "device"
+          ]
+        },
+        "file": {
+          "allOf": [
+            {
+              "$ref": "#/definitions/storage/definitions/node"
+            },
+            {
+              "type": "object",
+              "properties": {
+                "mode": {
+                  "type": ["integer", "null"]
+                },
+                "contents": {
+                  "$ref": "#/definitions/resource"
+                },
+                "append": {
+                  "type": "array",
+                  "items": {
+                    "$ref": "#/definitions/resource"
+                  }
+                }
+              }
+            }
+          ]
+        },
+        "directory": {
+          "allOf": [
+            {
+              "$ref": "#/definitions/storage/definitions/node"
+            },
+            {
+              "type": "object",
+              "properties": {
+                "mode": {
+                  "type": ["integer", "null"]
+                }
+              }
+            }
+          ]
+        },
+        "link": {
+          "allOf": [
+            {
+              "$ref": "#/definitions/storage/definitions/node"
+            },
+            {
+              "type": "object",
+              "properties": {
+                "target": {
+                  "type": ["string", "null"]
+                },
+                "hard": {
+                  "type": ["boolean", "null"]
+                }
+              }
+            }
+          ]
+        },
+        "partition": {
+          "type": "object",
+          "properties": {
+            "label": {
+              "type": ["string", "null"]
+            },
+            "number": {
+              "type": "integer"
+            },
+            "sizeMiB": {
+              "type": ["integer", "null"]
+            },
+            "startMiB": {
+              "type": ["integer", "null"]
+            },
+            "typeGuid": {
+              "type": ["string", "null"]
+            },
+            "guid": {
+              "type": ["string", "null"]
+            },
+            "wipePartitionEntry": {
+              "type": ["boolean", "null"]
+            },
+            "shouldExist": {
+              "type": ["boolean", "null"]
+            },
+            "resize": {
+              "type": ["boolean", "null"]
+            }
+          }
+        },
+        "node": {
+          "type": "object",
+          "properties": {
+            "path": {
+              "type": "string"
+            },
+            "overwrite": {
+              "type": ["boolean", "null"]
+            },
+            "user": {
+              "type": "object",
+              "properties": {
+                "id": {
+                  "type": ["integer", "null"]
+                },
+                "name": {
+                  "type": ["string", "null"]
+                }
+              }
+            },
+            "group": {
+              "type": "object",
+              "properties": {
+                "id": {
+                  "type": ["integer", "null"]
+                },
+                "name": {
+                  "type": ["string", "null"]
+                }
+              }
+            }
+          },
+          "required": [
+              "path"
+          ]
+        }
+      }
+    },
+    "systemd": {
+      "type": "object",
+      "properties": {
+        "units": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/systemd/definitions/unit"
+          }
+        }
+      },
+      "definitions": {
+        "unit": {
+          "type": "object",
+          "properties": {
+            "name": {
+              "type": "string"
+            },
+            "enabled": {
+              "type": ["boolean", "null"]
+            },
+            "mask": {
+              "type": ["boolean", "null"]
+            },
+            "contents": {
+              "type": ["string", "null"]
+            },
+            "dropins": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/systemd/definitions/dropin"
+              }
+            }
+          },
+          "required": [
+              "name"
+          ]
+        },
+        "dropin": {
+          "type": "object",
+          "properties": {
+            "name": {
+              "type": "string"
+            },
+            "contents": {
+              "type": ["string", "null"]
+            }
+          },
+          "required": [
+              "name"
+          ]
+        }
+      }
+    },
+    "kernelArguments": {
+      "type": "object",
+      "properties": {
+        "shouldExist": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/kernelArgument"
+          }
+        },
+        "shouldNotExist": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/kernelArgument"
+          }
+        }
+      }
+    },
+    "kernelArgument": {
+      "type": "string"
+    },
+    "passwd": {
+      "type": "object",
+      "properties": {
+        "users": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/passwd/definitions/user"
+          }
+        },
+        "groups": {
+          "type": "array",
+          "items": {
+            "$ref": "#/definitions/passwd/definitions/group"
+          }
+        }
+      },
+      "definitions": {
+        "user": {
+          "type": "object",
+          "properties": {
+            "name": {
+              "type": "string"
+            },
+            "passwordHash": {
+              "type": ["string", "null"]
+            },
+            "sshAuthorizedKeys": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            },
+            "uid": {
+              "type": ["integer", "null"]
+            },
+            "gecos": {
+              "type": ["string", "null"]
+            },
+            "homeDir": {
+              "type": ["string", "null"]
+            },
+            "noCreateHome": {
+              "type": ["boolean", "null"]
+            },
+            "primaryGroup": {
+              "type": ["string", "null"]
+            },
+            "groups": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            },
+            "noUserGroup": {
+              "type": ["boolean", "null"]
+            },
+            "system": {
+              "type": ["boolean", "null"]
+            },
+            "noLogInit": {
+              "type": ["boolean", "null"]
+            },
+            "shell": {
+              "type": ["string", "null"]
+            },
+            "shouldExist": {
+              "type": ["boolean", "null"]
+            }
+          },
+          "required": [
+              "name"
+          ]
+        },
+        "group": {
+          "type": "object",
+          "properties": {
+            "name": {
+              "type": "string"
+            },
+            "gid": {
+              "type": ["integer", "null"]
+            },
+            "passwordHash": {
+              "type": ["string", "null"]
+            },
+            "system": {
+              "type": ["boolean", "null"]
+            },
+            "shouldExist": {
+              "type": ["boolean", "null"]
+            }
+          },
+          "required": [
+              "name"
+          ]
+        }
+      }
+    }
+  }
+}
diff --git a/config/v3_5_experimental/translate/translate.go b/config/v3_5_experimental/translate/translate.go
new file mode 100644
index 00000000..5647e629
--- /dev/null
+++ b/config/v3_5_experimental/translate/translate.go
@@ -0,0 +1,35 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package translate
+
+import (
+	"github.com/coreos/ignition/v2/config/translate"
+	old_types "github.com/coreos/ignition/v2/config/v3_4/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+)
+
+func translateIgnition(old old_types.Ignition) (ret types.Ignition) {
+	// use a new translator so we don't recurse infinitely
+	translate.NewTranslator().Translate(&old, &ret)
+	ret.Version = types.MaxVersion.String()
+	return
+}
+
+func Translate(old old_types.Config) (ret types.Config) {
+	tr := translate.NewTranslator()
+	tr.AddCustomTranslator(translateIgnition)
+	tr.Translate(&old, &ret)
+	return
+}
diff --git a/config/v3_5_experimental/translate/translate_test.go b/config/v3_5_experimental/translate/translate_test.go
new file mode 100644
index 00000000..7896facc
--- /dev/null
+++ b/config/v3_5_experimental/translate/translate_test.go
@@ -0,0 +1,32 @@
+// Copyright 2021 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package translate
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/util"
+	old "github.com/coreos/ignition/v2/config/v3_4/types"
+)
+
+// Check that we have valid translators for the complete config struct
+// hierarchy; Translate will panic if not.  We need to use a deeply non-zero
+// struct to ensure translation descends into every type.
+func TestTranslate(t *testing.T) {
+	typ := reflect.TypeOf(old.Config{})
+	config := util.NonZeroValue(typ).Interface().(old.Config)
+	Translate(config)
+}
diff --git a/config/v3_5_experimental/types/clevis.go b/config/v3_5_experimental/types/clevis.go
new file mode 100644
index 00000000..68887d43
--- /dev/null
+++ b/config/v3_5_experimental/types/clevis.go
@@ -0,0 +1,49 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (c Clevis) IsPresent() bool {
+	return util.NotEmpty(c.Custom.Pin) ||
+		len(c.Tang) > 0 ||
+		util.IsTrue(c.Tpm2) ||
+		c.Threshold != nil && *c.Threshold != 0
+}
+
+func (cu ClevisCustom) Validate(c path.ContextPath) (r report.Report) {
+	if util.NilOrEmpty(cu.Pin) && util.NilOrEmpty(cu.Config) && !util.IsTrue(cu.NeedsNetwork) {
+		return
+	}
+	if util.NotEmpty(cu.Pin) {
+		switch *cu.Pin {
+		case "tpm2", "tang", "sss":
+		default:
+			r.AddOnError(c.Append("pin"), errors.ErrUnknownClevisPin)
+		}
+	} else {
+		r.AddOnError(c.Append("pin"), errors.ErrClevisPinRequired)
+	}
+	if util.NilOrEmpty(cu.Config) {
+		r.AddOnError(c.Append("config"), errors.ErrClevisConfigRequired)
+	}
+	return
+}
diff --git a/config/v3_5_experimental/types/clevis_test.go b/config/v3_5_experimental/types/clevis_test.go
new file mode 100644
index 00000000..f616868c
--- /dev/null
+++ b/config/v3_5_experimental/types/clevis_test.go
@@ -0,0 +1,78 @@
+// Copyright 2021 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestClevisCustomValidate(t *testing.T) {
+	tests := []struct {
+		in  ClevisCustom
+		at  path.ContextPath
+		out error
+	}{
+		{
+			in:  ClevisCustom{},
+			out: nil,
+		},
+		{
+			in: ClevisCustom{
+				Config:       util.StrToPtr("z"),
+				NeedsNetwork: util.BoolToPtr(true),
+				Pin:          util.StrToPtr("sss"),
+			},
+			out: nil,
+		},
+		{
+			in: ClevisCustom{
+				Config: util.StrToPtr("z"),
+			},
+			at:  path.New("", "pin"),
+			out: errors.ErrClevisPinRequired,
+		},
+		{
+			in: ClevisCustom{
+				Config: util.StrToPtr("z"),
+				Pin:    util.StrToPtr("z"),
+			},
+			at:  path.New("", "pin"),
+			out: errors.ErrUnknownClevisPin,
+		},
+		{
+			in: ClevisCustom{
+				Pin: util.StrToPtr("tpm2"),
+			},
+			at:  path.New("", "config"),
+			out: errors.ErrClevisConfigRequired,
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/config.go b/config/v3_5_experimental/types/config.go
new file mode 100644
index 00000000..40c27106
--- /dev/null
+++ b/config/v3_5_experimental/types/config.go
@@ -0,0 +1,65 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/go-semver/semver"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+var (
+	MaxVersion = semver.Version{
+		Major:      3,
+		Minor:      5,
+		PreRelease: "experimental",
+	}
+)
+
+func (cfg Config) Validate(c path.ContextPath) (r report.Report) {
+	systemdPath := "/etc/systemd/system/"
+	unitPaths := map[string]struct{}{}
+	for _, unit := range cfg.Systemd.Units {
+		if !util.NilOrEmpty(unit.Contents) {
+			pathString := systemdPath + unit.Name
+			unitPaths[pathString] = struct{}{}
+		}
+		for _, dropin := range unit.Dropins {
+			if !util.NilOrEmpty(dropin.Contents) {
+				pathString := systemdPath + unit.Name + ".d/" + dropin.Name
+				unitPaths[pathString] = struct{}{}
+			}
+		}
+	}
+	for i, f := range cfg.Storage.Files {
+		if _, exists := unitPaths[f.Path]; exists {
+			r.AddOnError(c.Append("storage", "files", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, d := range cfg.Storage.Directories {
+		if _, exists := unitPaths[d.Path]; exists {
+			r.AddOnError(c.Append("storage", "directories", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	for i, l := range cfg.Storage.Links {
+		if _, exists := unitPaths[l.Path]; exists {
+			r.AddOnError(c.Append("storage", "links", i, "path"), errors.ErrPathConflictsSystemd)
+		}
+	}
+	return
+}
diff --git a/config/v3_5_experimental/types/config_test.go b/config/v3_5_experimental/types/config_test.go
new file mode 100644
index 00000000..3d82627b
--- /dev/null
+++ b/config/v3_5_experimental/types/config_test.go
@@ -0,0 +1,260 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestConfigValidation(t *testing.T) {
+	tests := []struct {
+		in  Config
+		out error
+		at  path.ContextPath
+	}{
+		// test 0: file conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 1: file conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "files", 0, "path"),
+		},
+		// test 2: directory conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 3: directory conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "directories", 0, "path"),
+		},
+		// test 4: link conflicts with systemd dropin file, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service.d/bar.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/qux.conf")},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name: "foo.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Bar"),
+								},
+							},
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 5: link conflicts with systemd unit, error
+		{
+			in: Config{
+				Storage: Storage{
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/foo.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/qux.conf")},
+						},
+					},
+				},
+				Systemd: Systemd{
+					[]Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			out: errors.ErrPathConflictsSystemd,
+			at:  path.New("json", "storage", "links", 0, "path"),
+		},
+		// test 6: non-conflicting scenarios
+		{
+			in: Config{
+				Storage: Storage{
+					Files: []File{
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service.d/baz.conf"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/bar.service"},
+						},
+						{
+							Node: Node{Path: "/etc/systemd/system/foo.service.d/qux.conf"},
+						},
+					},
+					Links: []Link{
+						{
+							Node:          Node{Path: "/etc/systemd/system/qux.service"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/qux.conf")},
+						},
+						{
+							Node:          Node{Path: "/etc/systemd/system/quux.service.d/foo.conf"},
+							LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo.conf")},
+						},
+					},
+					Directories: []Directory{
+						{
+							Node: Node{Path: "/etc/systemd/system/quux.service.d"},
+						},
+					},
+				},
+				Systemd: Systemd{
+					Units: []Unit{
+						{
+							Name:     "foo.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+						{
+							Name: "bar.service",
+							Dropins: []Dropin{
+								{
+									Name: "baz.conf",
+								},
+							},
+							Enabled: util.BoolToPtr(true),
+						},
+						{
+							Name: "qux.service",
+							Dropins: []Dropin{
+								{
+									Name:     "bar.conf",
+									Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+								},
+							},
+						},
+						{
+							Name:     "quux.service",
+							Contents: util.StrToPtr("[Foo]\nQux=Baz"),
+							Enabled:  util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+		},
+	}
+	for i, test := range tests {
+		r := test.in.Validate(path.New("json"))
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad error: expected : %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/device.go b/config/v3_5_experimental/types/device.go
new file mode 100644
index 00000000..a10ce97b
--- /dev/null
+++ b/config/v3_5_experimental/types/device.go
@@ -0,0 +1,25 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (d Device) Validate(c path.ContextPath) (r report.Report) {
+	r.AddOnError(c, validatePath(string(d)))
+	return
+}
diff --git a/config/v3_5_experimental/types/directory.go b/config/v3_5_experimental/types/directory.go
new file mode 100644
index 00000000..f6f06845
--- /dev/null
+++ b/config/v3_5_experimental/types/directory.go
@@ -0,0 +1,26 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (d Directory) Validate(c path.ContextPath) (r report.Report) {
+	r.Merge(d.Node.Validate(c))
+	r.AddOnError(c.Append("mode"), validateMode(d.Mode))
+	return
+}
diff --git a/config/v3_5_experimental/types/disk.go b/config/v3_5_experimental/types/disk.go
new file mode 100644
index 00000000..8caf8499
--- /dev/null
+++ b/config/v3_5_experimental/types/disk.go
@@ -0,0 +1,135 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (d Disk) Key() string {
+	return d.Device
+}
+
+func (n Disk) Validate(c path.ContextPath) (r report.Report) {
+	if len(n.Device) == 0 {
+		r.AddOnError(c.Append("device"), errors.ErrDiskDeviceRequired)
+		return
+	}
+	r.AddOnError(c.Append("device"), validatePath(n.Device))
+
+	if collides, p := n.partitionNumbersCollide(); collides {
+		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionNumbersCollide)
+	}
+	if overlaps, p := n.partitionsOverlap(); overlaps {
+		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionsOverlap)
+	}
+	if n.partitionsMixZeroesAndNonexistence() {
+		r.AddOnError(c.Append("partitions"), errors.ErrZeroesWithShouldNotExist)
+	}
+	if collides, p := n.partitionLabelsCollide(); collides {
+		r.AddOnError(c.Append("partitions", p), errors.ErrDuplicateLabels)
+	}
+	return
+}
+
+// partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique. It also returns the
+// index of the colliding partition
+func (n Disk) partitionNumbersCollide() (bool, int) {
+	m := map[int][]int{} // from partition number to index into array
+	for i, p := range n.Partitions {
+		if p.Number != 0 {
+			// a number of 0 means next available number, multiple devices can specify this
+			m[p.Number] = append(m[p.Number], i)
+		}
+	}
+	for _, n := range m {
+		if len(n) > 1 {
+			// TODO(vc): return information describing the collision for logging
+			return true, n[1]
+		}
+	}
+	return false, 0
+}
+
+func (d Disk) partitionLabelsCollide() (bool, int) {
+	m := map[string]struct{}{}
+	for i, p := range d.Partitions {
+		if p.Label != nil {
+			// a number of 0 means next available number, multiple devices can specify this
+			if _, exists := m[*p.Label]; exists {
+				return true, i
+			}
+			m[*p.Label] = struct{}{}
+		}
+	}
+	return false, 0
+}
+
+// end returns the last sector of a partition. Only used by partitionsOverlap. Requires non-nil Start and Size.
+func (p Partition) end() int {
+	if *p.SizeMiB == 0 {
+		// a size of 0 means "fill available", just return the start as the end for those.
+		return *p.StartMiB
+	}
+	return *p.StartMiB + *p.SizeMiB - 1
+}
+
+// partitionsOverlap returns true if any explicitly dimensioned partitions overlap. It also returns the index of
+// the overlapping partition
+func (n Disk) partitionsOverlap() (bool, int) {
+	for _, p := range n.Partitions {
+		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
+		// We aren't going to check those for overlap since we don't have the disk geometry.
+		if p.StartMiB == nil || p.SizeMiB == nil || *p.StartMiB == 0 {
+			continue
+		}
+
+		for i, o := range n.Partitions {
+			if o.StartMiB == nil || o.SizeMiB == nil || p == o || *o.StartMiB == 0 {
+				continue
+			}
+
+			// is p.StartMiB within o?
+			if *p.StartMiB >= *o.StartMiB && *p.StartMiB <= o.end() {
+				return true, i
+			}
+
+			// is p.end() within o?
+			if p.end() >= *o.StartMiB && p.end() <= o.end() {
+				return true, i
+			}
+
+			// do p.StartMiB and p.end() straddle o?
+			if *p.StartMiB < *o.StartMiB && p.end() > o.end() {
+				return true, i
+			}
+		}
+	}
+	return false, 0
+}
+
+func (n Disk) partitionsMixZeroesAndNonexistence() bool {
+	hasZero := false
+	hasShouldNotExist := false
+	for _, p := range n.Partitions {
+		hasShouldNotExist = hasShouldNotExist || util.IsFalse(p.ShouldExist)
+		hasZero = hasZero || (p.Number == 0)
+	}
+	return hasZero && hasShouldNotExist
+}
diff --git a/config/v3_5_experimental/types/file.go b/config/v3_5_experimental/types/file.go
new file mode 100644
index 00000000..9b71bb26
--- /dev/null
+++ b/config/v3_5_experimental/types/file.go
@@ -0,0 +1,43 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (f File) Validate(c path.ContextPath) (r report.Report) {
+	r.Merge(f.Node.Validate(c))
+	r.AddOnError(c.Append("mode"), validateMode(f.Mode))
+	r.AddOnError(c.Append("overwrite"), f.validateOverwrite())
+	return
+}
+
+func (f File) validateOverwrite() error {
+	if util.IsTrue(f.Overwrite) && f.Contents.Source == nil {
+		return errors.ErrOverwriteAndNilSource
+	}
+	return nil
+}
+
+func (f FileEmbedded1) IgnoreDuplicates() map[string]struct{} {
+	return map[string]struct{}{
+		"Append": {},
+	}
+}
diff --git a/config/v3_5_experimental/types/file_test.go b/config/v3_5_experimental/types/file_test.go
new file mode 100644
index 00000000..449e0700
--- /dev/null
+++ b/config/v3_5_experimental/types/file_test.go
@@ -0,0 +1,117 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+)
+
+func TestFileValidateOverwrite(t *testing.T) {
+	tests := []struct {
+		in  File
+		out error
+	}{
+		{
+			File{},
+			nil,
+		},
+		{
+			File{
+				Node: Node{
+					Overwrite: util.BoolToPtr(true),
+				},
+			},
+			errors.ErrOverwriteAndNilSource,
+		},
+		{
+			File{
+				Node: Node{
+					Overwrite: util.BoolToPtr(true),
+				},
+				FileEmbedded1: FileEmbedded1{
+					Contents: Resource{
+						Source: util.StrToPtr(""),
+					},
+				},
+			},
+			nil,
+		},
+		{
+			File{
+				Node: Node{
+					Overwrite: util.BoolToPtr(true),
+				},
+				FileEmbedded1: FileEmbedded1{
+					Contents: Resource{
+						Source: util.StrToPtr("http://example.com"),
+					},
+				},
+			},
+			nil,
+		},
+	}
+
+	for i, test := range tests {
+		err := test.in.validateOverwrite()
+		if test.out != err {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out, err)
+		}
+	}
+}
+
+func TestFileContentsValidate(t *testing.T) {
+	tests := []struct {
+		in  Resource
+		out error
+	}{
+		{
+			Resource{},
+			nil,
+		},
+		{
+			Resource{
+				Source: util.StrToPtr(""),
+			},
+			nil,
+		},
+		{
+			Resource{
+				Source: util.StrToPtr(""),
+				Verification: Verification{
+					Hash: util.StrToPtr(""),
+				},
+			},
+			nil,
+		},
+		{
+			Resource{
+				Verification: Verification{
+					Hash: util.StrToPtr(""),
+				},
+			},
+			errors.ErrVerificationAndNilSource,
+		},
+	}
+
+	for i, test := range tests {
+		err := test.in.validateVerification()
+		if test.out != err {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out, err)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/filesystem.go b/config/v3_5_experimental/types/filesystem.go
new file mode 100644
index 00000000..c722b363
--- /dev/null
+++ b/config/v3_5_experimental/types/filesystem.go
@@ -0,0 +1,106 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (f Filesystem) Key() string {
+	return f.Device
+}
+
+func (f Filesystem) IgnoreDuplicates() map[string]struct{} {
+	return map[string]struct{}{
+		"Options":      {},
+		"MountOptions": {},
+	}
+}
+
+func (f Filesystem) Validate(c path.ContextPath) (r report.Report) {
+	r.AddOnError(c.Append("path"), f.validatePath())
+	r.AddOnError(c.Append("device"), validatePath(f.Device))
+	r.AddOnError(c.Append("format"), f.validateFormat())
+	r.AddOnError(c.Append("label"), f.validateLabel())
+	return
+}
+
+func (f Filesystem) validatePath() error {
+	return validatePathNilOK(f.Path)
+}
+
+func (f Filesystem) validateFormat() error {
+	if util.NilOrEmpty(f.Format) {
+		if util.NotEmpty(f.Path) ||
+			util.NotEmpty(f.Label) ||
+			util.NotEmpty(f.UUID) ||
+			util.IsTrue(f.WipeFilesystem) ||
+			len(f.MountOptions) != 0 ||
+			len(f.Options) != 0 {
+			return errors.ErrFormatNilWithOthers
+		}
+	} else {
+		switch *f.Format {
+		case "ext4", "btrfs", "xfs", "swap", "vfat", "none":
+		default:
+			return errors.ErrFilesystemInvalidFormat
+		}
+	}
+	return nil
+}
+
+func (f Filesystem) validateLabel() error {
+	if util.NilOrEmpty(f.Label) {
+		return nil
+	}
+	if util.NilOrEmpty(f.Format) {
+		return errors.ErrLabelNeedsFormat
+	}
+
+	switch *f.Format {
+	case "ext4":
+		if len(*f.Label) > 16 {
+			// source: man mkfs.ext4
+			return errors.ErrExt4LabelTooLong
+		}
+	case "btrfs":
+		if len(*f.Label) > 256 {
+			// source: man mkfs.btrfs
+			return errors.ErrBtrfsLabelTooLong
+		}
+	case "xfs":
+		if len(*f.Label) > 12 {
+			// source: man mkfs.xfs
+			return errors.ErrXfsLabelTooLong
+		}
+	case "swap":
+		// mkswap's man page does not state a limit on label size, but through
+		// experimentation it appears that mkswap will truncate long labels to
+		// 15 characters, so let's enforce that.
+		if len(*f.Label) > 15 {
+			return errors.ErrSwapLabelTooLong
+		}
+	case "vfat":
+		if len(*f.Label) > 11 {
+			// source: man mkfs.fat
+			return errors.ErrVfatLabelTooLong
+		}
+	}
+	return nil
+}
diff --git a/config/v3_5_experimental/types/filesystem_test.go b/config/v3_5_experimental/types/filesystem_test.go
new file mode 100644
index 00000000..1f8db903
--- /dev/null
+++ b/config/v3_5_experimental/types/filesystem_test.go
@@ -0,0 +1,194 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+)
+
+func TestFilesystemValidateFormat(t *testing.T) {
+	tests := []struct {
+		in  Filesystem
+		out error
+	}{
+		{
+			Filesystem{Format: util.StrToPtr("ext4")},
+			nil,
+		},
+		{
+			Filesystem{Format: util.StrToPtr("btrfs")},
+			nil,
+		},
+		{
+			Filesystem{Format: util.StrToPtr("")},
+			nil,
+		},
+		{
+			Filesystem{Format: nil},
+			nil,
+		},
+		{
+			Filesystem{Label: util.StrToPtr("z")},
+			errors.ErrFormatNilWithOthers,
+		},
+		{
+			Filesystem{MountOptions: []MountOption{MountOption("z")}},
+			errors.ErrFormatNilWithOthers,
+		},
+		{
+			Filesystem{Options: []FilesystemOption{FilesystemOption("z")}},
+			errors.ErrFormatNilWithOthers,
+		},
+		{
+			Filesystem{Format: util.StrToPtr(""), Path: util.StrToPtr("/")},
+			errors.ErrFormatNilWithOthers,
+		},
+		{
+			Filesystem{Format: nil, Path: util.StrToPtr("/")},
+			errors.ErrFormatNilWithOthers,
+		},
+		{
+			Filesystem{UUID: util.StrToPtr("z")},
+			errors.ErrFormatNilWithOthers,
+		},
+		{
+			Filesystem{WipeFilesystem: util.BoolToPtr(true)},
+			errors.ErrFormatNilWithOthers,
+		},
+	}
+
+	for i, test := range tests {
+		err := test.in.validateFormat()
+		if test.out != err {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out, err)
+		}
+	}
+}
+
+func TestFilesystemValidatePath(t *testing.T) {
+	tests := []struct {
+		in  Filesystem
+		out error
+	}{
+		{
+			Filesystem{Path: util.StrToPtr("/foo")},
+			nil,
+		},
+		{
+			Filesystem{Path: util.StrToPtr("")},
+			nil,
+		},
+		{
+			Filesystem{Path: nil},
+			nil,
+		},
+		{
+			Filesystem{Path: util.StrToPtr("foo")},
+			errors.ErrPathRelative,
+		},
+	}
+
+	for i, test := range tests {
+		err := test.in.validatePath()
+		if test.out != err {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out, err)
+		}
+	}
+}
+
+func TestLabelValidate(t *testing.T) {
+	type in struct {
+		filesystem Filesystem
+	}
+	type out struct {
+		err error
+	}
+
+	tests := []struct {
+		in  in
+		out out
+	}{
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("ext4"), Label: nil}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("ext4"), Label: util.StrToPtr("data")}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("ext4"), Label: util.StrToPtr("thislabelistoolong")}},
+			out: out{err: errors.ErrExt4LabelTooLong},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("btrfs"), Label: nil}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("btrfs"), Label: util.StrToPtr("thislabelisnottoolong")}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("btrfs"), Label: util.StrToPtr("thislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolongthislabelistoolong")}},
+			out: out{err: errors.ErrBtrfsLabelTooLong},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("xfs"), Label: nil}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("xfs"), Label: util.StrToPtr("data")}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("xfs"), Label: util.StrToPtr("thislabelistoolong")}},
+			out: out{err: errors.ErrXfsLabelTooLong},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("swap"), Label: nil}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("swap"), Label: util.StrToPtr("data")}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("swap"), Label: util.StrToPtr("thislabelistoolong")}},
+			out: out{err: errors.ErrSwapLabelTooLong},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("vfat"), Label: nil}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("vfat"), Label: util.StrToPtr("data")}},
+			out: out{},
+		},
+		{
+			in:  in{filesystem: Filesystem{Format: util.StrToPtr("vfat"), Label: util.StrToPtr("thislabelistoolong")}},
+			out: out{err: errors.ErrVfatLabelTooLong},
+		},
+	}
+
+	for i, test := range tests {
+		err := test.in.filesystem.validateLabel()
+		if test.out.err != err {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out.err, err)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/headers.go b/config/v3_5_experimental/types/headers.go
new file mode 100644
index 00000000..be1aadad
--- /dev/null
+++ b/config/v3_5_experimental/types/headers.go
@@ -0,0 +1,65 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/http"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+// Parse generates standard net/http headers from the data in HTTPHeaders
+func (hs HTTPHeaders) Parse() (http.Header, error) {
+	headers := http.Header{}
+	for _, header := range hs {
+		if header.Name == "" {
+			return nil, errors.ErrEmptyHTTPHeaderName
+		}
+		if header.Value == nil || string(*header.Value) == "" {
+			return nil, errors.ErrInvalidHTTPHeader
+		}
+		headers.Add(header.Name, string(*header.Value))
+	}
+	return headers, nil
+}
+
+func (h HTTPHeader) Validate(c path.ContextPath) (r report.Report) {
+	r.AddOnError(c.Append("name"), h.validateName())
+	r.AddOnError(c.Append("value"), h.validateValue())
+	return
+}
+
+func (h HTTPHeader) validateName() error {
+	if h.Name == "" {
+		return errors.ErrEmptyHTTPHeaderName
+	}
+	return nil
+}
+
+func (h HTTPHeader) validateValue() error {
+	if h.Value == nil {
+		return nil
+	}
+	if string(*h.Value) == "" {
+		return errors.ErrInvalidHTTPHeader
+	}
+	return nil
+}
+
+func (h HTTPHeader) Key() string {
+	return h.Name
+}
diff --git a/config/v3_5_experimental/types/headers_test.go b/config/v3_5_experimental/types/headers_test.go
new file mode 100644
index 00000000..40380b68
--- /dev/null
+++ b/config/v3_5_experimental/types/headers_test.go
@@ -0,0 +1,159 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+)
+
+func toPointer(val string) *string {
+	return &val
+}
+
+func equal(a, b []string) bool {
+	if len(a) != len(b) {
+		return false
+	}
+	for i, v := range a {
+		if v != b[i] {
+			return false
+		}
+	}
+	return true
+}
+
+func TestHeadersParse(t *testing.T) {
+	tests := []struct {
+		in  HTTPHeaders
+		out error
+	}{
+		{
+			// Valid headers
+			HTTPHeaders{
+				HTTPHeader{
+					Name:  "header1",
+					Value: toPointer("header1value"),
+				},
+				HTTPHeader{
+					Name:  "header2",
+					Value: toPointer("header2value"),
+				},
+			},
+			nil,
+		},
+		{
+			// Duplicate headers
+			HTTPHeaders{
+				HTTPHeader{
+					Name:  "header1",
+					Value: toPointer("header1value"),
+				},
+				HTTPHeader{
+					Name:  "header1",
+					Value: toPointer("header2value"),
+				},
+			},
+			nil,
+		},
+		{
+			// No header name
+			HTTPHeaders{
+				HTTPHeader{
+					Name:  "header1",
+					Value: toPointer("header1value"),
+				},
+				HTTPHeader{
+					Value: toPointer("emptyheadervalue"),
+				},
+			},
+			errors.ErrEmptyHTTPHeaderName,
+		},
+		{
+			// No header value
+			HTTPHeaders{
+				HTTPHeader{
+					Name:  "header1",
+					Value: toPointer("header1value"),
+				},
+				HTTPHeader{
+					Name: "emptyheadername",
+				},
+			},
+			errors.ErrInvalidHTTPHeader,
+		},
+		{
+			// Invalid header without elements
+			HTTPHeaders{
+				HTTPHeader{
+					Name:  "header1",
+					Value: toPointer("header1value"),
+				},
+				HTTPHeader{},
+			},
+			errors.ErrEmptyHTTPHeaderName,
+		},
+	}
+
+	for i, test := range tests {
+		_, err := test.in.Parse()
+		if test.out != err {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out, err)
+		}
+	}
+}
+
+func TestValidHeadersParse(t *testing.T) {
+	// Valid headers
+	headers := HTTPHeaders{
+		HTTPHeader{
+			Name:  "header1",
+			Value: toPointer("header1value"),
+		},
+		HTTPHeader{
+			Name:  "header2",
+			Value: toPointer("header2value"),
+		},
+	}
+	parseHeaders, err := headers.Parse()
+	if err != nil {
+		t.Errorf("error during parsing valid headers: %v", err)
+	}
+	if !equal(parseHeaders["Header1"], []string{"header1value"}) || !equal(parseHeaders["Header2"], []string{"header2value"}) {
+		t.Errorf("parsed HTTP headers values are wrong")
+	}
+}
+
+func TestDuplicateHeadersParse(t *testing.T) {
+	// Duplicate headers
+	headers := HTTPHeaders{
+		HTTPHeader{
+			Name:  "header1",
+			Value: toPointer("header1value"),
+		},
+		HTTPHeader{
+			Name:  "header1",
+			Value: toPointer("header2value"),
+		},
+	}
+	parseHeaders, err := headers.Parse()
+	if err != nil {
+		t.Errorf("error during parsing valid headers: %v", err)
+	}
+	if !equal(parseHeaders["Header1"], []string{"header1value", "header2value"}) {
+		t.Errorf("parsed HTTP headers values are wrong")
+	}
+}
diff --git a/config/v3_5_experimental/types/ignition.go b/config/v3_5_experimental/types/ignition.go
new file mode 100644
index 00000000..190445bd
--- /dev/null
+++ b/config/v3_5_experimental/types/ignition.go
@@ -0,0 +1,49 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (v Ignition) Semver() (*semver.Version, error) {
+	return semver.NewVersion(v.Version)
+}
+
+func (ic IgnitionConfig) Validate(c path.ContextPath) (r report.Report) {
+	for i, res := range ic.Merge {
+		r.AddOnError(c.Append("merge", i), res.validateRequiredSource())
+	}
+	return
+}
+
+func (v Ignition) Validate(c path.ContextPath) (r report.Report) {
+	c = c.Append("version")
+	tv, err := v.Semver()
+	if err != nil {
+		r.AddOnError(c, errors.ErrInvalidVersion)
+		return
+	}
+
+	if MaxVersion != *tv {
+		r.AddOnError(c, errors.ErrUnknownVersion)
+	}
+	return
+}
diff --git a/config/v3_5_experimental/types/ignition_test.go b/config/v3_5_experimental/types/ignition_test.go
new file mode 100644
index 00000000..ac7d462d
--- /dev/null
+++ b/config/v3_5_experimental/types/ignition_test.go
@@ -0,0 +1,48 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"testing"
+
+	"github.com/coreos/vcontext/validate"
+)
+
+func TestIgnitionConfigValidate(t *testing.T) {
+	tests := []struct {
+		in  IgnitionConfig
+		out string
+	}{
+		{
+			IgnitionConfig{
+				Merge: []Resource{{}},
+			},
+			"error at $.merge.0: source is required\n",
+		},
+		{
+			IgnitionConfig{
+				Replace: Resource{},
+			},
+			"",
+		},
+	}
+
+	for i, test := range tests {
+		r := validate.Validate(test.in, "test")
+		if test.out != r.String() {
+			t.Errorf("#%d: bad error: want %q, got %q", i, test.out, r.String())
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/kargs.go b/config/v3_5_experimental/types/kargs.go
new file mode 100644
index 00000000..42c29408
--- /dev/null
+++ b/config/v3_5_experimental/types/kargs.go
@@ -0,0 +1,22 @@
+// Copyright 2021 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+func (k KernelArguments) MergedKeys() map[string]string {
+	return map[string]string{
+		"ShouldExist":    "KernelArgument",
+		"ShouldNotExist": "KernelArgument",
+	}
+}
diff --git a/config/v3_5_experimental/types/kargs_test.go b/config/v3_5_experimental/types/kargs_test.go
new file mode 100644
index 00000000..1a258727
--- /dev/null
+++ b/config/v3_5_experimental/types/kargs_test.go
@@ -0,0 +1,51 @@
+// Copyright 2021 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/validate"
+)
+
+func TestKernelArgumentsValidate(t *testing.T) {
+	tests := []struct {
+		in  KernelArguments
+		out string
+	}{
+		// Ensure that ValidateWithContext prevents duplicate entries
+		// in ShouldExist & ShouldNotExist
+		{
+			KernelArguments{
+				ShouldExist: []KernelArgument{
+					"foo",
+					"bar",
+				},
+				ShouldNotExist: []KernelArgument{
+					"baz",
+					"foo",
+				},
+			},
+			"error at $.shouldNotExist.1: duplicate entry defined\n",
+		},
+	}
+
+	for i, test := range tests {
+		r := validate.ValidateWithContext(test.in, nil)
+		if test.out != r.String() {
+			t.Errorf("#%d: bad error: want %q, got %q", i, test.out, r.String())
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/luks.go b/config/v3_5_experimental/types/luks.go
new file mode 100644
index 00000000..90d72387
--- /dev/null
+++ b/config/v3_5_experimental/types/luks.go
@@ -0,0 +1,71 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"strings"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (l Luks) Key() string {
+	return l.Name
+}
+
+func (l Luks) IgnoreDuplicates() map[string]struct{} {
+	return map[string]struct{}{
+		"Options": {},
+	}
+}
+
+func (l Luks) Validate(c path.ContextPath) (r report.Report) {
+	if strings.Contains(l.Name, "/") {
+		r.AddOnError(c.Append("name"), errors.ErrLuksNameContainsSlash)
+	}
+	r.AddOnError(c.Append("label"), l.validateLabel())
+	if util.NilOrEmpty(l.Device) {
+		r.AddOnError(c.Append("device"), errors.ErrDiskDeviceRequired)
+	} else {
+		r.AddOnError(c.Append("device"), validatePath(*l.Device))
+	}
+
+	if util.NotEmpty(l.Clevis.Custom.Pin) && (len(l.Clevis.Tang) > 0 || util.IsTrue(l.Clevis.Tpm2) || (l.Clevis.Threshold != nil && *l.Clevis.Threshold != 0)) {
+		r.AddOnError(c.Append("clevis"), errors.ErrClevisCustomWithOthers)
+	}
+
+	// fail if a key file is provided and is not valid
+	if err := validateURLNilOK(l.KeyFile.Source); err != nil {
+		r.AddOnError(c.Append("keys"), errors.ErrInvalidLuksKeyFile)
+	}
+	return
+}
+
+func (l Luks) validateLabel() error {
+	if util.NilOrEmpty(l.Label) {
+		return nil
+	}
+
+	if len(*l.Label) > 47 {
+		// LUKS2_LABEL_L has a maximum length of 48 (including the null terminator)
+		// https://gitlab.com/cryptsetup/cryptsetup/-/blob/1633f030e89ad2f11ae649ba9600997a41abd3fc/lib/luks2/luks2.h#L86
+		return errors.ErrLuksLabelTooLong
+	}
+
+	return nil
+}
diff --git a/config/v3_5_experimental/types/mode.go b/config/v3_5_experimental/types/mode.go
new file mode 100644
index 00000000..9eb7573d
--- /dev/null
+++ b/config/v3_5_experimental/types/mode.go
@@ -0,0 +1,26 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+)
+
+func validateMode(m *int) error {
+	if m != nil && (*m < 0 || *m > 07777) {
+		return errors.ErrFileIllegalMode
+	}
+	return nil
+}
diff --git a/config/v3_5_experimental/types/mode_test.go b/config/v3_5_experimental/types/mode_test.go
new file mode 100644
index 00000000..8966e25d
--- /dev/null
+++ b/config/v3_5_experimental/types/mode_test.go
@@ -0,0 +1,62 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+)
+
+func TestModeValidate(t *testing.T) {
+	tests := []struct {
+		in  *int
+		out error
+	}{
+		{
+			nil,
+			nil,
+		},
+		{
+			util.IntToPtr(0),
+			nil,
+		},
+		{
+			util.IntToPtr(0644),
+			nil,
+		},
+		{
+			util.IntToPtr(01755),
+			nil,
+		},
+		{
+			util.IntToPtr(07777),
+			nil,
+		},
+		{
+			util.IntToPtr(010000),
+			errors.ErrFileIllegalMode,
+		},
+	}
+
+	for i, test := range tests {
+		err := validateMode(test.in)
+		if !reflect.DeepEqual(test.out, err) {
+			t.Errorf("#%d: bad err: want %v, got %v", i, test.out, err)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/node.go b/config/v3_5_experimental/types/node.go
new file mode 100644
index 00000000..248276e7
--- /dev/null
+++ b/config/v3_5_experimental/types/node.go
@@ -0,0 +1,59 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	vpath "github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (n Node) Key() string {
+	return n.Path
+}
+
+func (n Node) Validate(c vpath.ContextPath) (r report.Report) {
+	r.AddOnError(c.Append("path"), validatePath(n.Path))
+	return
+}
+
+func (n Node) Depth() int {
+	count := 0
+	for p := path.Clean(string(n.Path)); p != "/"; count++ {
+		p = path.Dir(p)
+	}
+	return count
+}
+
+func validateIDorName(id *int, name *string) error {
+	if id != nil && util.NotEmpty(name) {
+		return errors.ErrBothIDAndNameSet
+	}
+	return nil
+}
+
+func (nu NodeUser) Validate(c vpath.ContextPath) (r report.Report) {
+	r.AddOnError(c, validateIDorName(nu.ID, nu.Name))
+	return
+}
+
+func (ng NodeGroup) Validate(c vpath.ContextPath) (r report.Report) {
+	r.AddOnError(c, validateIDorName(ng.ID, ng.Name))
+	return
+}
diff --git a/config/v3_5_experimental/types/node_test.go b/config/v3_5_experimental/types/node_test.go
new file mode 100644
index 00000000..20ba4eb6
--- /dev/null
+++ b/config/v3_5_experimental/types/node_test.go
@@ -0,0 +1,101 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestNodeValidatePath(t *testing.T) {
+	node := Node{Path: "not/absolute"}
+	rep := report.Report{}
+	rep.AddOnError(path.ContextPath{}.Append("path"), errors.ErrPathRelative)
+	if receivedRep := node.Validate(path.ContextPath{}); !reflect.DeepEqual(rep, receivedRep) {
+		t.Errorf("bad error: want %v, got %v", rep, receivedRep)
+	}
+}
+
+func TestNodeValidateUser(t *testing.T) {
+	tests := []struct {
+		in  NodeUser
+		out error
+	}{
+		{
+			NodeUser{util.IntToPtr(0), util.StrToPtr("")},
+			nil,
+		},
+		{
+			NodeUser{util.IntToPtr(1000), util.StrToPtr("")},
+			nil,
+		},
+		{
+			NodeUser{nil, util.StrToPtr("core")},
+			nil,
+		},
+		{
+			NodeUser{util.IntToPtr(1000), util.StrToPtr("core")},
+			errors.ErrBothIDAndNameSet,
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(path.New(""), test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v got %v", i, test.out, r)
+		}
+	}
+}
+
+func TestNodeValidateGroup(t *testing.T) {
+	tests := []struct {
+		in  NodeGroup
+		out error
+	}{
+		{
+			NodeGroup{util.IntToPtr(0), util.StrToPtr("")},
+			nil,
+		},
+		{
+			NodeGroup{util.IntToPtr(1000), util.StrToPtr("")},
+			nil,
+		},
+		{
+			NodeGroup{nil, util.StrToPtr("core")},
+			nil,
+		},
+		{
+			NodeGroup{util.IntToPtr(1000), util.StrToPtr("core")},
+			errors.ErrBothIDAndNameSet,
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(path.New(""), test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v got %v", i, test.out, r)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/partition.go b/config/v3_5_experimental/types/partition.go
new file mode 100644
index 00000000..1b2d97ed
--- /dev/null
+++ b/config/v3_5_experimental/types/partition.go
@@ -0,0 +1,91 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"regexp"
+	"strings"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+const (
+	guidRegexStr = "^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$"
+)
+
+var (
+	guidRegex = regexp.MustCompile(guidRegexStr)
+)
+
+func (p Partition) Key() string {
+	if p.Number != 0 {
+		return fmt.Sprintf("number:%d", p.Number)
+	} else if p.Label != nil {
+		return fmt.Sprintf("label:%s", *p.Label)
+	} else {
+		return ""
+	}
+}
+
+func (p Partition) Validate(c path.ContextPath) (r report.Report) {
+	if util.IsFalse(p.ShouldExist) &&
+		(p.Label != nil || util.NotEmpty(p.TypeGUID) || util.NotEmpty(p.GUID) || p.StartMiB != nil || p.SizeMiB != nil) {
+		r.AddOnError(c, errors.ErrShouldNotExistWithOthers)
+	}
+	if p.Number == 0 && p.Label == nil {
+		r.AddOnError(c, errors.ErrNeedLabelOrNumber)
+	}
+
+	r.AddOnError(c.Append("label"), p.validateLabel())
+	r.AddOnError(c.Append("guid"), validateGUID(p.GUID))
+	r.AddOnError(c.Append("typeGuid"), validateGUID(p.TypeGUID))
+	return
+}
+
+func (p Partition) validateLabel() error {
+	if p.Label == nil {
+		return nil
+	}
+	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
+	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
+
+	// XXX(vc): note GPT calls it a name, we're using label for consistency
+	// with udev naming /dev/disk/by-partlabel/*.
+	if len(*p.Label) > 36 {
+		return errors.ErrLabelTooLong
+	}
+
+	// sgdisk uses colons for delimitting compound arguments and does not allow escaping them.
+	if strings.Contains(*p.Label, ":") {
+		return errors.ErrLabelContainsColon
+	}
+	return nil
+}
+
+func validateGUID(guidPointer *string) error {
+	if guidPointer == nil {
+		return nil
+	}
+	guid := *guidPointer
+	if ok := guidRegex.MatchString(guid); !ok {
+		return errors.ErrDoesntMatchGUIDRegex
+	}
+	return nil
+}
diff --git a/config/v3_5_experimental/types/partition_test.go b/config/v3_5_experimental/types/partition_test.go
new file mode 100644
index 00000000..a1e1623f
--- /dev/null
+++ b/config/v3_5_experimental/types/partition_test.go
@@ -0,0 +1,94 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+)
+
+func TestValidateLabel(t *testing.T) {
+	tests := []struct {
+		in  *string
+		out error
+	}{
+		{
+			util.StrToPtr("root"),
+			nil,
+		},
+		{
+			util.StrToPtr(""),
+			nil,
+		},
+		{
+			nil,
+			nil,
+		},
+		{
+			util.StrToPtr("111111111111111111111111111111111111"),
+			nil,
+		},
+		{
+			util.StrToPtr("1111111111111111111111111111111111111"),
+			errors.ErrLabelTooLong,
+		},
+		{
+			util.StrToPtr("test:"),
+			errors.ErrLabelContainsColon,
+		},
+	}
+	for i, test := range tests {
+		err := Partition{Label: test.in}.validateLabel()
+		if err != test.out {
+			t.Errorf("#%d: wanted %v, got %v", i, test.out, err)
+		}
+	}
+}
+
+func TestValidateGUID(t *testing.T) {
+	tests := []struct {
+		in  *string
+		out error
+	}{
+		{
+			util.StrToPtr("5DFBF5F4-2848-4BAC-AA5E-0D9A20B745A6"),
+			nil,
+		},
+		{
+			util.StrToPtr("5dfbf5f4-2848-4bac-aa5e-0d9a20b745a6"),
+			nil,
+		},
+		{
+			util.StrToPtr(""),
+			nil,
+		},
+		{
+			nil,
+			nil,
+		},
+		{
+			util.StrToPtr("not-a-valid-typeguid"),
+			errors.ErrDoesntMatchGUIDRegex,
+		},
+	}
+	for i, test := range tests {
+		err := validateGUID(test.in)
+		if err != test.out {
+			t.Errorf("#%d: wanted %v, got %v", i, test.out, err)
+		}
+	}
+}
diff --git a/config/v3_4_experimental/types/config.go b/config/v3_5_experimental/types/passwd.go
similarity index 79%
rename from config/v3_4_experimental/types/config.go
rename to config/v3_5_experimental/types/passwd.go
index e7718193..4060a2a6 100644
--- a/config/v3_4_experimental/types/config.go
+++ b/config/v3_5_experimental/types/passwd.go
@@ -14,14 +14,10 @@
 
 package types
 
-import (
-	"github.com/coreos/go-semver/semver"
-)
+func (p PasswdUser) Key() string {
+	return p.Name
+}
 
-var (
-	MaxVersion = semver.Version{
-		Major:      3,
-		Minor:      4,
-		PreRelease: "experimental",
-	}
-)
+func (g PasswdGroup) Key() string {
+	return g.Name
+}
diff --git a/config/v3_5_experimental/types/path.go b/config/v3_5_experimental/types/path.go
new file mode 100644
index 00000000..131e300c
--- /dev/null
+++ b/config/v3_5_experimental/types/path.go
@@ -0,0 +1,42 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+)
+
+func validatePath(p string) error {
+	if p == "" {
+		return errors.ErrNoPath
+	}
+	if !path.IsAbs(p) {
+		return errors.ErrPathRelative
+	}
+	if path.Clean(p) != p {
+		return errors.ErrDirtyPath
+	}
+	return nil
+}
+
+func validatePathNilOK(p *string) error {
+	if util.NilOrEmpty(p) {
+		return nil
+	}
+	return validatePath(*p)
+}
diff --git a/config/v3_5_experimental/types/path_test.go b/config/v3_5_experimental/types/path_test.go
new file mode 100644
index 00000000..3d199cbd
--- /dev/null
+++ b/config/v3_5_experimental/types/path_test.go
@@ -0,0 +1,57 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+)
+
+func TestPathValidate(t *testing.T) {
+	tests := []struct {
+		in  string
+		out error
+	}{
+		{
+			"/good/path",
+			nil,
+		},
+		{
+			"/name",
+			nil,
+		},
+		{
+			"/this/is/a/fairly/long/path/to/a/device.",
+			nil,
+		},
+		{
+			"/this one has spaces",
+			nil,
+		},
+		{
+			"relative/path",
+			errors.ErrPathRelative,
+		},
+	}
+
+	for i, test := range tests {
+		err := validatePath(test.in)
+		if !reflect.DeepEqual(test.out, err) {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out, err)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/proxy.go b/config/v3_5_experimental/types/proxy.go
new file mode 100644
index 00000000..d48d210a
--- /dev/null
+++ b/config/v3_5_experimental/types/proxy.go
@@ -0,0 +1,49 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/url"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (p Proxy) Validate(c path.ContextPath) (r report.Report) {
+	validateProxyURL(p.HTTPProxy, c.Append("httpProxy"), &r, true)
+	validateProxyURL(p.HTTPSProxy, c.Append("httpsProxy"), &r, false)
+	return
+}
+
+func validateProxyURL(s *string, p path.ContextPath, r *report.Report, httpOk bool) {
+	if s == nil {
+		return
+	}
+	u, err := url.Parse(*s)
+	if err != nil {
+		r.AddOnError(p, errors.ErrInvalidUrl)
+		return
+	}
+
+	if u.Scheme != "https" && u.Scheme != "http" {
+		r.AddOnError(p, errors.ErrInvalidProxy)
+		return
+	}
+	if u.Scheme == "http" && !httpOk {
+		r.AddOnWarn(p, errors.ErrInsecureProxy)
+	}
+}
diff --git a/config/v3_5_experimental/types/proxy_test.go b/config/v3_5_experimental/types/proxy_test.go
new file mode 100644
index 00000000..269f4fb2
--- /dev/null
+++ b/config/v3_5_experimental/types/proxy_test.go
@@ -0,0 +1,112 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestValidateProxyURL(t *testing.T) {
+	tests := []struct {
+		in     *string
+		httpOk bool
+		out    report.Entry
+	}{
+		{
+			nil,
+			false,
+			report.Entry{},
+		},
+		{
+			nil,
+			true,
+			report.Entry{},
+		},
+		{
+			util.StrToPtr("https://example.com"),
+			false,
+			report.Entry{},
+		},
+		{
+			util.StrToPtr("https://example.com"),
+			true,
+			report.Entry{},
+		},
+		{
+			util.StrToPtr("http://example.com"),
+			false,
+			report.Entry{
+				Kind:    report.Warn,
+				Message: errors.ErrInsecureProxy.Error(),
+			},
+		},
+		{
+			util.StrToPtr("http://example.com"),
+			true,
+			report.Entry{},
+		},
+		{
+			util.StrToPtr("ftp://example.com"),
+			false,
+			report.Entry{
+				Kind:    report.Error,
+				Message: errors.ErrInvalidProxy.Error(),
+			},
+		},
+		{
+			util.StrToPtr("ftp://example.com"),
+			true,
+			report.Entry{
+				Kind:    report.Error,
+				Message: errors.ErrInvalidProxy.Error(),
+			},
+		},
+		{
+			util.StrToPtr("http://[::1]a"),
+			false,
+			report.Entry{
+				Kind:    report.Error,
+				Message: errors.ErrInvalidUrl.Error(),
+			},
+		},
+		{
+			util.StrToPtr("http://[::1]a"),
+			true,
+			report.Entry{
+				Kind:    report.Error,
+				Message: errors.ErrInvalidUrl.Error(),
+			},
+		},
+	}
+
+	for i, test := range tests {
+		r := report.Report{}
+		validateProxyURL(test.in, path.New(""), &r, test.httpOk)
+		e := report.Entry{}
+		if len(r.Entries) > 0 {
+			e = r.Entries[0]
+		}
+		if !reflect.DeepEqual(test.out, e) {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out, e)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/raid.go b/config/v3_5_experimental/types/raid.go
new file mode 100644
index 00000000..9d69aa36
--- /dev/null
+++ b/config/v3_5_experimental/types/raid.go
@@ -0,0 +1,62 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (r Raid) Key() string {
+	return r.Name
+}
+
+func (r Raid) IgnoreDuplicates() map[string]struct{} {
+	return map[string]struct{}{
+		"Options": {},
+	}
+}
+
+func (ra Raid) Validate(c path.ContextPath) (r report.Report) {
+	r.AddOnError(c.Append("level"), ra.validateLevel())
+	if len(ra.Devices) == 0 {
+		r.AddOnError(c.Append("devices"), errors.ErrRaidDevicesRequired)
+	}
+	return
+}
+
+func (r Raid) validateLevel() error {
+	if util.NilOrEmpty(r.Level) {
+		return errors.ErrRaidLevelRequired
+	}
+	switch *r.Level {
+	case "linear", "raid0", "0", "stripe":
+		if r.Spares != nil && *r.Spares != 0 {
+			return errors.ErrSparesUnsupportedForLevel
+		}
+	case "raid1", "1", "mirror":
+	case "raid4", "4":
+	case "raid5", "5":
+	case "raid6", "6":
+	case "raid10", "10":
+	default:
+		return errors.ErrUnrecognizedRaidLevel
+	}
+
+	return nil
+}
diff --git a/config/v3_5_experimental/types/raid_test.go b/config/v3_5_experimental/types/raid_test.go
new file mode 100644
index 00000000..7323b26f
--- /dev/null
+++ b/config/v3_5_experimental/types/raid_test.go
@@ -0,0 +1,88 @@
+// Copyright 2021 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestRaidValidate(t *testing.T) {
+	tests := []struct {
+		in  Raid
+		at  path.ContextPath
+		out error
+	}{
+		{
+			in: Raid{
+				Name:    "name",
+				Level:   util.StrToPtr("0"),
+				Devices: []Device{"/dev/fd0"},
+				Spares:  util.IntToPtr(0),
+			},
+			out: nil,
+		},
+		{
+			in: Raid{
+				Name:    "name",
+				Devices: []Device{"/dev/fd0"},
+			},
+			at:  path.New("", "level"),
+			out: errors.ErrRaidLevelRequired,
+		},
+		{
+			in: Raid{
+				Name:    "name",
+				Level:   util.StrToPtr("0"),
+				Devices: []Device{"/dev/fd0"},
+				Spares:  util.IntToPtr(1),
+			},
+			at:  path.New("", "level"),
+			out: errors.ErrSparesUnsupportedForLevel,
+		},
+		{
+			in: Raid{
+				Name:    "name",
+				Devices: []Device{"/dev/fd0"},
+				Level:   util.StrToPtr("zzz"),
+			},
+			at:  path.New("", "level"),
+			out: errors.ErrUnrecognizedRaidLevel,
+		},
+		{
+			in: Raid{
+				Name:  "name",
+				Level: util.StrToPtr("0"),
+			},
+			at:  path.New("", "devices"),
+			out: errors.ErrRaidDevicesRequired,
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/resource.go b/config/v3_5_experimental/types/resource.go
new file mode 100644
index 00000000..68da6c7b
--- /dev/null
+++ b/config/v3_5_experimental/types/resource.go
@@ -0,0 +1,91 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/url"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (res Resource) Key() string {
+	if res.Source == nil {
+		return ""
+	}
+	return *res.Source
+}
+
+func (res Resource) Validate(c path.ContextPath) (r report.Report) {
+	r.AddOnError(c.Append("compression"), res.validateCompression())
+	r.AddOnError(c.Append("verification", "hash"), res.validateVerification())
+	r.AddOnError(c.Append("source"), validateURLNilOK(res.Source))
+	r.AddOnError(c.Append("httpHeaders"), res.validateSchemeForHTTPHeaders())
+	return
+}
+
+func (res Resource) validateCompression() error {
+	if res.Compression != nil {
+		switch *res.Compression {
+		case "", "gzip":
+		default:
+			return errors.ErrCompressionInvalid
+		}
+	}
+	return nil
+}
+
+func (res Resource) validateVerification() error {
+	if res.Verification.Hash != nil && res.Source == nil {
+		return errors.ErrVerificationAndNilSource
+	}
+	return nil
+}
+
+func (res Resource) validateSchemeForHTTPHeaders() error {
+	if len(res.HTTPHeaders) < 1 {
+		return nil
+	}
+
+	if util.NilOrEmpty(res.Source) {
+		return errors.ErrInvalidUrl
+	}
+
+	u, err := url.Parse(*res.Source)
+	if err != nil {
+		return errors.ErrInvalidUrl
+	}
+
+	switch u.Scheme {
+	case "http", "https":
+		return nil
+	default:
+		return errors.ErrUnsupportedSchemeForHTTPHeaders
+	}
+}
+
+// Ensure that the Source is specified and valid.  This is not called by
+// Resource.Validate() because some structs that embed Resource don't
+// require Source to be specified.  Containing structs that require Source
+// should call this function from their Validate().
+func (res Resource) validateRequiredSource() error {
+	if util.NilOrEmpty(res.Source) {
+		return errors.ErrSourceRequired
+	}
+	return validateURL(*res.Source)
+}
diff --git a/config/v3_4_experimental/types/schema.go b/config/v3_5_experimental/types/schema.go
similarity index 89%
rename from config/v3_4_experimental/types/schema.go
rename to config/v3_5_experimental/types/schema.go
index ca25b99e..27fe5b5b 100644
--- a/config/v3_4_experimental/types/schema.go
+++ b/config/v3_5_experimental/types/schema.go
@@ -1,6 +1,6 @@
 package types
 
-// generated by "schematyper --package=types config/v3_4_experimental/schema/ignition.json -o config/v3_4_experimental/types/schema.go --root-type=Config" -- DO NOT EDIT
+// generated by "schematyper --package=types config/v3_5_experimental/schema/ignition.json -o config/v3_5_experimental/types/schema.go --root-type=Config" -- DO NOT EDIT
 
 type Clevis struct {
 	Custom    ClevisCustom `json:"custom,omitempty"`
@@ -109,14 +109,16 @@ type LinkEmbedded1 struct {
 }
 
 type Luks struct {
-	Clevis     Clevis       `json:"clevis,omitempty"`
-	Device     *string      `json:"device,omitempty"`
-	KeyFile    Resource     `json:"keyFile,omitempty"`
-	Label      *string      `json:"label,omitempty"`
-	Name       string       `json:"name"`
-	Options    []LuksOption `json:"options,omitempty"`
-	UUID       *string      `json:"uuid,omitempty"`
-	WipeVolume *bool        `json:"wipeVolume,omitempty"`
+	Clevis      Clevis       `json:"clevis,omitempty"`
+	Device      *string      `json:"device,omitempty"`
+	Discard     *bool        `json:"discard,omitempty"`
+	KeyFile     Resource     `json:"keyFile,omitempty"`
+	Label       *string      `json:"label,omitempty"`
+	Name        string       `json:"name"`
+	OpenOptions []OpenOption `json:"openOptions,omitempty"`
+	Options     []LuksOption `json:"options,omitempty"`
+	UUID        *string      `json:"uuid,omitempty"`
+	WipeVolume  *bool        `json:"wipeVolume,omitempty"`
 }
 
 type LuksOption string
@@ -142,6 +144,8 @@ type NodeUser struct {
 	Name *string `json:"name,omitempty"`
 }
 
+type OpenOption string
+
 type Partition struct {
 	GUID               *string `json:"guid,omitempty"`
 	Label              *string `json:"label,omitempty"`
@@ -232,8 +236,9 @@ type TLS struct {
 }
 
 type Tang struct {
-	Thumbprint *string `json:"thumbprint,omitempty"`
-	URL        string  `json:"url,omitempty"`
+	Advertisement *string `json:"advertisement,omitempty"`
+	Thumbprint    *string `json:"thumbprint,omitempty"`
+	URL           string  `json:"url,omitempty"`
 }
 
 type Timeouts struct {
diff --git a/config/v3_5_experimental/types/storage.go b/config/v3_5_experimental/types/storage.go
new file mode 100644
index 00000000..20cb7304
--- /dev/null
+++ b/config/v3_5_experimental/types/storage.go
@@ -0,0 +1,115 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+	"strings"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	vpath "github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (s Storage) MergedKeys() map[string]string {
+	return map[string]string{
+		"Directories": "Node",
+		"Files":       "Node",
+		"Links":       "Node",
+	}
+}
+
+func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
+	s.validateDirectories(c, &r)
+	s.validateFiles(c, &r)
+	s.validateLinks(c, &r)
+	s.validateFilesystems(c, &r)
+	return
+}
+
+func (s Storage) validateDirectories(c vpath.ContextPath, r *report.Report) {
+	for i, d := range s.Directories {
+		for _, l := range s.Links {
+			if strings.HasPrefix(d.Path, l.Path+"/") {
+				r.AddOnError(c.Append("directories", i), errors.ErrDirectoryUsedSymlink)
+			}
+		}
+	}
+}
+
+func (s Storage) validateFiles(c vpath.ContextPath, r *report.Report) {
+	for i, f := range s.Files {
+		for _, l := range s.Links {
+			if strings.HasPrefix(f.Path, l.Path+"/") {
+				r.AddOnError(c.Append("files", i), errors.ErrFileUsedSymlink)
+			}
+		}
+	}
+}
+
+func (s Storage) validateLinks(c vpath.ContextPath, r *report.Report) {
+	for i, l1 := range s.Links {
+		for _, l2 := range s.Links {
+			if strings.HasPrefix(l1.Path, l2.Path+"/") {
+				r.AddOnError(c.Append("links", i), errors.ErrLinkUsedSymlink)
+			}
+		}
+		if util.NilOrEmpty(l1.Target) {
+			r.AddOnError(c.Append("links", i, "target"), errors.ErrLinkTargetRequired)
+			continue
+		}
+		if !util.IsTrue(l1.Hard) {
+			continue
+		}
+		target := path.Clean(*l1.Target)
+		if !path.IsAbs(target) {
+			target = path.Join(l1.Path, *l1.Target)
+		}
+		for _, d := range s.Directories {
+			if target == d.Path {
+				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
+			}
+		}
+		ownerCheck := func(ok bool, path vpath.ContextPath) {
+			if !ok {
+				r.AddOnWarn(path, errors.ErrHardLinkSpecifiesOwner)
+			}
+		}
+		ownerCheck(l1.User.ID == nil, c.Append("links", i, "user", "id"))
+		ownerCheck(l1.User.Name == nil, c.Append("links", i, "user", "name"))
+		ownerCheck(l1.Group.ID == nil, c.Append("links", i, "group", "id"))
+		ownerCheck(l1.Group.Name == nil, c.Append("links", i, "group", "name"))
+	}
+}
+
+func (s Storage) validateFilesystems(c vpath.ContextPath, r *report.Report) {
+	disks := make(map[string]Disk)
+	for _, d := range s.Disks {
+		disks[d.Device] = d
+	}
+
+	for i, f := range s.Filesystems {
+		disk, exist := disks[f.Device]
+		if exist {
+			if len(disk.Partitions) > 0 {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrPartitionsOverwritten)
+			} else if !util.IsTrue(f.WipeFilesystem) && util.IsTrue(disk.WipeTable) {
+				r.AddOnWarn(c.Append("filesystems", i, "device"), errors.ErrFilesystemImplicitWipe)
+			}
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/storage_test.go b/config/v3_5_experimental/types/storage_test.go
new file mode 100644
index 00000000..551688a2
--- /dev/null
+++ b/config/v3_5_experimental/types/storage_test.go
@@ -0,0 +1,359 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestStorageValidateErrors(t *testing.T) {
+	tests := []struct {
+		in   Storage
+		at   path.ContextPath
+		err  error
+		warn error
+	}{
+		// test empty storage config returns nil
+		{
+			in: Storage{},
+		},
+		// test a storage config with no conflicting paths returns nil
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+					{
+						Node:          Node{Path: "/quux"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/quux-t")},
+					},
+				},
+				Files: []File{
+					{
+						Node: Node{Path: "/bar"},
+					},
+				},
+				Directories: []Directory{
+					{
+						Node: Node{Path: "/baz"},
+					},
+				},
+			},
+		},
+		// test when a file uses a configured symlink path returns ErrFileUsedSymlink
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+				},
+				Files: []File{
+					{
+						Node: Node{Path: "/foo/bar"},
+					},
+				},
+			},
+			err: errors.ErrFileUsedSymlink,
+			at:  path.New("", "files", 0),
+		},
+		// test when a directory uses a configured symlink path returns ErrDirectoryUsedSymlink
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+				},
+				Directories: []Directory{
+					{
+						Node: Node{Path: "/foo/bar"},
+					},
+				},
+			},
+			err: errors.ErrDirectoryUsedSymlink,
+			at:  path.New("", "directories", 0),
+		},
+		// test the same path listed for two separate symlinks returns ErrLinkUsedSymlink
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+					{
+						Node:          Node{Path: "/foo/bar"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-bar-t")},
+					},
+				},
+			},
+			err: errors.ErrLinkUsedSymlink,
+			at:  path.New("", "links", 1),
+		},
+		// test a configured symlink with no target returns ErrLinkTargetRequired
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Hard: util.BoolToPtr(true)},
+					},
+				},
+			},
+			err: errors.ErrLinkTargetRequired,
+			at:  path.New("", "links", 0, "target"),
+		},
+		// test a configured symlink with a nil target returns ErrLinkTargetRequired
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("")},
+					},
+				},
+			},
+			err: errors.ErrLinkTargetRequired,
+			at:  path.New("", "links", 0, "target"),
+		},
+		// test that two symlinks can be configured at a time
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node:          Node{Path: "/foo"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foo-t")},
+					},
+					{
+						Node:          Node{Path: "/foob/bar"},
+						LinkEmbedded1: LinkEmbedded1{Target: util.StrToPtr("/foob-bar-t")},
+					},
+				},
+			},
+		},
+		// test when a directory uses a configured symlink with the 'Hard:= true' returns ErrHardLinkToDirectory
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{Path: "/quux"},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+				Directories: []Directory{
+					{
+						Node: Node{Path: "/foo/bar"},
+					},
+				},
+			},
+			err: errors.ErrHardLinkToDirectory,
+			at:  path.New("", "links", 0),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							User: NodeUser{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "user", "name"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								ID: util.IntToPtr(10),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "id"),
+		},
+		{
+			in: Storage{
+				Links: []Link{
+					{
+						Node: Node{
+							Path: "/quux",
+							Group: NodeGroup{
+								Name: util.StrToPtr("bovik"),
+							},
+						},
+						LinkEmbedded1: LinkEmbedded1{
+							Target: util.StrToPtr("/foo/bar"),
+							Hard:   util.BoolToPtr(true),
+						},
+					},
+				},
+			},
+			warn: errors.ErrHardLinkSpecifiesOwner,
+			at:   path.New("", "links", 0, "group", "name"),
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.err)
+		expected.AddOnWarn(test.at, test.warn)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
+
+func TestStorageValidateWarnings(t *testing.T) {
+	tests := []struct {
+		in  Storage
+		at  path.ContextPath
+		out error
+	}{
+		// test a disk with partitions with the same 'device' as a filesystem returns ErrPartitionsOverwritten
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sda",
+						Partitions: []Partition{
+							{}, {},
+						},
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrPartitionsOverwritten,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=true' as a configured filesystem returns ErrFilesystemImplicitWipe
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(true),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: errors.ErrFilesystemImplicitWipe,
+			at:  path.New("", "filesystems", 0, "device"),
+		},
+		// test a disk with the same 'device' and 'WipeTable:=false' as a configured filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device:    "/dev/sda",
+						WipeTable: util.BoolToPtr(false),
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sda",
+					},
+				},
+			},
+			out: nil,
+		},
+		// test a disk with no partitions with the same 'device' as a filesystem returns nil
+		{
+			in: Storage{
+				Disks: []Disk{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+				Filesystems: []Filesystem{
+					{
+						Device: "/dev/sdb",
+					},
+				},
+			},
+			out: nil,
+		},
+	}
+
+	for i, test := range tests {
+		r := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnWarn(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad report: want %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/systemd.go b/config/v3_5_experimental/types/systemd.go
new file mode 100644
index 00000000..ac521ba7
--- /dev/null
+++ b/config/v3_5_experimental/types/systemd.go
@@ -0,0 +1,61 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"regexp"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
+	"github.com/coreos/ignition/v2/config/util"
+
+	vpath "github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (s Systemd) Validate(c vpath.ContextPath) (r report.Report) {
+	units := make(map[string]Unit)
+	checkInstanceUnit := regexp.MustCompile(`^(.+?)@(.+?)\.service$`)
+	for _, d := range s.Units {
+		units[d.Name] = d
+	}
+	for index, unit := range s.Units {
+		if checkInstanceUnit.MatchString(unit.Name) && util.IsTrue(unit.Enabled) {
+			instUnitSlice := checkInstanceUnit.FindSubmatch([]byte(unit.Name))
+			instantiableUnit := string(instUnitSlice[1]) + "@.service"
+			if _, ok := units[instantiableUnit]; ok && util.NotEmpty(units[instantiableUnit].Contents) {
+				foundInstallSection := false
+				// we're doing a separate validation pass on each unit to identify
+				// if an instantiable unit has the install section. So logging an
+				// `AddOnError` will produce duplicate errors on bad unit contents
+				// because we're already doing that while validating a unit separately.
+				opts, err := parse.ParseUnitContents(units[instantiableUnit].Contents)
+				if err != nil {
+					continue
+				}
+				for _, section := range opts {
+					if section.Section == "Install" {
+						foundInstallSection = true
+						break
+					}
+				}
+				if !foundInstallSection {
+					r.AddOnWarn(c.Append("units", index, "contents"), errors.NewNoInstallSectionForInstantiableUnitError(instantiableUnit, unit.Name))
+				}
+			}
+		}
+	}
+	return
+}
diff --git a/config/v3_5_experimental/types/systemd_test.go b/config/v3_5_experimental/types/systemd_test.go
new file mode 100644
index 00000000..798eb10f
--- /dev/null
+++ b/config/v3_5_experimental/types/systemd_test.go
@@ -0,0 +1,105 @@
+// Copyright 2022 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+	"github.com/stretchr/testify/assert"
+)
+
+func TestSystemdValidate(t *testing.T) {
+	tests := []struct {
+		in  Systemd
+		out error
+	}{
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			errors.NewNoInstallSectionForInstantiableUnitError("test@.service", "test@foo.service"),
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+					{Name: "test@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(false)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test2@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service", Contents: util.StrToPtr("[Unit]\nDescription=echo service template\n[Service]\nType=oneshot\nExecStart=/bin/echo %i\n[Install]\nWantedBy=multi-user.target\n")},
+					{Name: "test2@foo.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+		{
+			Systemd{
+				[]Unit{
+					{Name: "test@.service"},
+					{Name: "test@bar.service", Enabled: util.BoolToPtr(true)},
+				},
+			},
+			nil,
+		},
+	}
+
+	for i, test := range tests {
+		t.Run(fmt.Sprintf("validate %d", i), func(t *testing.T) {
+			actual := test.in.Validate(path.ContextPath{})
+			expected := report.Report{}
+			expected.AddOnWarn(path.ContextPath{}.Append("units", 1, "contents"), test.out)
+			assert.Equal(t, expected, actual, "bad report")
+		})
+	}
+}
diff --git a/config/v3_5_experimental/types/tang.go b/config/v3_5_experimental/types/tang.go
new file mode 100644
index 00000000..1839d6cc
--- /dev/null
+++ b/config/v3_5_experimental/types/tang.go
@@ -0,0 +1,65 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"encoding/json"
+	"net/url"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (t Tang) Key() string {
+	return t.URL
+}
+
+func (t Tang) Validate(c path.ContextPath) (r report.Report) {
+	r.AddOnError(c.Append("url"), validateTangURL(t.URL))
+	if util.NilOrEmpty(t.Thumbprint) {
+		r.AddOnError(c.Append("thumbprint"), errors.ErrTangThumbprintRequired)
+	}
+	r.AddOnError(c.Append("advertisement"), validateTangAdvertisement(t.Advertisement))
+	return
+}
+
+func validateTangURL(s string) error {
+	u, err := url.Parse(s)
+	if err != nil {
+		return errors.ErrInvalidUrl
+	}
+
+	switch u.Scheme {
+	case "http", "https":
+		return nil
+	default:
+		return errors.ErrInvalidScheme
+	}
+}
+
+func validateTangAdvertisement(s *string) error {
+	if util.NotEmpty(s) {
+		var adv any
+		err := json.Unmarshal([]byte(*s), &adv)
+		if err != nil {
+			return errors.ErrInvalidTangAdvertisement
+		}
+	}
+
+	return nil
+}
diff --git a/config/v3_5_experimental/types/tang_test.go b/config/v3_5_experimental/types/tang_test.go
new file mode 100644
index 00000000..fb57b1e4
--- /dev/null
+++ b/config/v3_5_experimental/types/tang_test.go
@@ -0,0 +1,104 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestTangValidation(t *testing.T) {
+	tests := []struct {
+		in  Tang
+		out error
+		at  path.ContextPath
+	}{
+		// happy path with no advertisement and healthy url
+		{
+			in: Tang{
+				URL:        "http://example.com",
+				Thumbprint: util.StrToPtr("abc"),
+			},
+			out: nil,
+		},
+		// test 1: invalid url scheme
+		{
+			in: Tang{
+				URL:        "httasfdsafadsf",
+				Thumbprint: util.StrToPtr("abc"),
+			},
+			out: errors.ErrInvalidScheme,
+			at:  path.New("foo", "url"),
+		},
+		// null url
+		{
+			in: Tang{
+				Thumbprint: util.StrToPtr("abc"),
+			},
+			out: errors.ErrInvalidScheme,
+			at:  path.New("foo", "url"),
+		},
+		// null thumbprint
+		{
+			in: Tang{
+				URL:        "http://example.com",
+				Thumbprint: nil,
+			},
+			out: errors.ErrTangThumbprintRequired,
+			at:  path.New("foo", "thumbprint"),
+		},
+		// Advertisement is valid json
+		{
+			in: Tang{
+				URL:           "http://example.com",
+				Thumbprint:    util.StrToPtr("abc"),
+				Advertisement: util.StrToPtr("{\"payload\": \"eyJrZXlzIjogW3siYWxnIjogIkVTNTEyIiwgImt0eSI6ICJFQyIsICJjcnYiOiAiUC01MjEiLCAieCI6ICJBRGFNajJmazNob21CWTF5WElSQ21uRk92cmUzOFZjdHMwTnNHeDZ6RWNxdEVXcjh5ekhUMkhfa2hjNGpSa19FQWFLdjNrd2RjZ05sOTBLcGhfMGYyQ190IiwgInkiOiAiQUZ2d1UyeGJ5T1RydWo0V1NtcVlqN2wtcUVTZmhWakdCNTI1Q2d6d0NoZUZRRTBvb1o3STYyamt3NkRKQ05yS3VPUDRsSEhicm8tYXhoUk9MSXNJVExvNCIsICJrZXlfb3BzIjogWyJ2ZXJpZnkiXX0sIHsiYWxnIjogIkVDTVIiLCAia3R5IjogIkVDIiwgImNydiI6ICJQLTUyMSIsICJ4IjogIkFOZDVYcTFvZklUbTdNWG16OUY0VVRSYmRNZFNIMl9XNXczTDVWZ0w3b3hwdmpyM0hkLXNLNUVqd3A1V2swMnJMb3NXVUJjYkZyZEhjZFJTTVJoZlVFTFIiLCAieSI6ICJBRVVaVlVZWkFBY2hVcmdoX3poaTV3SUUzeTEycGwzeWhqUk5LcGpSdW9tUFhKaDhRaFhXRmRWZEtMUlEwX1lwUjNOMjNSUk1pU1lvWlg0Qm42QnlrQVBMIiwgImtleV9vcHMiOiBbImRlcml2ZUtleSJdfV19\", \"protected\": \"eyJhbGciOiJFUzUxMiIsImN0eSI6Imp3ay1zZXQranNvbiJ9\", \"signature\": \"APHfSyVzLwELwG0pMJyIP74gWvhHUvDtv0SESBxA2uOdSXq76IdWHW2xvCZDdlNan8pnqUvEedPZjf_vdKBw9MTXAPMkRxVnu64HepKwlrzzm_zG2R4CHpoCOsGgjH9-acYxg-Vha63oMojv3_bV0VHg-NbzNLaxietgYplstvcNIwkv\"}"),
+			},
+			out: nil,
+		},
+		// Advertisement is empty string
+		{
+			in: Tang{
+				URL:           "http://example.com",
+				Thumbprint:    util.StrToPtr("abc"),
+				Advertisement: util.StrToPtr(""),
+			},
+			out: nil,
+		},
+		// Advertisement is not valid json
+		{
+			in: Tang{
+				URL:           "http://example.com",
+				Thumbprint:    util.StrToPtr("abc"),
+				Advertisement: util.StrToPtr("{{"),
+			},
+			out: errors.ErrInvalidTangAdvertisement,
+			at:  path.New("foo", "advertisement"),
+		},
+	}
+	for i, test := range tests {
+		r := test.in.Validate(path.New("foo"))
+		expected := report.Report{}
+		expected.AddOnError(test.at, test.out)
+		if !reflect.DeepEqual(expected, r) {
+			t.Errorf("#%d: bad error: expected : %v, got %v", i, expected, r)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/tls.go b/config/v3_5_experimental/types/tls.go
new file mode 100644
index 00000000..8890e397
--- /dev/null
+++ b/config/v3_5_experimental/types/tls.go
@@ -0,0 +1,27 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (tls TLS) Validate(c path.ContextPath) (r report.Report) {
+	for i, ca := range tls.CertificateAuthorities {
+		r.AddOnError(c.Append("certificateAuthorities", i), ca.validateRequiredSource())
+	}
+	return
+}
diff --git a/config/v3_5_experimental/types/tls_test.go b/config/v3_5_experimental/types/tls_test.go
new file mode 100644
index 00000000..8f3b2e35
--- /dev/null
+++ b/config/v3_5_experimental/types/tls_test.go
@@ -0,0 +1,42 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"testing"
+
+	"github.com/coreos/vcontext/validate"
+)
+
+func TestTLSValidate(t *testing.T) {
+	tests := []struct {
+		in  TLS
+		out string
+	}{
+		{
+			TLS{
+				CertificateAuthorities: []Resource{{}},
+			},
+			"error at $.certificateAuthorities.0: source is required\n",
+		},
+	}
+
+	for i, test := range tests {
+		r := validate.Validate(test.in, "test")
+		if test.out != r.String() {
+			t.Errorf("#%d: bad error: want %q, got %q", i, test.out, r.String())
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/unit.go b/config/v3_5_experimental/types/unit.go
new file mode 100644
index 00000000..c5ee1e8e
--- /dev/null
+++ b/config/v3_5_experimental/types/unit.go
@@ -0,0 +1,68 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"path"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/shared/parse"
+	"github.com/coreos/ignition/v2/config/shared/validations"
+	"github.com/coreos/ignition/v2/config/util"
+
+	cpath "github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func (u Unit) Key() string {
+	return u.Name
+}
+
+func (d Dropin) Key() string {
+	return d.Name
+}
+
+func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
+	r.AddOnError(c.Append("name"), validateName(u.Name))
+	c = c.Append("contents")
+	opts, err := parse.ParseUnitContents(u.Contents)
+	r.AddOnError(c, err)
+
+	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, util.IsTrue(u.Enabled), util.NilOrEmpty(u.Contents), opts))
+
+	return
+}
+
+func validateName(name string) error {
+	switch path.Ext(name) {
+	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
+	default:
+		return errors.ErrInvalidSystemdExt
+	}
+	return nil
+}
+
+func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
+	_, err := parse.ParseUnitContents(d.Contents)
+	r.AddOnError(c.Append("contents"), err)
+
+	switch path.Ext(d.Name) {
+	case ".conf":
+	default:
+		r.AddOnError(c.Append("name"), errors.ErrInvalidSystemdDropinExt)
+	}
+
+	return
+}
diff --git a/config/v3_5_experimental/types/unit_test.go b/config/v3_5_experimental/types/unit_test.go
new file mode 100644
index 00000000..3dc90540
--- /dev/null
+++ b/config/v3_5_experimental/types/unit_test.go
@@ -0,0 +1,108 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"fmt"
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestSystemdUnitValidateContents(t *testing.T) {
+	tests := []struct {
+		in  Unit
+		out error
+	}{
+		{
+			Unit{Name: "test.service", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+			nil,
+		},
+		{
+			Unit{Name: "test.service", Contents: util.StrToPtr("[Foo")},
+			fmt.Errorf("invalid unit content: unable to find end of section"),
+		},
+		{
+			Unit{Name: "test.service", Contents: util.StrToPtr(""), Dropins: []Dropin{{}}},
+			nil,
+		},
+	}
+
+	for i, test := range tests {
+		err := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(path.New("", "contents"), test.out)
+		if !reflect.DeepEqual(expected, err) {
+			t.Errorf("#%d: bad error: want %v, got %v", i, expected, err)
+		}
+	}
+}
+
+func TestSystemdUnitValidateName(t *testing.T) {
+	tests := []struct {
+		in  string
+		out error
+	}{
+		{
+			"test.service",
+			nil,
+		},
+		{
+			"test.socket",
+			nil,
+		},
+		{
+			"test.blah",
+			errors.ErrInvalidSystemdExt,
+		},
+	}
+
+	for i, test := range tests {
+		err := validateName(test.in)
+		if test.out != err {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out, err)
+		}
+	}
+}
+
+func TestSystemdUnitDropInValidate(t *testing.T) {
+	tests := []struct {
+		in  Dropin
+		out error
+	}{
+		{
+			Dropin{Name: "test.conf", Contents: util.StrToPtr("[Foo]\nQux=Bar")},
+			nil,
+		},
+		{
+			Dropin{Name: "test.conf", Contents: util.StrToPtr("[Foo")},
+			fmt.Errorf("invalid unit content: unable to find end of section"),
+		},
+	}
+
+	for i, test := range tests {
+		err := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(path.New("", "contents"), test.out)
+		if !reflect.DeepEqual(expected, err) {
+			t.Errorf("#%d: bad error: want %v, got %v", i, expected, err)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/url.go b/config/v3_5_experimental/types/url.go
new file mode 100644
index 00000000..3ca189da
--- /dev/null
+++ b/config/v3_5_experimental/types/url.go
@@ -0,0 +1,83 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"net/url"
+	"strings"
+
+	"github.com/aws/aws-sdk-go/aws/arn"
+	"github.com/vincent-petithory/dataurl"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+)
+
+func validateURL(s string) error {
+	u, err := url.Parse(s)
+	if err != nil {
+		return errors.ErrInvalidUrl
+	}
+
+	switch u.Scheme {
+	case "http", "https", "tftp", "gs":
+		return nil
+	case "s3":
+		if v, ok := u.Query()["versionId"]; ok {
+			if len(v) == 0 || v[0] == "" {
+				return errors.ErrInvalidS3ObjectVersionId
+			}
+		}
+		return nil
+	case "arn":
+		fullURL := u.Scheme + ":" + u.Opaque
+		if !arn.IsARN(fullURL) {
+			return errors.ErrInvalidS3ARN
+		}
+		s3arn, err := arn.Parse(fullURL)
+		if err != nil {
+			return err
+		}
+		if s3arn.Service != "s3" {
+			return errors.ErrInvalidS3ARN
+		}
+		urlSplit := strings.Split(fullURL, "/")
+		if strings.HasPrefix(s3arn.Resource, "accesspoint/") && len(urlSplit) < 3 {
+			return errors.ErrInvalidS3ARN
+		} else if len(urlSplit) < 2 {
+			return errors.ErrInvalidS3ARN
+		}
+		if v, ok := u.Query()["versionId"]; ok {
+			if len(v) == 0 || v[0] == "" {
+				return errors.ErrInvalidS3ObjectVersionId
+			}
+		}
+		return nil
+	case "data":
+		if _, err := dataurl.DecodeString(s); err != nil {
+			return err
+		}
+		return nil
+	default:
+		return errors.ErrInvalidScheme
+	}
+}
+
+func validateURLNilOK(s *string) error {
+	if util.NilOrEmpty(s) {
+		return nil
+	}
+	return validateURL(*s)
+}
diff --git a/config/v3_5_experimental/types/url_test.go b/config/v3_5_experimental/types/url_test.go
new file mode 100644
index 00000000..1901b7af
--- /dev/null
+++ b/config/v3_5_experimental/types/url_test.go
@@ -0,0 +1,137 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/util"
+)
+
+func TestURLValidate(t *testing.T) {
+	tests := []struct {
+		in  *string
+		out error
+	}{
+		{
+			nil,
+			nil,
+		},
+		{
+			util.StrToPtr(""),
+			nil,
+		},
+		{
+			util.StrToPtr("http://example.com"),
+			nil,
+		},
+		{
+			util.StrToPtr("https://example.com"),
+			nil,
+		},
+		{
+			util.StrToPtr("tftp://example.com:69/foobar.txt"),
+			nil,
+		},
+		{
+			util.StrToPtr("data:,example%20file%0A"),
+			nil,
+		},
+		{
+			util.StrToPtr("bad://"),
+			errors.ErrInvalidScheme,
+		},
+		{
+			util.StrToPtr("s3://bucket/key"),
+			nil,
+		},
+		{
+			util.StrToPtr("s3://bucket/key?versionId="),
+			errors.ErrInvalidS3ObjectVersionId,
+		},
+		{
+			util.StrToPtr("s3://bucket/key?versionId=aVersionHash"),
+			nil,
+		},
+		{
+			util.StrToPtr("Arn:"),
+			errors.ErrInvalidS3ARN,
+		},
+		{
+			util.StrToPtr("arn:aws:iam:us-west-2:123456789012:resource"),
+			errors.ErrInvalidS3ARN,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:::bucket-name-but-no-key"),
+			errors.ErrInvalidS3ARN,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:us-west-2:123456789012:accesspoint"),
+			errors.ErrInvalidS3ARN,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:us-west-2:123456789012:accesspoint/"),
+			errors.ErrInvalidS3ARN,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:us-west-2:123456789012:accesspoint/accesspoint-name-but-no-bucket"),
+			errors.ErrInvalidS3ARN,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:us-west-2:123456789012:bucket-name/object-key"),
+			nil,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:us-west-2:123456789012:bucket-name/object-key?versionId=aVersionHash"),
+			nil,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:us-west-2:123456789012:accesspoint/accesspoint-name/object"),
+			nil,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:us-west-2:123456789012:accesspoint/accesspoint-name/some/nested/object"),
+			nil,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:us-west-2:123456789012:accesspoint/accesspoint-name/object?versionId=aVersionHash"),
+			nil,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:::bucket-name/object-key"),
+			nil,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:::bucket-name/some/nested/object"),
+			nil,
+		},
+		{
+			util.StrToPtr("arn:aws:s3:::bucket-name/object-key?versionId=aVersionHash"),
+			nil,
+		},
+		{
+			util.StrToPtr("gs://bucket/object"),
+			nil,
+		},
+	}
+
+	for i, test := range tests {
+		err := validateURLNilOK(test.in)
+		if test.out != err {
+			t.Errorf("#%d: bad error: want %v, got %v", i, test.out, err)
+		}
+	}
+}
diff --git a/config/v3_5_experimental/types/verification.go b/config/v3_5_experimental/types/verification.go
new file mode 100644
index 00000000..5def6f04
--- /dev/null
+++ b/config/v3_5_experimental/types/verification.go
@@ -0,0 +1,71 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"crypto"
+	"encoding/hex"
+	"strings"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+// HashParts will return the sum and function (in that order) of the hash stored
+// in this Verification, or an error if there is an issue during parsing.
+func (v Verification) HashParts() (string, string, error) {
+	if v.Hash == nil {
+		// The hash can be nil
+		return "", "", nil
+	}
+	parts := strings.SplitN(*v.Hash, "-", 2)
+	if len(parts) != 2 {
+		return "", "", errors.ErrHashMalformed
+	}
+
+	return parts[0], parts[1], nil
+}
+
+func (v Verification) Validate(c path.ContextPath) (r report.Report) {
+	c = c.Append("hash")
+	if v.Hash == nil {
+		// The hash can be nil
+		return
+	}
+
+	function, sum, err := v.HashParts()
+	if err != nil {
+		r.AddOnError(c, err)
+		return
+	}
+	var hash crypto.Hash
+	switch function {
+	case "sha512":
+		hash = crypto.SHA512
+	case "sha256":
+		hash = crypto.SHA256
+	default:
+		r.AddOnError(c, errors.ErrHashUnrecognized)
+		return
+	}
+
+	if len(sum) != hex.EncodedLen(hash.Size()) {
+		r.AddOnError(c, errors.ErrHashWrongSize)
+	}
+
+	return
+}
diff --git a/config/v3_5_experimental/types/verification_test.go b/config/v3_5_experimental/types/verification_test.go
new file mode 100644
index 00000000..9a0914d0
--- /dev/null
+++ b/config/v3_5_experimental/types/verification_test.go
@@ -0,0 +1,102 @@
+// Copyright 2020 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package types
+
+import (
+	"reflect"
+	"testing"
+
+	"github.com/coreos/ignition/v2/config/shared/errors"
+
+	"github.com/coreos/vcontext/path"
+	"github.com/coreos/vcontext/report"
+)
+
+func TestHashParts(t *testing.T) {
+	tests := []struct {
+		in  string
+		out error
+	}{
+		{
+			`"sha512-0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"`,
+			nil,
+		},
+		{
+			`"sha256-0519a9826023338828942b081814355d55301b9bc82042390f9afaf75cd3a707"`,
+			nil,
+		},
+		{
+			`"sha512:01234567"`,
+			errors.ErrHashMalformed,
+		},
+		{
+			`"sha256:12345678"`,
+			errors.ErrHashMalformed,
+		},
+	}
+
+	for i, test := range tests {
+		fun, sum, err := Verification{Hash: &test.in}.HashParts()
+		if err != test.out {
+			t.Fatalf("#%d: bad error: want %+v, got %+v", i, test.out, err)
+		}
+		if err == nil && fun+"-"+sum != test.in {
+			t.Fatalf("#%d: bad hash: want %+v, got %+v", i, test.in, fun+"-"+sum)
+		}
+	}
+}
+
+func TestHashValidate(t *testing.T) {
+	h1 := "xor-abcdef"
+	h2 := "sha512-123"
+	h3 := "sha512-0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
+	h4 := "sha256-0519a9826023338828942b081814355d55301b9bc82042390f9afaf75cd3a707"
+	h5 := "sha256-345"
+
+	tests := []struct {
+		in  Verification
+		out error
+	}{
+		{
+			Verification{Hash: &h1},
+			errors.ErrHashUnrecognized,
+		},
+		{
+			Verification{Hash: &h2},
+			errors.ErrHashWrongSize,
+		},
+		{
+			Verification{Hash: &h3},
+			nil,
+		},
+		{
+			Verification{Hash: &h4},
+			nil,
+		},
+		{
+			Verification{Hash: &h5},
+			errors.ErrHashWrongSize,
+		},
+	}
+
+	for i, test := range tests {
+		err := test.in.Validate(path.ContextPath{})
+		expected := report.Report{}
+		expected.AddOnError(path.New("", "hash"), test.out)
+		if !reflect.DeepEqual(expected, err) {
+			t.Errorf("#%d: bad error: want %v, got %v", i, expected, err)
+		}
+	}
+}
diff --git a/docs/_config.yml b/docs/_config.yml
index fa2c417f..e685a39f 100644
--- a/docs/_config.yml
+++ b/docs/_config.yml
@@ -1,9 +1,12 @@
-title: coreos/ignition
+# Template generated by https://github.com/coreos/repo-templates; do not edit downstream
+
+# To test documentation changes locally or using GitHub Pages, see:
+# https://github.com/coreos/fedora-coreos-tracker/blob/main/docs/testing-project-documentation-changes.md
+
+title: Ignition
 description: Ignition documentation
 baseurl: "/ignition"
 url: "https://coreos.github.io"
-# Comment above and use below for local development
-# url: "http://localhost:4000"
 permalink: /:title/
 markdown: kramdown
 kramdown:
@@ -11,7 +14,7 @@ kramdown:
     ndash: "--"
     mdash: "---"
 
-remote_theme: coreos/just-the-docs
+remote_theme: just-the-docs/just-the-docs@v0.7.0
 plugins:
   - jekyll-remote-theme
 
diff --git a/docs/_sass/custom/custom.scss b/docs/_sass/custom/custom.scss
new file mode 100644
index 00000000..e8fa84f2
--- /dev/null
+++ b/docs/_sass/custom/custom.scss
@@ -0,0 +1,9 @@
+#spec-docs ~ ul {
+  ul {
+    border-left: 1px solid $grey-lt-300;
+  }
+
+  li::before {
+    margin-left: -0.8em;
+  }
+}
diff --git a/docs/configuration-v3_0.md b/docs/configuration-v3_0.md
index f1054e6c..099e57f1 100644
--- a/docs/configuration-v3_0.md
+++ b/docs/configuration-v3_0.md
@@ -1,4 +1,6 @@
 ---
+# This file is automatically generated from config/doc and internal/doc.
+# Do not edit.
 title: Config Spec v3.0.0
 parent: Configuration specifications
 nav_order: 49
@@ -8,26 +10,28 @@ nav_order: 49
 
 The Ignition configuration is a JSON document conforming to the following specification, with **_italicized_** entries being optional:
 
+<div id="spec-docs"></div>
+
 * **ignition** (object): metadata about the configuration itself.
   * **version** (string): the semantic version number of the spec. The spec version must be compatible with the latest version (`3.0.0`). Compatibility requires the major versions to match and the spec version be less than or equal to the latest version. `-experimental` versions compare less than the final version with the same number, and previous experimental versions are not accepted.
-  * **_config_** (objects): options related to the configuration.
+  * **_config_** (object): options related to the configuration.
     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_verification_** (object): options related to the verification of the config.
         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is `sha512`.
     * **_replace_** (object): the config that will replace the current.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_verification_** (object): options related to the verification of the config.
         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is `sha512`.
   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
-    * **_httpResponseHeaders_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
-    * **_httpTotal_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
+    * **_httpResponseHeaders_** (integer): the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
+    * **_httpTotal_** (integer): the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
   * **_security_** (object): options relating to network security.
     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
       * **_certificateAuthorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`.
-        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
-        * **_verification_** (object): options related to the verification of the certificate.
-          * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is sha512.
+        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+        * **_verification_** (object): options related to the verification of the certificate bundle.
+          * **_hash_** (string): the hash of the certificate bundle, in the form `<type>-<value>` where type is `sha512`.
 * **_storage_** (object): describes the desired state of the system's storage devices.
   * **_disks_** (list of objects): the list of disks to be configured and their options. Every entry must have a unique `device`.
     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
@@ -37,10 +41,10 @@ The Ignition configuration is a JSON document conforming to the following specif
       * **_number_** (integer): the partition number, which dictates its position in the partition table (one-indexed). If zero, use the next available partition slot.
       * **_sizeMiB_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
       * **_startMiB_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
-      * **_typeGuid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
+      * **_typeGuid_** (string): the GPT [partition type GUID](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs). If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
       * **_guid_** (string): the GPT unique partition GUID.
-      * **_wipePartitionEntry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
-      * **_shouldExist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
+      * **_wipePartitionEntry_** (boolean): if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
+      * **_shouldExist_** (boolean): whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
     * **name** (string): the name to use for the resulting md device.
     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
@@ -51,30 +55,30 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
     * **_path_** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
-    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](operator-notes.md#filesystem-reuse-semantics) for more information. Defaults to false.
+    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information. Defaults to false.
     * **_label_** (string): the label of the filesystem.
     * **_uuid_** (string): the uuid of the filesystem.
     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
     * **path** (string): the absolute path to the file.
-    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents.source` must be specified if `overwrite` is true. Defaults to false.
+    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
     * **_contents_** (object): options related to the contents of the file.
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
-      * **_verification_** (object): options related to the verification of the file contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is `sha512`.
-    * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
-      * **_verification_** (object): options related to the verification of the appended contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is `sha512`.
-    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are not supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents.source` is unspecified, and a file already exists at the path.
+      * **_source_** (string): the URL of the file. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_compression_** (string): the type of compression used on the file (null or gzip). Compression cannot be used with S3.
+      * **_verification_** (object): options related to the verification of the file.
+        * **_hash_** (string): the hash of the file, in the form `<type>-<value>` where type is `sha512`. If `compression` is specified, the hash describes the decompressed file.
+    * **_append_** (list of objects): list of fragments to be appended to the file. Follows the same structure as `contents`.
+      * **_source_** (string): the URL of the fragment. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the fragment (null or gzip). Compression cannot be used with S3.
+      * **_verification_** (object): options related to the verification of the fragment.
+        * **_hash_** (string): the hash of the fragment, in the form `<type>-<value>` where type is `sha512`. If `compression` is specified, the hash describes the decompressed fragment.
+    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are not supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
     * **_user_** (object): specifies the file's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the file's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the directory.
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
@@ -82,18 +86,18 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_user_** (object): specifies the directory's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the directory's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the link
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
-    * **_user_** (object): specifies the symbolic link's owner.
+    * **_user_** (object): specifies the owner for a symbolic link. Ignored for hard links.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the group for a symbolic link. Ignored for hard links.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
     * **target** (string): the target path of the link
     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
 * **_systemd_** (object): describes the desired state of the systemd units.
@@ -108,7 +112,7 @@ The Ignition configuration is a JSON document conforming to the following specif
 * **_passwd_** (object): describes the desired additions to the passwd database.
   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
     * **name** (string): the username for the account.
-    * **_passwordHash_** (string): the encrypted password for the account.
+    * **_passwordHash_** (string): the hashed password for the account.
     * **_sshAuthorizedKeys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
     * **_uid_** (integer): the user ID of the account.
     * **_gecos_** (string): the GECOS field of the account.
@@ -119,12 +123,9 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_noUserGroup_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
     * **_noLogInit_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
     * **_shell_** (string): the login shell of the new account.
-    * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
+    * **_system_** (boolean): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
     * **name** (string): the name of the group.
     * **_gid_** (integer): the group ID of the new group.
-    * **_passwordHash_** (string): the encrypted password of the new group.
-    * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
-
-[part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
-[rfc2397]: https://tools.ietf.org/html/rfc2397
+    * **_passwordHash_** (string): the hashed password of the new group.
+    * **_system_** (boolean): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
diff --git a/docs/configuration-v3_1.md b/docs/configuration-v3_1.md
index 49e8676c..c842b5a3 100644
--- a/docs/configuration-v3_1.md
+++ b/docs/configuration-v3_1.md
@@ -1,4 +1,6 @@
 ---
+# This file is automatically generated from config/doc and internal/doc.
+# Do not edit.
 title: Config Spec v3.1.0
 parent: Configuration specifications
 nav_order: 48
@@ -8,38 +10,40 @@ nav_order: 48
 
 The Ignition configuration is a JSON document conforming to the following specification, with **_italicized_** entries being optional:
 
+<div id="spec-docs"></div>
+
 * **ignition** (object): metadata about the configuration itself.
   * **version** (string): the semantic version number of the spec. The spec version must be compatible with the latest version (`3.1.0`). Compatibility requires the major versions to match and the spec version be less than or equal to the latest version. `-experimental` versions compare less than the final version with the same number, and previous experimental versions are not accepted.
-  * **_config_** (objects): options related to the configuration.
+  * **_config_** (object): options related to the configuration.
     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the config.
-        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
     * **_replace_** (object): the config that will replace the current.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the config.
-        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
-    * **_httpResponseHeaders_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
-    * **_httpTotal_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
+    * **_httpResponseHeaders_** (integer): the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
+    * **_httpTotal_** (integer): the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
   * **_security_** (object): options relating to network security.
     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
       * **_certificateAuthorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`.
-        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
-        * **_compression_** (string): the type of compression used on the certificate (null or gzip). Compression cannot be used with S3.
+        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+        * **_compression_** (string): the type of compression used on the certificate bundle (null or gzip). Compression cannot be used with S3.
         * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
           * **name** (string): the header name.
           * **_value_** (string): the header contents.
-        * **_verification_** (object): options related to the verification of the certificate.
-          * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_verification_** (object): options related to the verification of the certificate bundle.
+          * **_hash_** (string): the hash of the certificate bundle, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed certificate bundle.
   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
@@ -53,10 +57,10 @@ The Ignition configuration is a JSON document conforming to the following specif
       * **_number_** (integer): the partition number, which dictates its position in the partition table (one-indexed). If zero, use the next available partition slot.
       * **_sizeMiB_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
       * **_startMiB_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
-      * **_typeGuid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
+      * **_typeGuid_** (string): the GPT [partition type GUID](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs). If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
       * **_guid_** (string): the GPT unique partition GUID.
-      * **_wipePartitionEntry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
-      * **_shouldExist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
+      * **_wipePartitionEntry_** (boolean): if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
+      * **_shouldExist_** (boolean): whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
     * **name** (string): the name to use for the resulting md device.
     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
@@ -67,37 +71,37 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
     * **_path_** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
-    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](operator-notes.md#filesystem-reuse-semantics) for more information. Defaults to false.
+    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information. Defaults to false.
     * **_label_** (string): the label of the filesystem.
     * **_uuid_** (string): the uuid of the filesystem.
     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
     * **_mountOptions_** (list of strings): any special options to be passed to the mount command.
   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
     * **path** (string): the absolute path to the file.
-    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents.source` must be specified if `overwrite` is true. Defaults to false.
+    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
     * **_contents_** (object): options related to the contents of the file.
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_source_** (string): the URL of the file. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_compression_** (string): the type of compression used on the file (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
-      * **_verification_** (object): options related to the verification of the file contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
-    * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_verification_** (object): options related to the verification of the file.
+        * **_hash_** (string): the hash of the file, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed file.
+    * **_append_** (list of objects): list of fragments to be appended to the file. Follows the same structure as `contents`.
+      * **_source_** (string): the URL of the fragment. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the fragment (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
-      * **_verification_** (object): options related to the verification of the appended contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
-    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are not supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents.source` is unspecified, and a file already exists at the path.
+      * **_verification_** (object): options related to the verification of the fragment.
+        * **_hash_** (string): the hash of the fragment, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed fragment.
+    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are not supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
     * **_user_** (object): specifies the file's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the file's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the directory.
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
@@ -105,18 +109,18 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_user_** (object): specifies the directory's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the directory's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the link
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
-    * **_user_** (object): specifies the symbolic link's owner.
+    * **_user_** (object): specifies the owner for a symbolic link. Ignored for hard links.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the group for a symbolic link. Ignored for hard links.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
     * **target** (string): the target path of the link
     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
 * **_systemd_** (object): describes the desired state of the systemd units.
@@ -131,7 +135,7 @@ The Ignition configuration is a JSON document conforming to the following specif
 * **_passwd_** (object): describes the desired additions to the passwd database.
   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
     * **name** (string): the username for the account.
-    * **_passwordHash_** (string): the encrypted password for the account.
+    * **_passwordHash_** (string): the hashed password for the account.
     * **_sshAuthorizedKeys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
     * **_uid_** (integer): the user ID of the account.
     * **_gecos_** (string): the GECOS field of the account.
@@ -142,12 +146,9 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_noUserGroup_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
     * **_noLogInit_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
     * **_shell_** (string): the login shell of the new account.
-    * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
+    * **_system_** (boolean): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
     * **name** (string): the name of the group.
     * **_gid_** (integer): the group ID of the new group.
-    * **_passwordHash_** (string): the encrypted password of the new group.
-    * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
-
-[part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
-[rfc2397]: https://tools.ietf.org/html/rfc2397
+    * **_passwordHash_** (string): the hashed password of the new group.
+    * **_system_** (boolean): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
diff --git a/docs/configuration-v3_2.md b/docs/configuration-v3_2.md
index 022b5e60..aa8b070a 100644
--- a/docs/configuration-v3_2.md
+++ b/docs/configuration-v3_2.md
@@ -1,4 +1,6 @@
 ---
+# This file is automatically generated from config/doc and internal/doc.
+# Do not edit.
 title: Config Spec v3.2.0
 parent: Configuration specifications
 nav_order: 47
@@ -8,38 +10,40 @@ nav_order: 47
 
 The Ignition configuration is a JSON document conforming to the following specification, with **_italicized_** entries being optional:
 
+<div id="spec-docs"></div>
+
 * **ignition** (object): metadata about the configuration itself.
   * **version** (string): the semantic version number of the spec. The spec version must be compatible with the latest version (`3.2.0`). Compatibility requires the major versions to match and the spec version be less than or equal to the latest version. `-experimental` versions compare less than the final version with the same number, and previous experimental versions are not accepted.
-  * **_config_** (objects): options related to the configuration.
+  * **_config_** (object): options related to the configuration.
     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `gs`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the config.
-        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
     * **_replace_** (object): the config that will replace the current.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `gs`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the config.
-        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
-    * **_httpResponseHeaders_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
-    * **_httpTotal_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
+    * **_httpResponseHeaders_** (integer): the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
+    * **_httpTotal_** (integer): the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
   * **_security_** (object): options relating to network security.
     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
       * **_certificateAuthorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`.
-        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `gs`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
-        * **_compression_** (string): the type of compression used on the certificate (null or gzip). Compression cannot be used with S3.
+        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+        * **_compression_** (string): the type of compression used on the certificate bundle (null or gzip). Compression cannot be used with S3.
         * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
           * **name** (string): the header name.
           * **_value_** (string): the header contents.
-        * **_verification_** (object): options related to the verification of the certificate.
-          * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_verification_** (object): options related to the verification of the certificate bundle.
+          * **_hash_** (string): the hash of the certificate bundle, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed certificate bundle.
   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
@@ -53,11 +57,11 @@ The Ignition configuration is a JSON document conforming to the following specif
       * **_number_** (integer): the partition number, which dictates its position in the partition table (one-indexed). If zero, use the next available partition slot.
       * **_sizeMiB_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
       * **_startMiB_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
-      * **_typeGuid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
+      * **_typeGuid_** (string): the GPT [partition type GUID](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs). If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
       * **_guid_** (string): the GPT unique partition GUID.
-      * **_wipePartitionEntry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
-      * **_shouldExist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
-      * **_resize_** (boolean) whether or not the existing partition should be resized. If omitted, it defaults to false. If true, Ignition will resize an existing partition if it matches the config in all respects except the partition size.
+      * **_wipePartitionEntry_** (boolean): if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
+      * **_shouldExist_** (boolean): whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
+      * **_resize_** (boolean): whether or not the existing partition should be resized. If omitted, it defaults to false. If true, Ignition will resize an existing partition if it matches the config in all respects except the partition size.
   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
     * **name** (string): the name to use for the resulting md device.
     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
@@ -68,37 +72,37 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
     * **_path_** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
-    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](operator-notes.md#filesystem-reuse-semantics) for more information. Defaults to false.
+    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information. Defaults to false.
     * **_label_** (string): the label of the filesystem.
     * **_uuid_** (string): the uuid of the filesystem.
     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
     * **_mountOptions_** (list of strings): any special options to be passed to the mount command.
   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
     * **path** (string): the absolute path to the file.
-    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents.source` must be specified if `overwrite` is true. Defaults to false.
+    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
     * **_contents_** (object): options related to the contents of the file.
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_source_** (string): the URL of the file. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_compression_** (string): the type of compression used on the file (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
-      * **_verification_** (object): options related to the verification of the file contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
-    * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_verification_** (object): options related to the verification of the file.
+        * **_hash_** (string): the hash of the file, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed file.
+    * **_append_** (list of objects): list of fragments to be appended to the file. Follows the same structure as `contents`.
+      * **_source_** (string): the URL of the fragment. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the fragment (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
-      * **_verification_** (object): options related to the verification of the appended contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
-    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are not supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents.source` is unspecified, and a file already exists at the path.
+      * **_verification_** (object): options related to the verification of the fragment.
+        * **_hash_** (string): the hash of the fragment, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed fragment.
+    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are not supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
     * **_user_** (object): specifies the file's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the file's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the directory.
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
@@ -106,45 +110,45 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_user_** (object): specifies the directory's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the directory's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the link
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
-    * **_user_** (object): specifies the symbolic link's owner.
+    * **_user_** (object): specifies the owner for a symbolic link. Ignored for hard links.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the group for a symbolic link. Ignored for hard links.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
     * **target** (string): the target path of the link
     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
   * **_luks_** (list of objects): the list of luks devices to be created. Every device must have a unique `name`.
     * **name** (string): the name of the luks device.
     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
-    * **_keyFile_** (string): options related to the contents of the key file.
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+    * **_keyFile_** (object): options related to the contents of the key file.
+      * **_source_** (string): the URL of the key file. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the key file (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the key file.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the key file, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed key file.
     * **_label_** (string): the label of the luks device.
     * **_uuid_** (string): the uuid of the luks device.
-    * **_options_** (list of strings): any additional options to be passed to the cryptsetup utility.
-    * **_wipeVolume_** (boolean): whether or not to wipe the device before volume creation, see [the documentation on filesystems](operator-notes.md#filesystem-reuse-semantics) for more information.
+    * **_options_** (list of strings): any additional options to be passed to `cryptsetup luksFormat`.
+    * **_wipeVolume_** (boolean): whether or not to wipe the device before volume creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
     * **_clevis_** (object): describes the clevis configuration for the luks device.
       * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
         * **url** (string): url of the tang server.
         * **thumbprint** (string): thumbprint of a trusted signing key.
-      * **_tpm2_** (bool): whether or not to use a tpm2 device.
-      * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device. Default is 1.
+      * **_tpm2_** (boolean): whether or not to use a tpm2 device.
+      * **_threshold_** (integer): sets the minimum number of pieces required to decrypt the device. Default is 1.
       * **_custom_** (object): overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
         * **pin** (string): the clevis pin.
         * **config** (string): the clevis configuration JSON.
-        * **_needsNetwork_** (bool): whether or not the device requires networking.
+        * **_needsNetwork_** (boolean): whether or not the device requires networking.
 * **_systemd_** (object): describes the desired state of the systemd units.
   * **_units_** (list of objects): the list of systemd units. Every unit must have a unique `name`.
     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service").
@@ -157,7 +161,7 @@ The Ignition configuration is a JSON document conforming to the following specif
 * **_passwd_** (object): describes the desired additions to the passwd database.
   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
     * **name** (string): the username for the account.
-    * **_passwordHash_** (string): the encrypted password for the account.
+    * **_passwordHash_** (string): the hashed password for the account.
     * **_sshAuthorizedKeys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
     * **_uid_** (integer): the user ID of the account.
     * **_gecos_** (string): the GECOS field of the account.
@@ -168,14 +172,11 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_noUserGroup_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
     * **_noLogInit_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
     * **_shell_** (string): the login shell of the new account.
-    * **_shouldExist_** (boolean) whether or not the user with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified user.
-    * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
+    * **_shouldExist_** (boolean): whether or not the user with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified user.
+    * **_system_** (boolean): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
     * **name** (string): the name of the group.
     * **_gid_** (integer): the group ID of the new group.
-    * **_passwordHash_** (string): the encrypted password of the new group.
-    * **_shouldExist_** (boolean) whether or not the group with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified group.
-    * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
-
-[part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
-[rfc2397]: https://tools.ietf.org/html/rfc2397
+    * **_passwordHash_** (string): the hashed password of the new group.
+    * **_shouldExist_** (boolean): whether or not the group with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified group.
+    * **_system_** (boolean): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
diff --git a/docs/configuration-v3_3.md b/docs/configuration-v3_3.md
index 731c2b3e..97f9ff81 100644
--- a/docs/configuration-v3_3.md
+++ b/docs/configuration-v3_3.md
@@ -1,4 +1,6 @@
 ---
+# This file is automatically generated from config/doc and internal/doc.
+# Do not edit.
 title: Config Spec v3.3.0
 parent: Configuration specifications
 nav_order: 46
@@ -8,38 +10,40 @@ nav_order: 46
 
 The Ignition configuration is a JSON document conforming to the following specification, with **_italicized_** entries being optional:
 
+<div id="spec-docs"></div>
+
 * **ignition** (object): metadata about the configuration itself.
   * **version** (string): the semantic version number of the spec. The spec version must be compatible with the latest version (`3.3.0`). Compatibility requires the major versions to match and the spec version be less than or equal to the latest version. `-experimental` versions compare less than the final version with the same number, and previous experimental versions are not accepted.
-  * **_config_** (objects): options related to the configuration.
+  * **_config_** (object): options related to the configuration.
     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `gs`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the config.
-        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
     * **_replace_** (object): the config that will replace the current.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `gs`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the config.
-        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
-    * **_httpResponseHeaders_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
-    * **_httpTotal_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
+    * **_httpResponseHeaders_** (integer): the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
+    * **_httpTotal_** (integer): the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
   * **_security_** (object): options relating to network security.
     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
       * **_certificateAuthorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`.
-        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `gs`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
-        * **_compression_** (string): the type of compression used on the certificate (null or gzip). Compression cannot be used with S3.
+        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+        * **_compression_** (string): the type of compression used on the certificate bundle (null or gzip). Compression cannot be used with S3.
         * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
           * **name** (string): the header name.
           * **_value_** (string): the header contents.
-        * **_verification_** (object): options related to the verification of the certificate.
-          * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_verification_** (object): options related to the verification of the certificate bundle.
+          * **_hash_** (string): the hash of the certificate bundle, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed certificate bundle.
   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
@@ -53,11 +57,11 @@ The Ignition configuration is a JSON document conforming to the following specif
       * **_number_** (integer): the partition number, which dictates its position in the partition table (one-indexed). If zero, use the next available partition slot.
       * **_sizeMiB_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
       * **_startMiB_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
-      * **_typeGuid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
+      * **_typeGuid_** (string): the GPT [partition type GUID](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs). If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
       * **_guid_** (string): the GPT unique partition GUID.
-      * **_wipePartitionEntry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
-      * **_shouldExist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
-      * **_resize_** (boolean) whether or not the existing partition should be resized. If omitted, it defaults to false. If true, Ignition will resize an existing partition if it matches the config in all respects except the partition size.
+      * **_wipePartitionEntry_** (boolean): if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
+      * **_shouldExist_** (boolean): whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
+      * **_resize_** (boolean): whether or not the existing partition should be resized. If omitted, it defaults to false. If true, Ignition will resize an existing partition if it matches the config in all respects except the partition size.
   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
     * **name** (string): the name to use for the resulting md device.
     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
@@ -68,37 +72,37 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, swap, or none).
     * **_path_** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
-    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](operator-notes.md#filesystem-reuse-semantics) for more information. Defaults to false.
+    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information. Defaults to false.
     * **_label_** (string): the label of the filesystem.
     * **_uuid_** (string): the uuid of the filesystem.
     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
     * **_mountOptions_** (list of strings): any special options to be passed to the mount command.
   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
     * **path** (string): the absolute path to the file.
-    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents.source` must be specified if `overwrite` is true. Defaults to false.
+    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
     * **_contents_** (object): options related to the contents of the file.
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_source_** (string): the URL of the file. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_compression_** (string): the type of compression used on the file (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
-      * **_verification_** (object): options related to the verification of the file contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
-    * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_verification_** (object): options related to the verification of the file.
+        * **_hash_** (string): the hash of the file, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed file.
+    * **_append_** (list of objects): list of fragments to be appended to the file. Follows the same structure as `contents`.
+      * **_source_** (string): the URL of the fragment. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the fragment (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
-      * **_verification_** (object): options related to the verification of the appended contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
-    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are not supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents.source` is unspecified, and a file already exists at the path.
+      * **_verification_** (object): options related to the verification of the fragment.
+        * **_hash_** (string): the hash of the fragment, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed fragment.
+    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are not supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
     * **_user_** (object): specifies the file's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the file's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the directory.
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
@@ -106,45 +110,45 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_user_** (object): specifies the directory's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the directory's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the link
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
-    * **_user_** (object): specifies the symbolic link's owner.
+    * **_user_** (object): specifies the owner for a symbolic link. Ignored for hard links.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the group for a symbolic link. Ignored for hard links.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
     * **target** (string): the target path of the link
     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
   * **_luks_** (list of objects): the list of luks devices to be created. Every device must have a unique `name`.
     * **name** (string): the name of the luks device.
     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
-    * **_keyFile_** (string): options related to the contents of the key file.
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+    * **_keyFile_** (object): options related to the contents of the key file.
+      * **_source_** (string): the URL of the key file. Supported schemes are `http`, `https`, `tftp`, `s3`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the key file (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the key file.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the key file, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed key file.
     * **_label_** (string): the label of the luks device.
     * **_uuid_** (string): the uuid of the luks device.
-    * **_options_** (list of strings): any additional options to be passed to the cryptsetup utility.
-    * **_wipeVolume_** (boolean): whether or not to wipe the device before volume creation, see [the documentation on filesystems](operator-notes.md#filesystem-reuse-semantics) for more information.
+    * **_options_** (list of strings): any additional options to be passed to `cryptsetup luksFormat`.
+    * **_wipeVolume_** (boolean): whether or not to wipe the device before volume creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
     * **_clevis_** (object): describes the clevis configuration for the luks device.
       * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
         * **url** (string): url of the tang server.
         * **thumbprint** (string): thumbprint of a trusted signing key.
-      * **_tpm2_** (bool): whether or not to use a tpm2 device.
-      * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device. Default is 1.
+      * **_tpm2_** (boolean): whether or not to use a tpm2 device.
+      * **_threshold_** (integer): sets the minimum number of pieces required to decrypt the device. Default is 1.
       * **_custom_** (object): overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
         * **pin** (string): the clevis pin.
         * **config** (string): the clevis configuration JSON.
-        * **_needsNetwork_** (bool): whether or not the device requires networking.
+        * **_needsNetwork_** (boolean): whether or not the device requires networking.
 * **_systemd_** (object): describes the desired state of the systemd units.
   * **_units_** (list of objects): the list of systemd units. Every unit must have a unique `name`.
     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service").
@@ -157,7 +161,7 @@ The Ignition configuration is a JSON document conforming to the following specif
 * **_passwd_** (object): describes the desired additions to the passwd database.
   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
     * **name** (string): the username for the account.
-    * **_passwordHash_** (string): the encrypted password for the account.
+    * **_passwordHash_** (string): the hashed password for the account.
     * **_sshAuthorizedKeys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
     * **_uid_** (integer): the user ID of the account.
     * **_gecos_** (string): the GECOS field of the account.
@@ -168,17 +172,14 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_noUserGroup_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
     * **_noLogInit_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
     * **_shell_** (string): the login shell of the new account.
-    * **_shouldExist_** (boolean) whether or not the user with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified user.
-    * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
+    * **_shouldExist_** (boolean): whether or not the user with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified user.
+    * **_system_** (boolean): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
     * **name** (string): the name of the group.
     * **_gid_** (integer): the group ID of the new group.
-    * **_passwordHash_** (string): the encrypted password of the new group.
-    * **_shouldExist_** (boolean) whether or not the group with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified group.
-    * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
+    * **_passwordHash_** (string): the hashed password of the new group.
+    * **_shouldExist_** (boolean): whether or not the group with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified group.
+    * **_system_** (boolean): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
 * **_kernelArguments_** (object): describes the desired kernel arguments.
   * **_shouldExist_** (list of strings): the list of kernel arguments that should exist.
   * **_shouldNotExist_** (list of strings): the list of kernel arguments that should not exist.
-
-[part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
-[rfc2397]: https://tools.ietf.org/html/rfc2397
diff --git a/docs/configuration-v3_4.md b/docs/configuration-v3_4.md
new file mode 100644
index 00000000..c4e133f9
--- /dev/null
+++ b/docs/configuration-v3_4.md
@@ -0,0 +1,188 @@
+---
+# This file is automatically generated from config/doc and internal/doc.
+# Do not edit.
+title: Config Spec v3.4.0
+parent: Configuration specifications
+nav_order: 45
+---
+
+# Configuration Specification v3.4.0
+
+The Ignition configuration is a JSON document conforming to the following specification, with **_italicized_** entries being optional:
+
+<div id="spec-docs"></div>
+
+* **ignition** (object): metadata about the configuration itself.
+  * **version** (string): the semantic version number of the spec. The spec version must be compatible with the latest version (`3.4.0`). Compatibility requires the major versions to match and the spec version be less than or equal to the latest version. `-experimental` versions compare less than the final version with the same number, and previous experimental versions are not accepted.
+  * **_config_** (object): options related to the configuration.
+    * **_merge_** (list of objects): a list of the configs to be merged to the current config.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
+      * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
+        * **name** (string): the header name.
+        * **_value_** (string): the header contents.
+      * **_verification_** (object): options related to the verification of the config.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
+    * **_replace_** (object): the config that will replace the current.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
+      * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
+        * **name** (string): the header name.
+        * **_value_** (string): the header contents.
+      * **_verification_** (object): options related to the verification of the config.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
+  * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
+    * **_httpResponseHeaders_** (integer): the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
+    * **_httpTotal_** (integer): the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
+  * **_security_** (object): options relating to network security.
+    * **_tls_** (object): options relating to TLS when fetching resources over `https`.
+      * **_certificateAuthorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`.
+        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+        * **_compression_** (string): the type of compression used on the certificate bundle (null or gzip). Compression cannot be used with S3.
+        * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
+          * **name** (string): the header name.
+          * **_value_** (string): the header contents.
+        * **_verification_** (object): options related to the verification of the certificate bundle.
+          * **_hash_** (string): the hash of the certificate bundle, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed certificate bundle.
+  * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
+    * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
+    * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
+    * **_noProxy_** (list of strings): specifies a list of strings to hosts that should be excluded from proxying. Each value is represented by an `IP address prefix (1.2.3.4)`, `an IP address prefix in CIDR notation (1.2.3.4/8)`, `a domain name`, or `a special DNS label (*)`. An IP address prefix and domain name can also include a literal port number `(1.2.3.4:80)`. A domain name matches that name and all subdomains. A domain name with a leading `.` matches subdomains only. For example `foo.com` matches `foo.com` and `bar.foo.com`; `.y.com` matches `x.y.com` but not `y.com`. A single asterisk `(*)` indicates that no proxying should be done.
+* **_storage_** (object): describes the desired state of the system's storage devices.
+  * **_disks_** (list of objects): the list of disks to be configured and their options. Every entry must have a unique `device`.
+    * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
+    * **_wipeTable_** (boolean): whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact.
+    * **_partitions_** (list of objects): the list of partitions and their configuration for this particular disk. Every partition must have a unique `number`, or if 0 is specified, a unique `label`.
+      * **_label_** (string): the PARTLABEL for the partition.
+      * **_number_** (integer): the partition number, which dictates its position in the partition table (one-indexed). If zero, use the next available partition slot.
+      * **_sizeMiB_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
+      * **_startMiB_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
+      * **_typeGuid_** (string): the GPT [partition type GUID](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs). If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
+      * **_guid_** (string): the GPT unique partition GUID.
+      * **_wipePartitionEntry_** (boolean): if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
+      * **_shouldExist_** (boolean): whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
+      * **_resize_** (boolean): whether or not the existing partition should be resized. If omitted, it defaults to false. If true, Ignition will resize an existing partition if it matches the config in all respects except the partition size.
+  * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
+    * **name** (string): the name to use for the resulting md device.
+    * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
+    * **devices** (list of strings): the list of devices (referenced by their absolute path) in the array.
+    * **_spares_** (integer): the number of spares (if applicable) in the array.
+    * **_options_** (list of strings): any additional options to be passed to mdadm.
+  * **_filesystems_** (list of objects): the list of filesystems to be configured. `device` and `format` need to be specified. Every filesystem must have a unique `device`.
+    * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
+    * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, swap, or none).
+    * **_path_** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
+    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information. Defaults to false.
+    * **_label_** (string): the label of the filesystem.
+    * **_uuid_** (string): the uuid of the filesystem.
+    * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
+    * **_mountOptions_** (list of strings): any special options to be passed to the mount command.
+  * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
+    * **path** (string): the absolute path to the file.
+    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
+    * **_contents_** (object): options related to the contents of the file.
+      * **_source_** (string): the URL of the file. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_compression_** (string): the type of compression used on the file (null or gzip). Compression cannot be used with S3.
+      * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
+        * **name** (string): the header name.
+        * **_value_** (string): the header contents.
+      * **_verification_** (object): options related to the verification of the file.
+        * **_hash_** (string): the hash of the file, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed file.
+    * **_append_** (list of objects): list of fragments to be appended to the file. Follows the same structure as `contents`.
+      * **_source_** (string): the URL of the fragment. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the fragment (null or gzip). Compression cannot be used with S3.
+      * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
+        * **name** (string): the header name.
+        * **_value_** (string): the header contents.
+      * **_verification_** (object): options related to the verification of the fragment.
+        * **_hash_** (string): the hash of the fragment, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed fragment.
+    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
+    * **_user_** (object): specifies the file's owner.
+      * **_id_** (integer): the user ID of the owner.
+      * **_name_** (string): the user name of the owner.
+    * **_group_** (object): specifies the file's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
+  * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
+    * **path** (string): the absolute path to the directory.
+    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
+    * **_mode_** (integer): the directory's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0755 -> 493). Setuid/setgid/sticky bits are supported. If not specified, the permission mode for directories defaults to 0755 or the mode of an existing directory if `overwrite` is false and a directory already exists at the path.
+    * **_user_** (object): specifies the directory's owner.
+      * **_id_** (integer): the user ID of the owner.
+      * **_name_** (string): the user name of the owner.
+    * **_group_** (object): specifies the directory's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
+  * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
+    * **path** (string): the absolute path to the link
+    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
+    * **_user_** (object): specifies the owner for a symbolic link. Ignored for hard links.
+      * **_id_** (integer): the user ID of the owner.
+      * **_name_** (string): the user name of the owner.
+    * **_group_** (object): specifies the group for a symbolic link. Ignored for hard links.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
+    * **target** (string): the target path of the link
+    * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
+  * **_luks_** (list of objects): the list of luks devices to be created. Every device must have a unique `name`.
+    * **name** (string): the name of the luks device.
+    * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
+    * **_keyFile_** (object): options related to the contents of the key file.
+      * **_source_** (string): the URL of the key file. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the key file (null or gzip). Compression cannot be used with S3.
+      * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
+        * **name** (string): the header name.
+        * **_value_** (string): the header contents.
+      * **_verification_** (object): options related to the verification of the key file.
+        * **_hash_** (string): the hash of the key file, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed key file.
+    * **_label_** (string): the label of the luks device.
+    * **_uuid_** (string): the uuid of the luks device.
+    * **_options_** (list of strings): any additional options to be passed to `cryptsetup luksFormat`.
+    * **_discard_** (boolean): whether to issue discard commands to the underlying block device when blocks are freed. Enabling this improves performance and device longevity on SSDs and space utilization on thinly provisioned SAN devices, but leaks information about which disk blocks contain data. If omitted, it defaults to false.
+    * **_openOptions_** (list of strings): any additional options to be passed to `cryptsetup luksOpen`. Supported options will be persistently written to the luks volume.
+    * **_wipeVolume_** (boolean): whether or not to wipe the device before volume creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
+    * **_clevis_** (object): describes the clevis configuration for the luks device.
+      * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
+        * **url** (string): url of the tang server.
+        * **thumbprint** (string): thumbprint of a trusted signing key.
+        * **_advertisement_** (string): the advertisement JSON. If not specified, the advertisement is fetched from the tang server during provisioning.
+      * **_tpm2_** (boolean): whether or not to use a tpm2 device.
+      * **_threshold_** (integer): sets the minimum number of pieces required to decrypt the device. Default is 1.
+      * **_custom_** (object): overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
+        * **pin** (string): the clevis pin.
+        * **config** (string): the clevis configuration JSON.
+        * **_needsNetwork_** (boolean): whether or not the device requires networking.
+* **_systemd_** (object): describes the desired state of the systemd units.
+  * **_units_** (list of objects): the list of systemd units. Every unit must have a unique `name`.
+    * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service").
+    * **_enabled_** (boolean): whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section.
+    * **_mask_** (boolean): whether or not the service shall be masked. When true, the service is masked by symlinking it to `/dev/null`. When false, the service is unmasked by deleting the symlink to `/dev/null` if it exists.
+    * **_contents_** (string): the contents of the unit.
+    * **_dropins_** (list of objects): the list of drop-ins for the unit. Every drop-in must have a unique `name`.
+      * **name** (string): the name of the drop-in. This must be suffixed with ".conf".
+      * **_contents_** (string): the contents of the drop-in.
+* **_passwd_** (object): describes the desired additions to the passwd database.
+  * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
+    * **name** (string): the username for the account.
+    * **_passwordHash_** (string): the hashed password for the account.
+    * **_sshAuthorizedKeys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
+    * **_uid_** (integer): the user ID of the account.
+    * **_gecos_** (string): the GECOS field of the account.
+    * **_homeDir_** (string): the home directory of the account.
+    * **_noCreateHome_** (boolean): whether or not to create the user's home directory. This only has an effect if the account doesn't exist yet.
+    * **_primaryGroup_** (string): the name of the primary group of the account.
+    * **_groups_** (list of strings): the list of supplementary groups of the account.
+    * **_noUserGroup_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
+    * **_noLogInit_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
+    * **_shell_** (string): the login shell of the new account.
+    * **_shouldExist_** (boolean): whether or not the user with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified user.
+    * **_system_** (boolean): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
+  * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
+    * **name** (string): the name of the group.
+    * **_gid_** (integer): the group ID of the new group.
+    * **_passwordHash_** (string): the hashed password of the new group.
+    * **_shouldExist_** (boolean): whether or not the group with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified group.
+    * **_system_** (boolean): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
+* **_kernelArguments_** (object): describes the desired kernel arguments.
+  * **_shouldExist_** (list of strings): the list of kernel arguments that should exist.
+  * **_shouldNotExist_** (list of strings): the list of kernel arguments that should not exist.
diff --git a/docs/configuration-v3_4_experimental.md b/docs/configuration-v3_5_experimental.md
similarity index 65%
rename from docs/configuration-v3_4_experimental.md
rename to docs/configuration-v3_5_experimental.md
index 39f6cf99..5f334ba0 100644
--- a/docs/configuration-v3_4_experimental.md
+++ b/docs/configuration-v3_5_experimental.md
@@ -1,47 +1,51 @@
 ---
-title: Config Spec v3.4.0-experimental
+# This file is automatically generated from config/doc and internal/doc.
+# Do not edit.
+title: Config Spec v3.5.0-experimental
 parent: Configuration specifications
 nav_order: 50
 ---
 
-# Configuration Specification v3.4.0-experimental
+# Configuration Specification v3.5.0-experimental
 
 _NOTE_: This pre-release version of the specification is experimental and is subject to change without notice or regard to backward compatibility.
 
 The Ignition configuration is a JSON document conforming to the following specification, with **_italicized_** entries being optional:
 
+<div id="spec-docs"></div>
+
 * **ignition** (object): metadata about the configuration itself.
-  * **version** (string): the semantic version number of the spec. The spec version must be compatible with the latest version (`3.4.0-experimental`). Compatibility requires the major versions to match and the spec version be less than or equal to the latest version. `-experimental` versions compare less than the final version with the same number, and previous experimental versions are not accepted.
-  * **_config_** (objects): options related to the configuration.
+  * **version** (string): the semantic version number of the spec. The spec version must be compatible with the latest version (`3.5.0-experimental`). Compatibility requires the major versions to match and the spec version be less than or equal to the latest version. `-experimental` versions compare less than the final version with the same number, and previous experimental versions are not accepted.
+  * **_config_** (object): options related to the configuration.
     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `arn`, `gs`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the config.
-        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
     * **_replace_** (object): the config that will replace the current.
-      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `arn`, `gs`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
       * **_compression_** (string): the type of compression used on the config (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the config.
-        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed config.
   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
-    * **_httpResponseHeaders_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
-    * **_httpTotal_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
+    * **_httpResponseHeaders_** (integer): the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
+    * **_httpTotal_** (integer): the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
   * **_security_** (object): options relating to network security.
     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
       * **_certificateAuthorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`.
-        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `arn`, `gs`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
-        * **_compression_** (string): the type of compression used on the certificate (null or gzip). Compression cannot be used with S3.
+        * **source** (string): the URL of the certificate bundle (in PEM format). The bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+        * **_compression_** (string): the type of compression used on the certificate bundle (null or gzip). Compression cannot be used with S3.
         * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
           * **name** (string): the header name.
           * **_value_** (string): the header contents.
-        * **_verification_** (object): options related to the verification of the certificate.
-          * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_verification_** (object): options related to the verification of the certificate bundle.
+          * **_hash_** (string): the hash of the certificate bundle, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed certificate bundle.
   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
@@ -55,11 +59,11 @@ The Ignition configuration is a JSON document conforming to the following specif
       * **_number_** (integer): the partition number, which dictates its position in the partition table (one-indexed). If zero, use the next available partition slot.
       * **_sizeMiB_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
       * **_startMiB_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
-      * **_typeGuid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
+      * **_typeGuid_** (string): the GPT [partition type GUID](https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs). If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
       * **_guid_** (string): the GPT unique partition GUID.
-      * **_wipePartitionEntry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
-      * **_shouldExist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
-      * **_resize_** (boolean) whether or not the existing partition should be resized. If omitted, it defaults to false. If true, Ignition will resize an existing partition if it matches the config in all respects except the partition size.
+      * **_wipePartitionEntry_** (boolean): if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
+      * **_shouldExist_** (boolean): whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
+      * **_resize_** (boolean): whether or not the existing partition should be resized. If omitted, it defaults to false. If true, Ignition will resize an existing partition if it matches the config in all respects except the partition size.
   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
     * **name** (string): the name to use for the resulting md device.
     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
@@ -70,37 +74,37 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, swap, or none).
     * **_path_** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
-    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](operator-notes.md#filesystem-reuse-semantics) for more information. Defaults to false.
+    * **_wipeFilesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information. Defaults to false.
     * **_label_** (string): the label of the filesystem.
     * **_uuid_** (string): the uuid of the filesystem.
     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
     * **_mountOptions_** (list of strings): any special options to be passed to the mount command.
   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
     * **path** (string): the absolute path to the file.
-    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents.source` must be specified if `overwrite` is true. Defaults to false.
+    * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
     * **_contents_** (object): options related to the contents of the file.
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_source_** (string): the URL of the file. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created.
+      * **_compression_** (string): the type of compression used on the file (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
-      * **_verification_** (object): options related to the verification of the file contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
-    * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_verification_** (object): options related to the verification of the file.
+        * **_hash_** (string): the hash of the file, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed file.
+    * **_append_** (list of objects): list of fragments to be appended to the file. Follows the same structure as `contents`.
+      * **_source_** (string): the URL of the fragment. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the fragment (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
-      * **_verification_** (object): options related to the verification of the appended contents.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
-    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents.source` is unspecified, and a file already exists at the path.
+      * **_verification_** (object): options related to the verification of the fragment.
+        * **_hash_** (string): the hash of the fragment, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed fragment.
+    * **_mode_** (integer): the file's permission mode. Note that the mode must be properly specified as a **decimal** value (i.e. 0644 -> 420). Setuid/setgid/sticky bits are supported. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
     * **_user_** (object): specifies the file's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the file's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the directory.
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
@@ -108,45 +112,48 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_user_** (object): specifies the directory's owner.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the directory's group.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
     * **path** (string): the absolute path to the link
     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
-    * **_user_** (object): specifies the symbolic link's owner.
+    * **_user_** (object): specifies the owner for a symbolic link. Ignored for hard links.
       * **_id_** (integer): the user ID of the owner.
       * **_name_** (string): the user name of the owner.
-    * **_group_** (object): specifies the group of the owner.
-      * **_id_** (integer): the group ID of the owner.
-      * **_name_** (string): the group name of the owner.
+    * **_group_** (object): specifies the group for a symbolic link. Ignored for hard links.
+      * **_id_** (integer): the group ID of the group.
+      * **_name_** (string): the group name of the group.
     * **target** (string): the target path of the link
     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
   * **_luks_** (list of objects): the list of luks devices to be created. Every device must have a unique `name`.
     * **name** (string): the name of the luks device.
     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
-    * **_keyFile_** (string): options related to the contents of the key file.
-      * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
-      * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+    * **_keyFile_** (object): options related to the contents of the key file.
+      * **_source_** (string): the URL of the key file. Supported schemes are `http`, `https`, `tftp`, `s3`, `arn`, `gs`, and [`data`](https://tools.ietf.org/html/rfc2397). When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
+      * **_compression_** (string): the type of compression used on the key file (null or gzip). Compression cannot be used with S3.
       * **_httpHeaders_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
         * **name** (string): the header name.
         * **_value_** (string): the header contents.
       * **_verification_** (object): options related to the verification of the key file.
-        * **_hash_** (string): the hash of the contents, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
+        * **_hash_** (string): the hash of the key file, in the form `<type>-<value>` where type is either `sha512` or `sha256`. If `compression` is specified, the hash describes the decompressed key file.
     * **_label_** (string): the label of the luks device.
     * **_uuid_** (string): the uuid of the luks device.
-    * **_options_** (list of strings): any additional options to be passed to the cryptsetup utility.
-    * **_wipeVolume_** (boolean): whether or not to wipe the device before volume creation, see [the documentation on filesystems](operator-notes.md#filesystem-reuse-semantics) for more information.
+    * **_options_** (list of strings): any additional options to be passed to `cryptsetup luksFormat`.
+    * **_discard_** (boolean): whether to issue discard commands to the underlying block device when blocks are freed. Enabling this improves performance and device longevity on SSDs and space utilization on thinly provisioned SAN devices, but leaks information about which disk blocks contain data. If omitted, it defaults to false.
+    * **_openOptions_** (list of strings): any additional options to be passed to `cryptsetup luksOpen`. Supported options will be persistently written to the luks volume.
+    * **_wipeVolume_** (boolean): whether or not to wipe the device before volume creation, see [Ignition's documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
     * **_clevis_** (object): describes the clevis configuration for the luks device.
       * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
         * **url** (string): url of the tang server.
         * **thumbprint** (string): thumbprint of a trusted signing key.
-      * **_tpm2_** (bool): whether or not to use a tpm2 device.
-      * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device. Default is 1.
+        * **_advertisement_** (string): the advertisement JSON. If not specified, the advertisement is fetched from the tang server during provisioning.
+      * **_tpm2_** (boolean): whether or not to use a tpm2 device.
+      * **_threshold_** (integer): sets the minimum number of pieces required to decrypt the device. Default is 1.
       * **_custom_** (object): overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
         * **pin** (string): the clevis pin.
         * **config** (string): the clevis configuration JSON.
-        * **_needsNetwork_** (bool): whether or not the device requires networking.
+        * **_needsNetwork_** (boolean): whether or not the device requires networking.
 * **_systemd_** (object): describes the desired state of the systemd units.
   * **_units_** (list of objects): the list of systemd units. Every unit must have a unique `name`.
     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service").
@@ -159,7 +166,7 @@ The Ignition configuration is a JSON document conforming to the following specif
 * **_passwd_** (object): describes the desired additions to the passwd database.
   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
     * **name** (string): the username for the account.
-    * **_passwordHash_** (string): the encrypted password for the account.
+    * **_passwordHash_** (string): the hashed password for the account.
     * **_sshAuthorizedKeys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
     * **_uid_** (integer): the user ID of the account.
     * **_gecos_** (string): the GECOS field of the account.
@@ -170,17 +177,14 @@ The Ignition configuration is a JSON document conforming to the following specif
     * **_noUserGroup_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
     * **_noLogInit_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
     * **_shell_** (string): the login shell of the new account.
-    * **_shouldExist_** (boolean) whether or not the user with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified user.
-    * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
+    * **_shouldExist_** (boolean): whether or not the user with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified user.
+    * **_system_** (boolean): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
     * **name** (string): the name of the group.
     * **_gid_** (integer): the group ID of the new group.
-    * **_passwordHash_** (string): the encrypted password of the new group.
-    * **_shouldExist_** (boolean) whether or not the group with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified group.
-    * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
+    * **_passwordHash_** (string): the hashed password of the new group.
+    * **_shouldExist_** (boolean): whether or not the group with the specified `name` should exist. If omitted, it defaults to true. If false, then Ignition will delete the specified group.
+    * **_system_** (boolean): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
 * **_kernelArguments_** (object): describes the desired kernel arguments.
   * **_shouldExist_** (list of strings): the list of kernel arguments that should exist.
   * **_shouldNotExist_** (list of strings): the list of kernel arguments that should not exist.
-
-[part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
-[rfc2397]: https://tools.ietf.org/html/rfc2397
diff --git a/docs/development.md b/docs/development.md
index c2f12dc6..e4d2b82a 100644
--- a/docs/development.md
+++ b/docs/development.md
@@ -1,5 +1,5 @@
 ---
-nav_order: 10
+nav_order: 11
 ---
 
 # Development
@@ -8,7 +8,7 @@ nav_order: 10
 1. TOC
 {:toc}
 
-A Go 1.15+ [environment](https://golang.org/doc/install) and the `blkid.h` headers are required.
+A Go 1.20+ [environment](https://golang.org/doc/install) and the `blkid.h` headers are required.
 
 ```sh
 # Debian/Ubuntu
@@ -18,6 +18,80 @@ sudo apt-get install libblkid-dev
 sudo dnf install libblkid-devel
 ```
 
+## Development notes
+
+See also the [Ignition rationale](rationale.md).
+
+### Code structure
+
+The [frontend](https://github.com/coreos/ignition/tree/main/config) handles config parsing and validation which need not run on the target system.  The [backend](https://github.com/coreos/ignition/tree/main/internal) performs the configuration of the target system.  The frontend is a stable library API that is used by other programs, so existing frontend API cannot be changed without bumping the Ignition major version.
+
+### Adding functionality
+
+New config directives should only be added if the desired behavior cannot reasonably be achieved with existing directives.  User-friendly wrappers for existing syntax ("sugar") should be handled by [Butane](https://github.com/coreos/butane).
+
+New behavior should only be added in the current experimental spec.  If new functionality is backported to older specs, and a config using an older spec comes to depend on that functionality, then it won't be obvious that the config will not work on all Ignition versions supporting that spec.  It's not always possible to follow this restriction, since the backend doesn't know what config version the user specified.  Where possible, use config validation to prevent the backend from seeing config directives that a spec version doesn't support (for example, values of the filesystem `format` field).
+
+New functionality added to a config spec must be declarative: it must describe what should exist, not what Ignition should do.  In particular, field names should not include verbs.  When adding functionality, carefully think through the interactions between features, which can be non-trivial.  Features should be orthogonal, minimal, and low-level; making them user-friendly is the responsibility of Butane sugar.
+
+When reprovisioning an existing node, the config may want to reuse existing disks and filesystems without reformatting them.  Config directives should support detecting and reusing an existing object (RAID volume, filesystem, etc.) if its properties match those specified in the config.
+
+Ignition specs should not include distro-specific functionality such as package management.  Features may require support from the distro (for example, setting kernel arguments), but such features should be broadly applicable.  Distro-specific options such as support for SELinux, or paths to external binaries, can be configured at build time in the [`distro`](https://github.com/coreos/ignition/blob/main/internal/distro/distro.go) package.  Distro-specific glue (e.g. support for reformatting the root filesystem) should be implemented outside the Ignition codebase, in Dracut modules that run between Ignition stages (see below).
+
+Ideally, functionality should not be added to an experimental spec in the same Ignition release that the spec is stabilized.  Doing so prevents users from trying out the functionality before we commit to maintaining it.
+
+### Modifying existing functionality
+
+Bugfixes can be backported to older specs if working configs will not be affected and the current behavior is unintended.  New config validations can (and should) be backported if the prohibited behavior always would have failed anyway.
+
+Existing config semantics can only be changed (without adding a flag field) if the spec major version is bumped.  This might be appropriate e.g. to clean up some awkward syntax or change some default behavior.  However, altogether removing functionality is very costly.  The spec 2.x to 3.x transition was difficult because some 2.x configs cannot be represented in spec 3.x, so users were required to manually update their configs.  If a major version bump only rearranges functionality but doesn't remove any, Ignition can automatically translate the previous major version to the current one, and no [flag day](https://en.wikipedia.org/wiki/Flag_day_(computing)) will be required.
+
+### Validation and failures
+
+Ignition is a low-level tool and does not attempt to prevent configs from doing unreasonable things.
+
+- Config validation should fail when it's clear from inspection that Ignition will be unable to perform the requested provisioning.  This must occur when the config is contradictory (e.g. specifies the same filesystem object as both a file and a directory) and thus would break the declarativeness of the spec, and may occur where the problem will produce a routine error at runtime (e.g. invalid arguments to `mkfs`).
+- Ignition must fail at runtime when it is dynamically unable to perform the requested provisioning.
+- If a config is implementable but will render the system non-functional, Ignition should execute the config anyway.  Any user-friendly detection of unreasonable configs should happen in Butane.
+
+### Platforms
+
+Platform providers should continue retrying config fetch until it's clear whether the user has provided an Ignition config.  If Ignition eventually timed out when fetching a config, then a slow network device or block device (on a very large machine or a heavily-loaded VM host) could cause Ignition to prematurely fail, or to continue booting without applying the specified config.
+
+Platform providers must allow the user not to provide a config, e.g. to boot an exploratory OS instance and use Afterburn to inject SSH keys.
+
+Ignition must never read from config providers that aren't under the control of the platform, since this could allow config injection from unintended sources.  For example, `169.254.169.254` is a link-local address and could easily be spoofed on platforms that don't specially handle that address.  As a corollary, the platform ID must always be explicitly set by the OS image, never guessed.
+
+### Network access
+
+All config fields that cause network accesses, directly or indirectly, should be added to the `fetch-offline` needs-net detector.
+
+Any network accesses performed by subprocesses should be mimicked by Ignition before starting the subprocess.  This ensures that Ignition's retry logic is used, so Ignition doesn't improperly fail if the network is still coming up.
+
+### Execution stages
+
+Ignition execution is divided into stages to allow other OS functionality to run in the middle of provisioning:
+
+1. `fetch-offline` stage
+1. OS enables networking if required
+1. `fetch` stage
+1. OS examines fetched config and e.g. copies root filesystem contents to RAM
+1. `disks` stage
+1. OS mounts root filesystem
+1. `mount` stage
+1. OS does any preprocessing of configured filesystems, including copying root filesystem contents back
+1. `files` stage
+1. OS does any postprocessing of provisioned system
+1. `umount` stage
+
+New stages should only be created when OS hooks would otherwise need to run in the middle of a stage.  Note that various external projects hardcode the list of Ignition stages.
+
+### Security
+
+Ignition must always provide secure defaults, and does not provide config directives that support or encourage unsafe behavior.  For example, Ignition does not support disabling HTTPS certificate checks, nor seeding the system entropy pool from potentially deterministic sources.  Similarly, the LUKS `discard` option exists because users may legitimately want to trade off some security for hardware longevity, but Ignition defaults to the secure option.
+
+Users might put secrets in Ignition configs.  On many platforms, userdata is accessible to unprivileged programs at runtime, potentially leaking those secrets.  When the userdata is accessible via a network service, users can configure firewall rules to prevent such access, but this may not be possible for hypervisors that expose userdata through a kernel interface.  Where possible, platform providers should provide a `DelConfig` method allowing Ignition to delete the userdata from the platform after provisioning is complete.
+
 ## Modifying the config spec
 
 Install [schematyper](https://github.com/idubinskiy/schematyper) to generate Go structs from JSON schema definitions.
@@ -49,7 +123,15 @@ After modifying `go.mod` run `make vendor` to update the vendor directory.
 
 Group changes to `go.mod`, `go.sum` and `vendor/` in their own commit; do not make code changes and vendoring changes in the same commit.
 
-## Running Blackbox Tests
+## Testing
+
+Ignition uses three different test frameworks:
+
+- Unit tests (`./test`) validate functionality that only affects internal program state.
+- Blackbox tests validate config directives that affect the target disk.
+- Fedora CoreOS [kola tests](https://coreos.github.io/coreos-assembler/kola/) validate functionality that interacts with platforms (e.g. config fetching) or the rest of the OS.  kola tests may be [internal](https://github.com/coreos/coreos-assembler/tree/main/mantle/kola/tests/ignition) or [external](https://github.com/coreos/fedora-coreos-config/tree/testing-devel/tests/kola/ignition).
+
+### Running blackbox tests
 
 ```sh
 ./build_blackbox_tests
@@ -68,9 +150,9 @@ You can get a list of available tests to run by passing the `-list` option, like
 sudo sh -c 'PATH=$PWD/bin/amd64:$PATH ./tests.test -list'
 ```
 
-## Test Host System Dependencies
+### Blackbox test host system dependencies
 
-The following packages are required by the Blackbox Test:
+The following packages are required by the blackbox tests:
 
 * `util-linux`
 * `dosfstools`
@@ -82,27 +164,21 @@ The following packages are required by the Blackbox Test:
 * `mdadm`
 * `libblkid-devel`
 
-## Writing Blackbox Tests
+### Writing blackbox tests
 
 To add a blackbox test create a function which yields a `Test` object. A `Test` object consists of the following fields:
 
-Name: `string`
-
-In: `[]Disk` object, which describes the Disks that should be created before Ignition is run.
-
-Out: `[]Disk` object, which describes the Disks that should be present after Ignition is run.
-
-MntDevices: `MntDevice` object, which describes any disk related variable replacements that need to be done to the Ignition config before Ignition is run. This is done so that disks which are created during the test run can be referenced inside of an Ignition config.
-
-SystemDirFiles: `[]File` object which describes the Files that should be written into Ignition's system config directory before Ignition is run.
-
-Config: `string` type where the specific config version should be replaced by `$version` and will be updated before Ignition is run.
-
-ConfigMinVersion: `string` type which describes the minimum config version the test should be run with. Copies of the test will be generated for every version, inside the same major version, that is equal to or greater than the specified ConfigMinVersion. If the test should run only once with a specfic config version, leave this field empty and replace $version in the `Config` field with the desired version.
+- `Name`: `string`
+- `In`: `[]Disk` object, which describes the Disks that should be created before Ignition is run.
+- `Out`: `[]Disk` object, which describes the Disks that should be present after Ignition is run.
+- `MntDevices`: `MntDevice` object, which describes any disk related variable replacements that need to be done to the Ignition config before Ignition is run. This is done so that disks which are created during the test run can be referenced inside of an Ignition config.
+- `SystemDirFiles`: `[]File` object which describes the Files that should be written into Ignition's system config directory before Ignition is run.
+- `Config`: `string` type where the specific config version should be replaced by `$version` and will be updated before Ignition is run.
+- `ConfigMinVersion`: `string` type which describes the minimum config version the test should be run with. Copies of the test will be generated for every version, inside the same major version, that is equal to or greater than the specified ConfigMinVersion. If the test should run only once with a specfic config version, leave this field empty and replace $version in the `Config` field with the desired version.
 
 The test should be added to the init function inside of the test file. If the test module is being created then an `init` function should be created which registers the tests and the package must be imported inside of `tests/registry/registry.go` to allow for discovery.
 
-UUIDs may be required in the following fields of a Test object: In, Out, and Config. Replace all GUIDs with GUID varaibles which take on the format `$uuid<num>` (e.g. $uuid123). Where `<num>` must be a positive integer. GUID variables with identical `<num>` fields will be replaced with identical GUIDs. For example, look at [tests/positive/partitions/zeros.go](https://github.com/coreos/ignition/blob/main/tests/positive/partitions/zeros.go).
+UUIDs may be required in the following fields of a `Test` object: `In`, `Out`, and `Config`. Replace all GUIDs with GUID varaibles which take on the format `$uuid<num>` (e.g. $uuid123). Where `<num>` must be a positive integer. GUID variables with identical `<num>` fields will be replaced with identical GUIDs. For example, look at [tests/positive/partitions/zeros.go](https://github.com/coreos/ignition/blob/main/tests/positive/partitions/zeros.go).
 
 ## Releasing Ignition
 
@@ -119,66 +195,4 @@ In case you have trouble with the aforementioned standard Pull Request Guide, co
 
 ## Marking an experimental spec as stable
 
-When an experimental version of the Ignition config spec (e.g.: `3.1.0-experimental`) is to be declared stable (e.g. `3.1.0`), there are a handful of changes that must be made to the code base. These changes should have the following effects:
-
-- Any configs with a `version` field set to the previously experimental version will no longer pass validation. For example, if `3.1.0-experimental` is being marked as stable, any configs written for `3.1.0-experimental` should have their version fields changed to `3.1.0`, for Ignition will no longer accept them.
-- A new experimental spec version will be created. For example, if `3.1.0-experimental` is being marked as stable, a new version of `3.2.0-experimental` (or `4.0.0-experimental` if backwards incompatible changes are being made) will now be accepted, and start to accumulate new changes to the spec.
-- The new stable spec and the new experimental spec will be identical except for the accepted versions. The new experimental spec is a direct copy of the old experimental spec, and no new changes to the spec have been made yet, so initially the two specs will have the same fields and semantics.
-- The HTTP `Accept` header that Ignition uses whenever fetching a config will be updated to advertise the new stable spec.
-- New features will be documented in the [Upgrading Configs](migrating-configs.md) documentation.
-
-The changes that are required to achieve these effects are typically the following:
-
-### Making the experimental package stable
-
-- Rename `config/vX_Y_experimental` to `config/vX_Y`, and update the golang `package` statements
-- Drop `_experimental` from all imports in `config/vX_Y`
-- Update `MaxVersion` in `config/vX_Y/types/config.go` to delete the `PreRelease` field
-- Update `config/vX_Y/config_test.go` to test that the new stable version is valid and the old experimental version is invalid
-- Update the `Accept` header in `internal/resource/url.go` to specify the new spec version.
-
-### Creating the new experimental package
-
-- Copy `config/vX_Y` into `config/vX_(Y+1)_experimental`, and update the golang `package` statements
-- Update all `config/vX_Y` imports in `config/vX_(Y+1)_experimental` to `config/vX_(Y+1)_experimental`
-- Update `config/vX_(Y+1)_experimental/types/config.go` to set `MaxVersion` to the correct major/minor versions with `PreRelease` set to `"experimental"`
-- Update `config/vX_(Y+1)_experimental/config.go` to point the `prev` import to the new stable `vX_Y` package
-- Update `config/vX_(Y+1)_experimental/config_test.go` to test that the new stable version is invalid and the new experimental version is valid
-- Update `config/vX_(Y+1)_experimental/translate/translate.go` to translate from the previous stable version.  Update the `old_types` import, delete all functions except `translateIgnition` and `Translate`, and ensure `translateIgnition` translates the entire `Ignition` struct.
-- Update `config/config.go` imports to point to the experimental version.
-- Update `config/config_test.go` to add the new experimental version to `TestConfigStructure`.
-- Update `generate` to generate the new stable and experimental versions, and rerun `generate`.
-
-### Update all relevant places to use the new experimental package
-
-Next, all places that imported `config/vX_Y_experimental` should be updated to `config/vX_(Y+1)_experimental`.
-
-Update `tests/register/register.go` in the following ways:
-
-- Add import `config/vX_Y`
-- Update import `config/vX_Y_experimental` to `config/vX_(Y+1)_experimental`
-- Add `config/vX_Y`'s identifier to `configVersions` in `Register()`
-
-### Update the blackbox tests
-
-Update the blackbox tests.
-
-- Bump the invalid `-experimental` version in the relevant `VersionOnlyConfig` test in `tests/negative/general/config.go`.
-- Find all tests using `X.Y.0-experimental` and alter them to use `X.Y.0`.
-- Update the `Accept` header checks in `tests/servers.go` to specify the new spec version.
-
-### Update docs
-
-Finally, update docs.
-
-- Rename `docs/configuration-vX_Y-experimental.md` to `docs/configuration-vX_Y.md` and make a copy as `docs/configuration-vX_(Y+1)_experimental.md`.
-- In `docs/configuration-vX_Y.md`, drop `-experimental` from the version number in the heading and the `ignition.version` field, and drop the prerelease warning. Update the `nav_order` field in the Jekyll front matter to be one less than the `nav_order` of the previous stable spec.
-- In `docs/configuration-vX_(Y+1)_experimental.md`, update the version of the experimental spec in the heading and the `ignition.version` field.
-- Add a section to `docs/migrating-configs.md`.
-- In `docs/specs.md`, update the list of stable and experimental spec versions (listing the latest stable release first) and update the table listing the Ignition release where a spec has been marked as stable.
-
-### External Tests
-
-If there are any external kola tests that were using the now stabilized experimental spec that are not part of the Ignition repo (e.g. tests in the [fedora-coreos-config](https://github.com/coreos/fedora-coreos-config/tree/testing-devel/tests/kola) repo), CI will fail for the spec stabilization PR. Uncomment the commented-out workaround for this in `.cci.jenkinsfile`.
-
-When bumping the Ignition package in fedora-coreos-config, you'll need to update the external test in that repo to make CI green. At that point, you must comment out the workaround.
+Create a new [stabilization checklist](https://github.com/coreos/ignition/issues/new?template=stabilize-checklist.md) and follow the steps there.
diff --git a/docs/distributor-notes.md b/docs/distributor-notes.md
index 1e29720c..23f917f4 100644
--- a/docs/distributor-notes.md
+++ b/docs/distributor-notes.md
@@ -1,5 +1,5 @@
 ---
-nav_order: 9
+nav_order: 10
 ---
 
 # Distributor Notes
@@ -8,6 +8,10 @@ nav_order: 9
 1. TOC
 {:toc}
 
+## Dracut Module
+
+The distribution specific integration is responsible for ensuring that the ignition dracut module is included in the initramfs when necessary. This can be achieved by adding it as dependency of the dracut module containing the distribution integration, or by installing a dracut configuration file.
+
 ## Kernel Arguments
 
 When Ignition is updating kernel arguments it will call out to a binary (defined in `internal/distro/distro.go` and overridable at build-time via overriding the `github.com/coreos/ignition/v2/internal/distro.kargsCmd` build flag). Ignition expects that the binary accepts `--should-exist` & `--should-not-exist` parameters. Should exist operations should append the argument if missing and should not exist should NOT fail if the argument is not present. The binary should also reboot the system if necessary.
diff --git a/docs/migrating-configs.md b/docs/migrating-configs.md
index 30f0dc23..2a220197 100644
--- a/docs/migrating-configs.md
+++ b/docs/migrating-configs.md
@@ -10,6 +10,124 @@ Occasionally, there are changes made to Ignition's configuration that break back
 1. TOC
 {:toc}
 
+## From Version 3.3.0 to 3.4.0
+
+There are not any breaking changes between versions 3.3.0 and 3.4.0 of the configuration specification. Any valid 3.3.0 configuration can be updated to a 3.4.0 configuration by simply changing the version string in the config.
+
+The following is a list of notable new features, deprecations, and changes.
+
+### Offline Tang provisioning
+
+The `tang` section gained a new `advertisement` field. If specified, Ignition will use it to provision the Tang server binding rather than fetching the advertisement from the server at runtime. This allows the server to be unavailable at provisioning time. The advertisement can be obtained from the server with `curl http://tang.example.com/adv`.
+
+<!-- ignition -->
+```json
+{
+  "ignition": { "version": "3.4.0" },
+  "storage": {
+    "luks": [{
+      "name": "luks-tang",
+      "device": "/dev/sdb",
+      "clevis": {
+        "tang": [{
+          "url": "https://tang.example.com",
+          "thumbprint": "REPLACE-THIS-WITH-YOUR-TANG-THUMBPRINT",
+          "advertisement": "{\"payload\": \"...\", \"protected\": \"...\", \"signature\": \"...\"}"
+        }]
+      }
+    }]
+  }
+}
+```
+
+### LUKS discard
+
+The `luks` section gained a new `discard` field. If specified and true, the LUKS volume will issue discard commands to the underlying block device when blocks are freed. This improves performance and device longevity on SSDs and space utilization on thinly provisioned SAN devices, but leaks information about which disk blocks contain data.
+
+<!-- ignition -->
+```json
+{
+  "ignition": { "version": "3.4.0" },
+  "storage": {
+    "luks": [{
+      "name": "luks-tpm",
+      "device": "/dev/sdb",
+      "discard": true,
+      "clevis": {
+        "tpm2": true
+      }
+    }]
+  }
+}
+```
+
+### LUKS open options
+
+The `luks` section gained a new `openOptions` field. It is a list of options Ignition should pass to `cryptsetup luksOpen` when unlocking the volume. Ignition also passes `--persistent`, so any options that support persistence will be saved to the volume and automatically used for future unlocks. Any options that do not support persistence will only be applied to Ignition's initial unlock of the volume.
+
+<!-- ignition -->
+```json
+{
+  "ignition": { "version": "3.4.0" },
+  "storage": {
+    "luks": [{
+      "name": "luks-tpm",
+      "device": "/dev/sdb",
+      "openOptions": ["--perf-no_read_workqueue", "--perf-no_write_workqueue"],
+      "clevis": {
+        "tpm2": true
+      }
+    }]
+  }
+}
+```
+
+### Special mode bits supported
+
+The `mode` field of the `files` and `directories` sections now respects the setuid, setgid, and sticky bits. Previous spec versions ignore these bits, but will generate a warning on Ignition ≥ 2.14.0.
+
+<!-- ignition -->
+```json
+{
+  "ignition": {
+    "version": "3.4.0"
+  },
+  "storage": {
+    "files": [{
+      "path": "/usr/local/bin/setuid",
+      "contents": {
+        "source": "https://rootkit.example.com/setuid"
+      },
+      "mode": 2541
+    }],
+    "directories": [{
+      "path": "/var/local/tmp",
+      "mode": 1023
+    }]
+  }
+}
+```
+
+### AWS S3 access point ARN support
+
+The sections which allow fetching a remote URL now accept AWS S3 access point ARNs (`arn:aws:s3:<region>:<account>:accesspoint/<accesspoint>/object/<path>`) in the `source` field.
+
+<!-- ignition -->
+```json
+{
+  "ignition": { "version": "3.4.0" },
+  "storage": {
+    "files": [{
+      "path": "/etc/example",
+      "mode": 420,
+      "contents": {
+        "source": "arn:aws:s3:us-west-1:123456789012:accesspoint/test/object/some/path"
+      }
+    }]
+  }
+}
+```
+
 ## From Version 3.2.0 to 3.3.0
 
 There are not any breaking changes between versions 3.2.0 and 3.3.0 of the configuration specification. Any valid 3.2.0 configuration can be updated to a 3.3.0 configuration by simply changing the version string in the config.
diff --git a/docs/operator-notes.md b/docs/operator-notes.md
index 518e479b..245ed4b7 100644
--- a/docs/operator-notes.md
+++ b/docs/operator-notes.md
@@ -138,7 +138,7 @@ If a child header has no value, the parent header with the same name will be rem
 
 Ignition has support for creating both purely key-file based LUKS2 devices as well as Tang/TPM2 backed (via clevis) devices.
 
-If a key-file is not specified one will be generated for the device. Key-files will be stored at `/etc/luks/<deviceName>` (this path can be overriden via build flags).
+If a key-file is not specified one will be generated for the device. Key-files will be stored at `/etc/luks/<deviceName>` (this path can be overridden via build flags).
 
 Ignition generates entries in `/etc/crypttab` for each device and expects that the operating system has hooks to be able to unlock the device (e.x.: `systemd-cryptsetup-generator`).
 
diff --git a/docs/rationale.md b/docs/rationale.md
index 9f400795..be78d70b 100644
--- a/docs/rationale.md
+++ b/docs/rationale.md
@@ -28,8 +28,14 @@ Ignition configs describe the state of a system. Ignition configs do _not_ list
 
 Ignition configs do not allow users to provide arbitrary logic (including scripts for Ignition to run). Users describe which filesystems must exist, which files must be created, which users must exist, and etc. Any further customization must use systemd services, created by Ignition.
 
+Ignition does not guess how the system should be configured.  For example, it does not automatically select a disk to hold any requested partitions.  Users must specify the configuration explicitly.
+
 ## Ignition configs should not be written by hand
 
-Ignition configs were designed to be human readable, but difficult to write, to discourage users from attempting to write configs by hand.
+Ignition configs were designed to be human readable, but difficult to write, to discourage users from attempting to write configs by hand.  Ignition configs support basic primitives such as files, directories, filesystems, and partitions, but do not provide higher-level functionality for configuring specific system services.
 
 Use [Butane](https://coreos.github.io/butane/), or a similar tool, to generate Ignition configs. Butane reads [Butane configs](https://coreos.github.io/butane/specs/), which are YAML files containing distribution-independent Ignition directives and optional distribution-specific directives that provide an easier way to perform certain configuration tasks. Butane validates a Butane config for common errors and produces an Ignition config ready to be passed to a machine.
+
+## Ignition is distro-independent
+
+Ignition provides functionality that is broadly applicable to image-based Linux distributions.  It does not provide distro-specific functionality such as package management.
diff --git a/docs/release-notes.md b/docs/release-notes.md
new file mode 100644
index 00000000..6510ccde
--- /dev/null
+++ b/docs/release-notes.md
@@ -0,0 +1,1359 @@
+---
+nav_order: 9
+---
+
+# Release Notes
+
+## Upcoming Ignition 2.19.0 (unreleased)
+
+### Breaking changes
+
+### Features
+
+### Changes
+
+### Bug fixes
+
+## Ignition 2.18.0 (2024-03-01)
+
+### Breaking changes
+
+- Only include dracut module in initramfs if requested (see distributor notes
+  for details)
+
+### Features
+
+- Support Scaleway
+
+
+### Changes
+
+- Require Go 1.20+
+
+### Bug fixes
+
+- Fix failure when config only disables units already disabled
+- Retry HTTP requests on Azure on status codes 404, 410, and 429
+
+
+## Ignition 2.17.0 (2023-11-20)
+
+Starting with this release, ignition-validate binaries are signed with the
+[Fedora 39 key](https://getfedora.org/security/).
+
+### Features
+
+- Support the native Apple Hypervisor
+- Support Hetzner Cloud
+- A GRUB configuration suitable for use with https://github.com/coreos/bootupd
+  can now be installed; use `make install-grub-for-bootupd` to install it
+
+### Changes
+
+- Require Go 1.19+
+
+### Bug fixes
+
+- Prevent races with udev after disk editing
+- Don't fail to wipe partition table if it's corrupted
+
+
+## Ignition 2.16.2 (2023-07-12)
+
+### Bug fixes
+
+- Fix Dracut module installation on arches other than x86 and aarch64
+
+
+## Ignition 2.16.1 (2023-07-10)
+
+### Bug fixes
+
+- Fix build on 32-bit systems
+
+
+## Ignition 2.16.0 (2023-06-29)
+
+Starting with this release, ignition-validate binaries are signed with the
+[Fedora 38 key](https://getfedora.org/security/).
+
+### Features
+
+- Support Hyper-V platform
+- Automatically generate spec docs
+
+### Changes
+
+- Clarify spec terminology for contents of CA bundles, files, and key files
+- Improve rendering of spec docs on docs site
+
+### Bug fixes
+
+- Fix failure disabling nonexistent unit with systemd ≥ 252
+- Don't relabel a mount point that already exists
+- Document that `hash` fields describe decompressed data
+- Clarify documentation of `passwordHash` fields
+- Correctly document Tang `advertisement` field as optional
+
+### Test changes
+
+- Support and require xfsprogs ≥ 5.19 in blackbox tests
+
+
+## Ignition 2.15.0 (2023-02-21)
+
+Starting with this release, ignition-validate binaries are signed with the
+[Fedora 37 key](https://getfedora.org/security/).
+
+### Features
+
+- Support offline Tang provisioning via pre-shared advertisement _(3.4.0)_
+- Allow enabling discard passthrough on LUKS devices _(3.4.0)_
+- Allow specifying arbitrary LUKS open options _(3.4.0)_
+- Ship aarch64 macOS ignition-validate binary in GitHub release artifacts
+
+### Changes
+
+- Mark the 3.4.0 config spec as stable
+- No longer accept configs with version 3.4.0-experimental
+- Create new 3.5.0-experimental config spec from 3.4.0
+- Fail if files/links/dirs conflict with systemd units or dropins
+- Warn if template for enabled systemd instance unit has no `Install` section
+- Warn if filesystem overwrites partitioned disk
+- Warn if `wipeTable` overwrites a filesystem that would otherwise be reused
+- Warn if `user`/`group` specified for hard link
+- Install ignition-apply in `/usr/libexec`
+- Allow distros to add Ignition command-line arguments from a unit drop-in
+- Convert `NEWS` to Markdown and move to docs site
+- Require Go 1.18+
+
+### Bug fixes
+
+- Don't overwrite LUKS1 volume when `storage.luks.wipeVolume` is false
+- Request network when custom Clevis config has `needsNetwork` set
+- Fix creating LUKS volume with custom Clevis config that uses TPM2
+- Avoid logging spurious error when a LUKS volume wasn't previously formatted
+- Fix version string in ignition-validate release container
+- Fix reproducibility of systemd preset file in ignition-apply output
+- Document that `user`/`group` fields aren't applied to hard links
+- Clarify spec docs for `files`/`directories`/`links` `group` fields
+
+
+## Ignition 2.14.0 (12-May-2022)
+
+Starting with this release, ignition-validate binaries are signed with the
+[Fedora 36 key](https://getfedora.org/security/).
+
+### Features
+
+- Support KubeVirt platform
+- Support AWS `arn:` URLs for S3 objects and access points _(3.4.0-exp)_
+- Support reading configs from Azure IMDS "user data"
+- Support S3 fetch via IPv6
+- Add `ignition-apply` entrypoint to apply an Ignition config in a container
+
+### Changes
+
+- Delete userdata after provisioning on VirtualBox and VMware by default
+  (see operator notes for details) (GHSA-hj57-j5cw-2mwp, CVE-2022-1706)
+- Support setting setuid/setgid/sticky mode bits _(3.4.0-exp)_
+- Warn if setuid/setgid/sticky mode bits specified _(3.0.0 - 3.3.0)_
+- Support UEFI Secure Boot on VMware
+- Add arm64 support to ignition-validate container
+- Document S3 fetch semantics in operator notes
+- Document considerations for handling secrets in operator notes
+
+### Bug fixes
+
+- Fix disabling systemd units with pre-existing enablement symlinks
+- Fix reuse of statically keyed LUKS volumes (2.12.0 regression)
+- Fix `gs://` fetch in GCE instances configured without a service account
+- Fix error reading VirtualBox guest properties that have flags
+- Fix infinite loop if `-root` command-line argument is a relative path
+
+
+## Ignition 2.13.0 (30-Nov-2021)
+
+Starting with this release, ignition-validate binaries are signed with the
+[Fedora 35 key](https://getfedora.org/security/).
+
+### Features
+
+- Add Nutanix provider
+- Switch VirtualBox provider to read from `/Ignition/Config` guest property
+
+### Changes
+
+- Improve QEMU `fw_cfg` read performance
+- Warn when QEMU `fw_cfg` config is too large for reasonable performance
+- Move Ignition report to `/etc/.ignition-result.json`
+- Improve resilience to filesystem unmount failures
+- Run `mkfs.fat` instead of its alias `mkfs.vfat`
+- Refresh supported platform documentation
+
+### Bug fixes
+
+- Make `ignition.version` required in JSON schema _(3.4.0-exp)_
+- Disallow null `noProxy` array entries in JSON schema _(3.4.0-exp)_
+
+
+## Ignition 2.12.0 (05-Aug-2021)
+
+### Features
+
+- Support Azure generation 2 VMs
+- Write info about Ignition’s execution to `/var/lib/ignition/result.json`
+
+### Changes
+
+- Access GCP metadata service by IP address to mitigate DNS poisoning
+  attacks
+- Document `storage.luks.clevis.threshold` default
+- Document minimum Ignition release for each spec version
+
+### Bug fixes
+
+- Fix permissions of mountpoints inside user home directories
+- Apply SELinux labels to newly-created `ext4` filesystems
+
+### Internal changes
+
+- Drop `ignition-setup-user.service` and `ignition-firstboot-complete.service`
+  in favor of distro-provided code
+- Persist some state between Ignition stages using a file in `/run`
+- Add command-line flag specifying path to `neednet` flag file
+- Drop `-clear-cache` command-line flag
+- Fix reboot race in example kargs helper
+- Drop support for Go 1.13 and 1.14
+
+
+## Ignition 2.11.0 (25-Jun-2021)
+
+### Breaking changes
+
+- Convert `ClevisCustom.Config`, `ClevisCustom.Pin`, `LinkEmbedded1.Target`,
+  and `Raid.Level` Go fields to pointers _(3.3.0)_
+
+### Features
+
+- Accept `none` in `storage.filesystems.format` _(3.3.0)_
+- Add `ParseCompatibleVersion()` Go functions to parse any config up to
+  the selected version
+- Add `powervs` platform
+
+### Changes
+
+- Mark the 3.3.0 config spec as stable
+- No longer accept configs with version 3.3.0-experimental
+- Create new 3.4.0-experimental config spec from 3.3.0
+- Report specific reason an existing LUKS device cannot be reused
+- Validate that `storage.raid.devices` is non-empty
+- Don't sequence `ignition-setup-user.service` before `multipathd.service`
+
+### Bug fixes
+
+- Fix misleading error message if spares are requested for a RAID level
+  that doesn't support them
+
+
+## Ignition 2.10.1 (29-Apr-2021)
+
+### Bug fixes
+
+- Fix file mode of `ignition-kargs-helper` script
+
+
+## Ignition 2.10.0 (29-Apr-2021)
+
+Starting with this release, ignition-validate binaries are signed with the
+[Fedora 34 key](https://getfedora.org/security/).
+
+### Breaking changes
+
+- Rename `Custom` struct to `ClevisCustom` _(3.3.0-exp)_
+- Embed `Clevis` and `ClevisCustom` structs in parents _(3.3.0-exp)_
+- Always include interior nodes in merge transcript
+
+### Features
+
+- Add kernel argument support _(3.3.0-exp)_
+
+### Bug fixes
+
+- Fix fetching userdata on AWS when IMDSv1 is disabled
+- Fix creating Tang-based LUKS volumes before network is up
+- Document `storage.filesystems.wipeFilesystem` default
+
+
+## Ignition 2.9.0 (08-Jan-2021)
+
+### Changes
+
+- Require `storage.filesystems.format` if `wipeFilesystem` or `mountOptions`
+  is specified
+- Refactor code to address golangci-lint warnings
+
+### Bug fixes
+
+- Fix fetching configs from S3 resources when running on non-default AWS
+  partitions
+- Fix fetching userdata from IMDSv2 on AWS
+- Fix crash on partitions with no number or label
+- Correctly document `storage.filesystems.path` as optional
+- Clarify documented semantics of `systemd.units.name`
+
+
+## Ignition 2.8.1 (02-Dec-2020)
+
+### Bug fixes
+
+- Correctly merge config fields behind a struct pointer (e.g. `clevis`)
+
+
+## Ignition 2.8.0 (25-Nov-2020)
+
+Starting with this release, ignition-validate binaries are signed with the
+[Fedora 33 key](https://getfedora.org/security/).
+
+### Features
+
+- Support unmasking systemd units
+
+### Changes
+
+- Switch system base config from single file to `.d` directory
+- Add Go merge API that produces a transcript of merge operations
+
+
+## Ignition 2.7.0 (13-Oct-2020)
+
+### Features
+
+- Support resizing existing partitions _(3.2.0)_
+- Support reusing LUKS devices not bound to Clevis _(3.2.0)_
+
+### Changes
+
+- Mark the 3.2.0 config spec as stable
+- No longer accept configs with version 3.2.0-experimental
+- Create new 3.3.0-experimental config spec from 3.2.0
+- Require presence of a config source on CloudStack/OpenStack, and
+  wait indefinitely for it to appear
+- When executing in non-default AWS partitions (GovCloud or AWS
+  China), fetch `s3://` resources from the same partition
+
+### Bug fixes
+
+- Fix bundled library unconditionally blocking for entropy at startup
+- Fix config fetching on AzureStack
+- Fix partition offset/length calculation on big-endian systems
+- Fix premature logging of successful config fetch
+
+
+## Ignition 2.6.0 (07-Aug-2020)
+
+### Features
+
+- Add `release` tag to ignition-validate container for latest release
+- Support creating ephemeral LUKS volumes _(3.2.0-exp)_
+- Support deleting users/groups _(3.2.0-exp)_
+
+### Bug fixes
+
+- Request network when needed on CloudStack/OpenStack
+
+
+## Ignition 2.5.0 (23-Jul-2020)
+
+### Changes
+
+- Merge ignition-dracut into the Ignition repository
+
+### Bug fixes
+
+- Fix udev race determining filesystem type when creating filesystem
+
+
+## Ignition 2.4.1 (16-Jul-2020)
+
+### Changes
+
+- Set LUKS key file directory to mode 700
+
+### Bug fixes
+
+- Fix nondeterministic config provider precedence causing fetch failures
+- Don't relabel symlink to home directory, since it might not be writable
+- Fix failure looking up users/groups
+
+
+## Ignition 2.4.0 (13-Jul-2020)
+
+### Features
+
+- Support creating LUKS volumes with Clevis or static key file _(3.2.0-exp)_
+- Support Google Cloud Storage (`gs://`) resource URLs
+- Support AWS IMDSv2
+- Allow specifying multiple CA certificates in one resource
+- Add Azure Stack platform
+- Allow OS to avoid starting network if the config doesn't need it
+
+### Changes
+
+- When creating a filesystem, run `wipefs` on target device first
+- Warn if filesystem probe finds multiple filesystem signatures
+- Don't warn about unset file/directory mode in config
+- Fetch AWS metadata version 2019-10-01 instead of 2009-04-04
+- Refactor SELinux relabeling
+
+### Bug fixes
+
+- Fix compressed CA certificates
+- Fix hard links to files deeper than the hard link
+- Write empty systemd dropin if requested
+- Remember to relabel `/etc/systemd/system-preset`
+- Ensure configs are only fetched during fetch stage
+- Clarify docs about interaction between file contents and overwrite
+
+
+## Ignition 2.3.0 (05-May-2020)
+
+Starting with this release, ignition-validate binaries are signed with the
+[Fedora 32 key](https://getfedora.org/security/).
+
+### Features
+
+- Allow specifying HTTP headers when fetching remote resources _(3.1.0)_
+- Support compression for CA certs and merged/replaced configs _(3.1.0)_
+- Support `sha256` verification hashes _(3.1.0)_
+- Support compression for `data` URIs
+- Log structured journal entry when user config is found
+- Log structured journal entry when SSH keys are written
+
+### Changes
+
+- Unify `CaReference`, `ConfigReference`, `FileContents` structs into
+  `Resource` _(3.1.0)_
+- Mark the 3.1.0 config spec as stable
+- No longer accept configs with version 3.1.0-experimental
+- Create new 3.2.0-experimental config spec from 3.1.0
+
+### Bug fixes
+
+- Fix `ignition-validate` for config versions other than 3.0.0
+- Fix config fetch and status reporting on Packet
+
+
+## Ignition 2.2.1 (24-Mar-2020)
+
+### Bug fixes
+
+- Fix build failure on arches other than amd64, arm64, ppc64le, or s390x
+
+
+## Ignition 2.2.0 (23-Mar-2020)
+
+### Features
+
+- Add Exoscale and Vultr providers
+- On QEMU/s390x and QEMU/ppc64le, fetch Ignition config from a virtio
+  block device (experimental)
+
+### Changes
+
+- Don't relabel `/root` and `/home`
+
+### Bug fixes
+
+- Fix enabling systemd instantiated services
+- Fail if SSH keys cannot be written
+- Fix partition creation on s390x
+
+
+## Ignition 2.1.1 (13-Dec-2019)
+
+### Bug fixes
+
+- Fix panics when processes Ignition starts fail
+
+### Features
+
+- An ignition-validate container is now built and can be used instead of
+  the ignition-validate binaries
+
+
+## Ignition 2.1.0 (12-Dec-2019)
+
+### Bug fixes
+
+- Do not panic when filesystem paths are unspecified
+- Specify the correct config version HTTP `Accept` headers when fetching
+  configs
+- Write the config cache file atomically
+- Relabel symlinks for masking systemd units
+- Fix bug where empty GPT labels were treated as errors
+- Do not generate warnings if mode is unset for files with only an `append`
+  section
+- Validate HTTP(S) proxy urls in spec 3.1.0-experimental
+
+### Features
+
+- Ignition now logs the name of the stage it is running
+- Ignition now relabels files directly instead of writing systemd units to
+  do so. Requires Linux 5.4.0+ or a patch. See operator notes for more
+  details
+- Add optional `fetch` stage to cache the rendered config, but not apply
+  any of it
+- Add support for `aliyun` cloud
+- Add support for zVM hypervisor
+- Add support for specifying mount options for filesystems in spec
+  3.1.0-experimental
+
+### Dependency changes
+
+- Ignition no longer needs the `chroot` or `id` binaries in the initramfs
+
+
+## Ignition 2.0.1 (24-Jul-2019)
+
+### Bug fixes
+
+- Fix getting AWS region when networking is slow to come up
+- Validate file/directory paths correctly
+
+
+## Ignition 2.0.0 (03-Jun-2019)
+
+### Bug fixes
+
+- Use `/run/ignition/dev_aliases` instead of `/dev_aliases` when creating our
+  own symlinks to devices in `/dev`
+
+### Test changes
+
+- Rename tests to use `dots.with.lowercase`
+
+### Public Go API changes
+
+- Replace `config/validate` api with `github.com/coreos/vcontext`
+- `Validate()` functions in `config/*` now follow the `vcontext` validation
+  interface
+
+
+## Ignition 2.0.0-beta (26-Apr-2019)
+
+### Features
+
+- Add configuration spec 3.1.0-experimental
+- Allow specifying HTTP(S) proxies in spec 3.1.0-experimental
+- Validate hard links do not link to directories
+- Validate paths do not include links specified in the config
+
+### Bug fixes
+
+- Include major version in `go.mod` correctly
+- Fix SELinux relabeling of systemd unit files
+- Update documentation for spec 3.0.0+
+
+### Changes
+
+- Remove all deprecated fields in configuration specs
+- Remove `ec2` platform id in favor of `aws`
+- Remove `pxe` platform as it is not a platform
+- Fail if files, links, and directories conflict after symlink resolution
+- Do not fail when writing directories or links if overwrite is false and a
+  matching directory or link already exists
+
+
+## Ignition 2.0.0-alpha (25-Mar-2019)
+
+**NOTE**: This is an alpha release. While the spec is marked as stable (i.e no
+"-experimental" suffix) we still reserve the right to change it until the
+stable 2.0.0 release. However, we do not anticipate any backwards
+incompatible changes aside from removing deprecated fields.
+
+**NOTE**: In order to allow types from both the 2.x.y and 3.0.0 specs to be
+vendored and imported in the same project, we are skipping version 1.0.0.
+Go mod (and some other tools) treat v0.x and v1.x as the same when
+importing packages with semantic import versioning.
+
+### Features
+
+- Ignition now understands config specification 3.0.0
+- Configs are now merged instead of appended
+
+### Changes
+
+- Configs with version < 3.0.0 are now rejected
+- Duplicate entries are now disallowed in lists
+- Removal of almost all deprecated fields
+
+
+## Ignition 0.30.0 (14-Dec-2018)
+
+### Features
+
+- Parallelize filesystem creation
+
+### Changes
+
+- Increase default config fetch timeout to 2 minutes
+
+### Test changes
+
+- Add `-list` option to list blackbox tests
+- Skip backward compatibility tests with `-test.short`
+
+
+## Ignition 0.29.1 (06-Dec-2018)
+
+### Bug fixes
+
+- When writing files, directories, or links, do not follow symlinks if they
+  are the last path element
+
+
+## Ignition 0.29.0 (30-Nov-2018)
+
+### Features
+
+- Add support for `?versionId` on `s3://` URLs
+
+### Changes
+
+- Mark the 2.3.0 config spec as stable
+- No longer accept configs with version 2.3.0-experimental
+- Create new 2.4.0-experimental config spec from 2.3.0
+
+### Bug fixes
+
+- Don't allow HTTPS connections to block on system entropy pool
+- Relabel `/var/home` and `/var/roothome` when SELinux is enabled
+- Fix race where files were relabeled after `systemd-sysctl.service`
+- Do not run `udevadm settle` after the disks stage if the disks stage did
+  nothing
+- Allow writing relative symlinks
+- Resolve absolute symlinks relative to specified filesystem instead of the
+  initramfs root
+- Report status to Packet as `running` instead of `succeeded`
+
+### Test changes
+
+- Fix race with `umount` when running blackbox tests
+
+
+## Ignition 0.28.0 (22-Aug-2018)
+
+### Features
+
+- Refactor blackbox tests to allow testing disks with 4k sectors
+
+### Bug fixes
+
+- Correctly detect disks with 4k sectors when scanning existing partitions
+- Fix race between HTTP backoff tests
+- Set the minimum config versions in tests to the actual minimum required
+- Relabel `/root` when SELinux relabeling is enabled
+
+
+## Ignition 0.27.0 (09-Aug-2018)
+
+### Features
+
+- Ignition is now built as a Position Independent Executable (PIE)
+- Blackbox tests now run against all spec versions (within the same major
+  version) greater than their minimum version
+- Ignition now reports its status when running on Packet
+- Add a compile-time flag to enable SELinux file relabeling after boot
+
+### Bug fixes
+
+- Directories specified in both base and appended configs are always
+  created with the permissions specified in the appended config
+- Call `chdir()` after `chroot()` to silence static checkers
+
+
+## Ignition 0.26.0 (11-June-2018)
+
+### Features
+
+- Support partition matching, specifying that a partition should not
+  exist, and recreating existing partitions
+- Fail blackbox tests when Ignition encounters critical-level logs
+
+### Bug fixes
+
+- Fix an issue in timeout logic causing http(s) requests to sometimes fail
+- Do not log non-critical errors with `CRITICAL` log level
+
+
+## Ignition 0.25.1 (22-May-2018)
+
+### Bug fixes
+
+- Fix an issue in timeout logic causing http(s) requests to sometimes fail
+
+
+## Ignition 0.24.1 (22-May-2018)
+
+### Bug fixes
+
+- Fix an issue in timeout logic causing http(s) requests to sometimes fail
+
+
+## Ignition 0.25.0 (17-May-2018)
+
+### Features
+
+ - Blackbox tests can now be run in parallel
+
+### Changes
+
+ - Remove Oracle Cloud Infrastructure support
+
+### Bug fixes
+
+ - No longer leave a stray file when appending to an existing file
+ - Fix multiple blackbox test validation errors
+ - Fix v1 config parsing to return `ErrUnknownVersion` if version is
+   unrecognized
+
+
+## Ignition 0.24.0 (06-Mar-2018)
+
+### Features
+
+- Warn when adding and enabling a systemd unit and there is no `Install`
+  section in the unit contents
+- Add highlights to reports generated by `Validate` functions on config
+  structs
+
+### Changes
+
+- Move a helper validation function to the `config/validate` package
+- Move unit validation helpers to `config/shared/validations`
+- Add common error types to `config/shared/errors`, refactor `config/v*` to
+  use these errors
+
+
+## Ignition 0.23.0 (12-Mar-2018)
+
+### Changes
+
+- Latest experimental package has been moved from `config/types` to
+  `config/v2_3_experimental`.
+- Each `config` package's `Parse` function will now transparently handle any
+  configs of a lesser version than itself (e.g. `config/v2_2` will handle a
+  2.0.0 config).
+- Validation in `config/v1` reworked to use `config/validate`.
+- Common error types from the `config` package moved to `config/errors`.
+
+
+## Ignition 0.22.0 (09-Feb-2018)
+
+### Changes
+
+- Mark the 2.2.0 config spec as stable
+- No longer accept configs with version 2.2.0-experimental
+- Create new 2.3.0-experimental config spec from 2.2.0
+
+
+## Ignition 0.21.0 (26-Jan-2018)
+
+### Features
+
+- Add support for networkd drop-ins
+- Add new program, `ignition-validate`, for validating Ignition configs
+- Add `overwrite` field to `files`, `directories`, and `links` sections for
+  deleting preexisting items at the node's path
+- Add `options` field to `raid` section for specifying arbitrary `mdadm`
+  options
+- Add `append` field to `files` section for appending to preexisting files
+- Add support for specifying additional certificate authorities to use when
+  fetching objects over HTTPS
+
+### Changes
+
+- Validate that partition labels don't contain colons, as `sgdisk` will
+  silently truncate the label
+- Remove `-validate` flag from Ignition that was introduced in 0.20.0
+- Warn when the mode for a file or directory is unset
+- Log retries of HTTP fetches at `info` loglevel so messages appear on console
+
+### Bug fixes
+
+- Fix issue where unspecified fields in an appended config could "unset"
+  fields specified in a config earlier in the chain
+- Use timeouts specified in a config when fetching other configs referenced
+  by it
+
+
+## Ignition 0.20.1 (12-Jan-2018)
+
+### Changes
+
+- Add support for fetching S3 objects from non-default AWS partitions when
+  running in one such partition
+
+
+## Ignition 0.20.0 (13-Dec-2017)
+
+### Features
+
+- Add `validate` flag for validating Ignition configs without running any
+  stages
+- Add support for reading user configs from initramfs
+
+### Changes
+
+- Move `update-ssh-keys` from dependency into internal library
+- Move constants such as paths for invoked binaries into dedicated package
+  to allow for easy overriding at link time
+- Read base and default configs from initramfs instead of hardcoding them
+- Use the golang DNS resolver instead of the default glibc DNS resolver
+
+
+## Ignition 0.19.0 (22-Sep-2017)
+
+### Features
+
+- Add support for CloudStack network metadata
+- Add blackbox tests for TFTP URLs
+- Remove dependency on `kpartx` for blackbox tests
+
+### Changes
+
+- Stop adding extra quotes around GECOS field when creating users
+
+### Bug fixes
+
+- Fix regression in validation logic causing inaccurate line and column
+  reporting
+- Fix regression in validation logic where JSON syntax errors were not
+  reported correctly
+- Add warning if a non-existent filesystem is specified when creating links
+  and directories
+- Fix udev race causing systemd units depending on the Ignition disks stage and
+  a device unit to fail when no filesystems are created
+- Fix udev race where symlinks are deleted before Ignition can create its own
+  copy
+
+
+## Ignition 0.18.0 (08-Sep-2017)
+
+### Features
+
+- On VMWare allow guest variables to override values specified in the OVF
+  environment
+- Add partial support for CloudStack
+- Add blackbox tests
+- Add support for Oracle OCI provider
+
+### Changes
+
+- Chmod pre-existing directories to match defined permissions in config
+- Chown pre-existing links to match defined owner in config
+- Add `--homehost any` arguments to `mdadm` raid creation to ensure consistent
+  device name under `/dev/md`
+- On GCE, don't bind-mount `docker` binary into Google Cloud SDK container
+- On GCE, remove `gcutil` alias
+
+### Bug fixes
+
+- Properly error out when a user or group set by name in the config cannot
+  be resolved to an id
+- Fix typo in `gcloud` alias preventing connection to the docker daemon in
+  some cases
+- Fix partition number validation where multiple partitions on a disk were
+  unable to specify 0 for the next available partition number
+
+
+## Ignition 0.17.2 (28-Jul-2017)
+
+### Bug fixes
+
+- Fix failure to create files/directories/links on correct filesystem
+- Fix failure to force filesystem creation when legacy `force` flag was set
+- Prevent VFAT filesystem creation from unconditionally overwriting existing
+  filesystem
+- Fix deprecation warning on `enable` field in OEM systemd units
+- Fix failure where hard link targets would be on incorrect filesystem,
+  causing creation to fail
+- Fix incorrect filesystem UUID check when deciding whether to reuse
+  existing filesystem, causing Ignition to fail
+
+
+## Ignition 0.17.1 (05-Jul-2017)
+
+### Bug fixes
+
+- Fix failure when user data was not provided on EC2 and GCE
+- Fix failure to fetch user data on packet.net
+
+
+## Ignition 0.17.0 (30-Jun-2017)
+
+### Features
+
+- Add support for S3 fetching and IAM role credential use in EC2
+- Add `enabled` flag to services to allow disabling services
+- Add new `vagrant-virtualbox` oem
+
+### Changes
+
+- Mark 2.1.0 as stable
+- No longer accept 2.1.0-experimental configs
+- Create new 2.2.0-experimental spec from 2.1.0
+
+### Bug fixes
+
+- Mask `user-configdrive.service` and `user-configvirtfs.service` on
+  `brightbox` and `openstack` to prevent cloudinit from running a second time
+- Use value given in `root` flag everywhere, instead of hard coding `/sysroot`
+
+
+## Ignition 0.16.0 (16-Jun-2017)
+
+### Experimental (2.1.0-experimental)
+
+- Fix TFTP URL validation
+- Fix nil pointer dereference when uid or gid for a file is unspecified
+- Add support for VFAT filesystem creation
+- Fix `raid` device validation
+
+### Changes
+
+- Validate length of filesystem labels
+- Remove all OEM etcd v0 drop-in units
+- Remove `xendom0` OEM
+
+### Features
+
+- Add support for VMware's OVF environment
+- Add support for VirtualBox OEM
+
+
+## Ignition 0.15.0 (23-May-2017)
+
+### Experimental (2.1.0-experimental)
+
+- Define the Ignition Config schema in a JSON Schema file. Generate golang
+  structs from this file
+- Add partition GUID to the filesystem object, create or modify the
+  partition as appropriate
+- Add support for `swap` filesystems
+- Add support for links, both symbolic and hard
+- Deprecate the user level `create` object, add relevant fields directly to
+  the user object
+- Add support for referencing users and groups by name when creating files,
+  directories, and links
+- Deprecate the filesystem level `create` object, add relevant fields directly
+  to the filesystem object
+- Add support for reusing existing filesystems, toggled via the new
+  `wipeFilesystem` field in the filesystem object
+- Add filesystem UUID and label to the filesystem object
+- Correctly handle timeouts, instead of ignoring timeout settings in the
+  Ignition config
+
+### Bug fixes
+
+- Fix file path validation on Windows
+- On Brightbox correctly fetch the config, instead of failing with a noop
+- Fix a race with udev events which could cause filesystem creation to fail
+
+### Changes
+
+- Modify existing users, instead of attempting to create them
+
+### Features
+
+- Support for TFTP URLs
+
+
+## Ignition 0.14.0 (13-Mar-2017)
+
+### Changes
+
+- Update the services for the Azure OEM
+- Update the services for the BrightBox OEM
+- Update the services for the EC2 OEM
+- Update the services for the OpenStack OEM
+- Update the services for the Packet OEM
+- Update the services for the VMware OEM
+
+
+## Ignition 0.13.0 (01-Mar-2017)
+
+### Bug fixes
+
+- Read from both the config-drive and metadata service when using the
+  OpenStack provider
+- Properly reports errors encountered while creating files
+- Fix GCE `gcloud` alias to properly invoke the container
+
+### Features
+
+- Add support for experimental features via a newer config spec
+- Allow file provider's config path to be overridden
+- Perform basic syntactic validation on the contents of systemd units
+
+### Experimental (2.1.0-experimental)
+
+- Add ability to explicitly create directories
+- Add configuration for HTTP-related timeouts
+
+
+## Ignition 0.12.1 (14-Dec-2016)
+
+### Bug fixes
+
+- Enable `coreos-metadata-sshkeys` on Packet
+- Assert validity of `data` URLs during config validation
+
+
+## Ignition 0.12.0 (29-Nov-2016)
+
+### Features
+
+- Allow kernel command-line parameter to override OEM config
+
+
+## Ignition 0.11.2 (07-Oct-2016)
+
+### Bug fixes
+
+- Correctly set the partition typecode
+
+### Changes
+
+- Update the services for the GCE OEM
+
+
+## Ignition 0.11.1 (20-Sep-2016)
+
+### Bug fixes
+
+- Fix potential deadlock when waiting for multiple disks
+
+
+## Ignition 0.11.0 (07-Sep-2016)
+
+### Features
+
+- Add support for DigitalOcean
+- Add experimental support for OpenStack
+
+
+## Ignition 0.10.1 (26-Aug-2016)
+
+### Bug fixes
+
+- Fix handling of `oem://` URLs
+- Use stable symlinks when operating on devices
+- Retry failed requests when fetching Packet userdata
+- Log the raw configurations instead of the parsed result
+
+
+## Ignition 0.10.0 (23-Aug-2016)
+
+### Features
+
+- Add support for QEMU Firmware Configuration Device
+
+
+## Ignition 0.9.2 (15-Aug-2016)
+
+### Bug fixes
+
+- Do not retry HTTP requests that result in non-5xx status codes
+
+
+## Ignition 0.9.1 (11-Aug-2016)
+
+### Bug fixes
+
+- Properly validate `data` URLs
+
+
+## Ignition 0.9.0 (11-Aug-2016)
+
+### Features
+
+- Add detailed configuration validation
+
+### Bug fixes
+
+- Add retry to all HTTP requests
+- Fix potential panic when parsing certain URLs
+
+
+## Ignition 0.8.0 (26-Jul-2016)
+
+### Features
+
+- Add support for Packet
+
+
+## Ignition 0.7.1 (13-Jul-2016)
+
+### Bug fixes
+
+- Interpret files without a URL to be empty instead of invalid
+- HTTP fetches time out while waiting for response header instead of body
+- Stream remote assets to disk instead of loading them into memory
+
+### Changes
+
+- Improve configuration validation
+
+
+## Ignition 0.7.0 (15-Jun-2016)
+
+### Features
+
+- Allow HTTPS URLs
+
+### Bug fixes
+
+- Don't overwrite existing data when formatting `ext4` unless `force` is set
+- Ensure service unit in `/etc` doesn't exist before masking
+- Capture and log stdout of subprocesses
+
+### Changes
+
+- Drop YAML tags from the config package
+
+
+## Ignition 0.6.0 (18-May-2016)
+
+### Features
+
+- All URL schemes (currently `http`, `oem`, and `data`) are now supported
+  everywhere a URL can be provided
+- Add base OEM and default user configurations for GCE
+
+
+## Ignition 0.5.0 (04-May-2016)
+
+### Features
+
+- Add support for GCE
+
+### Bug fixes
+
+- Write files after users and home directories are created
+
+### Changes
+
+- Strip support for EC2 SSH keys (these are handled by coreos-metadata now)
+- Add OEM-specific base configs and execute even if user config is empty
+
+
+## Ignition 0.4.0 (05-Apr-2016)
+
+### Features
+
+- Update the config spec to v2.0.0 (see the migration guide for more info)
+  - v1 configs will be automatically translated to v2.0.0
+- Add HTTP `User-Agent` and `Accept` headers to all requests
+
+### Changes
+
+- Use Go's vendor directory for all dependencies
+- Split source into a public `config` package and `internal`
+
+
+## Ignition 0.3.3 (25-Mar-2016)
+
+### Bug fixes
+
+- Fix compilation errors when building for ARM
+- Properly fetch configs from EC2
+
+
+## Ignition 0.3.2 (17-Mar-2016)
+
+### Bug fixes
+
+- Properly decode VMware guest variables before parsing config
+
+### Changes
+
+- Move config structures from `config` package to `config/types`
+
+
+## Ignition 0.3.1 (02-Mar-2016)
+
+### Bug fixes
+
+- Allow building on non-AMD64 architectures
+
+### Changes
+
+- Major refactoring of the internal processing of OEMs and providers
+
+
+## Ignition 0.3.0 (24-Feb-2016)
+
+### Features
+
+- Add support for VMware
+
+
+## Ignition 0.2.6 (13-Jan-2016)
+
+### Features
+
+- Improve validation of `storage.filesystems` options
+
+### Bug fixes
+
+- Properly zap GPT tables when they are partially valid
+
+
+## Ignition 0.2.5 (06-Jan-2016)
+
+### Bug fixes
+
+- Recognize and ignore gzipped cloud-configs
+
+
+## Ignition 0.2.4 (19-Nov-2015)
+
+### Bug fixes
+
+- Correctly escape device unit names
+
+
+## Ignition 0.2.3 (17-Nov-2015)
+
+### Features
+
+- Provide logging to pinpoint JSON errors in invalid configs
+
+### Bug fixes
+
+- Ensure that `/mnt/oem` exists before mounting
+- Remove `/sysroot/` prefix from alternate config path
+
+
+## Ignition 0.2.2 (20-Oct-2015)
+
+### Bug fixes
+
+- Mount the oem partition for `oem://` schemes when needed
+
+
+## Ignition 0.2.1 (15-Oct-2015)
+
+### Bug fixes
+
+- Allow empty CustomData on Azure
+
+
+## Ignition 0.2.0 (29-Sep-2015)
+
+### Features
+
+- Added support for Azure
+- Added support for formatting partitions as `xfs`
+
+### Bug fixes
+
+- Removed online timeout for EC2
+
+
+## Ignition 0.1.6 (09-Sep-2015)
+
+### Features
+
+- `--fetchtimeout` becomes `--online-timeout`
+- `--online-timeout` of 0 now represents infinity
+- Added recognition of `interoute` OEM
+
+### Documentation
+
+- Examples have been removed and supported platforms added
+- Various minor cleanups
+
+### Bug fixes
+
+- Ensure added SSH keys are newline terminated
+
+### Build system changes
+
+- Fix `gofmt` invocation from test script to fail when appropriate
+
+
+## Ignition 0.1.5 (28-Aug-2015)
+
+### Bug fixes
+
+- Disable EC2 provider for now
+
+
+## Ignition 0.1.4 (27-Aug-2015)
+
+### Features
+
+- Add support for `oem://` scheme config urls
+
+### Documentation
+
+- Added guides
+- Updated config specification
+
+### Bug fixes
+
+- Add `DefaultDependencies=false` to `WaitOnDevices()` transient unit
+- Updated JSON configuration keys to match style
+
+### Build system changes
+
+- Added script for tagging releases
+
+
+## Ignition 0.1.3 (11-Aug-2015)
+
+### Features
+
+- Add support for ssh keys on EC2
+- Log version at runtime
+
+### Bug fixes
+
+- Log ssh keys as they are added
+- Various small cleanups
+
+### Build system changes
+
+- Derive version from `git describe` at build time
+- Use `bash` build and test scripts instead of `make`
+
+
+## Ignition 0.1.2 (22-Jul-2015)
+
+### Bug fixes
+
+- Fix validation of drop-in names
+- Properly handle a lack of userdata on EC2
+
+
+## Ignition 0.1.1 (22-Jul-2015)
+
+### Bug fixes
+
+- Ignore empty configs
+- Ignore unsupported CoreOS OEMs
+- Panic on incorrect OEM flag configurations
+
+
+## Ignition 0.1.0 (14-Jul-2015)
+
+### Features
+
+- Initial release of Ignition!
+- Support for disk partitioning, partition formatting, writing files,
+  RAID, systemd units, networkd units, users, and groups.
+- Supports reading the config from a remote URL (via
+  `config.coreos.url`) or from the Amazon EC2 metadata service.
diff --git a/docs/specs.md b/docs/specs.md
index 5bad4a65..43b1a799 100644
--- a/docs/specs.md
+++ b/docs/specs.md
@@ -19,6 +19,7 @@ We recommend that you always use the latest **stable** specification to benefit
 from new features and bug fixes. The following **stable** specification
 versions are currently supported in Ignition:
 
+- [v3.4.0](configuration-v3_4.md)
 - [v3.3.0](configuration-v3_3.md)
 - [v3.2.0](configuration-v3_2.md)
 - [v3.1.0](configuration-v3_1.md)
@@ -31,7 +32,7 @@ and testing** as it is subject to change **without warning or announcement**.
 The following **experimental** specification version is currently available in
 Ignition:
 
-- [v3.4.0-experimental](configuration-v3_4_experimental.md)
+- [v3.5.0-experimental](configuration-v3_5_experimental.md)
 
 ## Legacy spec 2.x configuration specifications
 
@@ -52,3 +53,4 @@ recommended to use the latest Ignition release.
 | 3.1.0        | 2.3.0            |
 | 3.2.0        | 2.7.0            |
 | 3.3.0        | 2.11.0           |
+| 3.4.0        | 2.15.0           |
diff --git a/docs/supported-platforms.md b/docs/supported-platforms.md
index 9ecb590a..f0318339 100644
--- a/docs/supported-platforms.md
+++ b/docs/supported-platforms.md
@@ -7,6 +7,7 @@ nav_order: 8
 Ignition is currently only supported for the following platforms:
 
 * [Alibaba Cloud] (`aliyun`) - Ignition will read its configuration from the instance userdata. Cloud SSH keys are handled separately.
+* [Apple Hypervisor] (`applehv`) - Ignition will read its configuration using an HTTP GET over a vsock connection with its host on port 1024.
 * [Amazon Web Services] (`aws`) - Ignition will read its configuration from the instance userdata. Cloud SSH keys are handled separately.
 * [Microsoft Azure] (`azure`)- Ignition will read its configuration from the custom data provided to the instance. Cloud SSH keys are handled separately.
 * [Microsoft Azure Stack] (`azurestack`) - Ignition will read its configuration from the custom data provided to the instance. Cloud SSH keys are handled separately.
@@ -15,6 +16,8 @@ Ignition is currently only supported for the following platforms:
 * [DigitalOcean] (`digitalocean`) - Ignition will read its configuration from the droplet userdata. Cloud SSH keys and network configuration are handled separately.
 * [Exoscale] (`exoscale`) - Ignition will read its configuration from the instance userdata. Cloud SSH keys are handled separately.
 * [Google Cloud] (`gcp`) - Ignition will read its configuration from the instance metadata entry named "user-data". Cloud SSH keys are handled separately.
+* [Hetzner Cloud] (`hetzner`) - Ignition will read its configuration from the instance userdata. Cloud SSH keys are handled separately.
+* [Microsoft Hyper-V] (`hyperv`) - Ignition will read its configuration from the `ignition.config` key in pool 0 of the Hyper-V Data Exchange Service (KVP). Values are limited to approximately 1 KiB of text, so Ignition can also read and concatenate multiple keys named `ignition.config.0`, `ignition.config.1`, and so on.
 * [IBM Cloud] (`ibmcloud`) - Ignition will read its configuration from the instance userdata. Cloud SSH keys are handled separately.
 * [KubeVirt] (`kubevirt`) - Ignition will read its configuration from the instance userdata via config drive. Cloud SSH keys are handled separately.
 * Bare Metal (`metal`) - Use the `ignition.config.url` kernel parameter to provide a URL to the configuration. The URL can use the `http://`, `https://`, `tftp://`, `s3://`, `arn:`, or `gs://` schemes to specify a remote config.
@@ -23,6 +26,7 @@ Ignition is currently only supported for the following platforms:
 * [Equinix Metal] (`packet`) - Ignition will read its configuration from the instance userdata. Cloud SSH keys are handled separately.
 * [IBM Power Systems Virtual Server] (`powervs`) - Ignition will read its configuration from the instance userdata. Cloud SSH keys are handled separately.
 * [QEMU] (`qemu`) - Ignition will read its configuration from the 'opt/com.coreos/config' key on the QEMU Firmware Configuration Device (available in QEMU 2.4.0 and higher).
+* [Scaleway] (`scaleway`) - Ignition will read its configuration from the instance userdata. Cloud SSH keys are handled separately.
 * [VirtualBox] (`virtualbox`) - Use the VirtualBox guest property `/Ignition/Config` to provide the config to the virtual machine.
 * [VMware] (`vmware`) - Use the VMware Guestinfo variables `ignition.config.data` and `ignition.config.data.encoding` to provide the config and its encoding to the virtual machine. Valid encodings are "", "base64", and "gzip+base64". Guestinfo variables can be provided directly or via an OVF environment, with priority given to variables specified directly.
 * [Vultr] (`vultr`) - Ignition will read its configuration from the instance userdata. Cloud SSH keys are handled separately.
@@ -33,6 +37,7 @@ Ignition is under active development, so this list may grow over time.
 For most cloud providers, cloud SSH keys and custom network configuration are handled by [Afterburn].
 
 [Alibaba Cloud]: https://www.alibabacloud.com/product/ecs
+[Apple Hypervisor]: https://developer.apple.com/documentation/hypervisor
 [Amazon Web Services]: https://aws.amazon.com/ec2/
 [Microsoft Azure]: https://azure.microsoft.com/en-us/services/virtual-machines/
 [Microsoft Azure Stack]: https://azure.microsoft.com/en-us/overview/azure-stack/
@@ -41,6 +46,8 @@ For most cloud providers, cloud SSH keys and custom network configuration are ha
 [DigitalOcean]: https://www.digitalocean.com/products/droplets/
 [Exoscale]: https://www.exoscale.com/compute/
 [Google Cloud]: https://cloud.google.com/compute
+[Hetzner Cloud]: https://www.hetzner.com/cloud
+[Microsoft Hyper-V]: https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/
 [IBM Cloud]: https://www.ibm.com/cloud/vpc
 [KubeVirt]: https://kubevirt.io
 [Nutanix]: https://www.nutanix.com/products/ahv
@@ -48,6 +55,7 @@ For most cloud providers, cloud SSH keys and custom network configuration are ha
 [Equinix Metal]: https://metal.equinix.com/product/
 [IBM Power Systems Virtual Server]: https://www.ibm.com/products/power-virtual-server
 [QEMU]: https://www.qemu.org/
+[Scaleway]: https://www.scaleway.com
 [VirtualBox]: https://www.virtualbox.org/
 [VMware]: https://www.vmware.com/
 [Vultr]: https://www.vultr.com/products/cloud-compute/
diff --git a/dracut/30ignition/ignition-disks.service b/dracut/30ignition/ignition-disks.service
index 9b225257..730063f1 100644
--- a/dracut/30ignition/ignition-disks.service
+++ b/dracut/30ignition/ignition-disks.service
@@ -32,4 +32,4 @@ After=systemd-udevd.service
 Type=oneshot
 RemainAfterExit=yes
 EnvironmentFile=/run/ignition.env
-ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=disks
+ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=disks ${IGNITION_ARGS}
diff --git a/dracut/30ignition/ignition-fetch-offline.service b/dracut/30ignition/ignition-fetch-offline.service
index 0d1284ab..c1920227 100644
--- a/dracut/30ignition/ignition-fetch-offline.service
+++ b/dracut/30ignition/ignition-fetch-offline.service
@@ -21,4 +21,4 @@ OnFailureJobMode=isolate
 Type=oneshot
 RemainAfterExit=yes
 EnvironmentFile=/run/ignition.env
-ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=fetch-offline
+ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=fetch-offline ${IGNITION_ARGS}
diff --git a/dracut/30ignition/ignition-fetch.service b/dracut/30ignition/ignition-fetch.service
index a61c3ad4..fb36f1af 100644
--- a/dracut/30ignition/ignition-fetch.service
+++ b/dracut/30ignition/ignition-fetch.service
@@ -25,4 +25,4 @@ After=network.target
 Type=oneshot
 RemainAfterExit=yes
 EnvironmentFile=/run/ignition.env
-ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=fetch
+ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=fetch ${IGNITION_ARGS}
diff --git a/dracut/30ignition/ignition-files.service b/dracut/30ignition/ignition-files.service
index c4d43ca0..f96aa16b 100644
--- a/dracut/30ignition/ignition-files.service
+++ b/dracut/30ignition/ignition-files.service
@@ -18,4 +18,4 @@ Before=initrd-parse-etc.service
 Type=oneshot
 RemainAfterExit=yes
 EnvironmentFile=/run/ignition.env
-ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=files --log-to-stdout
+ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=files ${IGNITION_ARGS}
diff --git a/dracut/30ignition/ignition-kargs.service b/dracut/30ignition/ignition-kargs.service
index 599fcc06..a704bb01 100644
--- a/dracut/30ignition/ignition-kargs.service
+++ b/dracut/30ignition/ignition-kargs.service
@@ -16,7 +16,7 @@ OnFailureJobMode=isolate
 Type=oneshot
 RemainAfterExit=yes
 EnvironmentFile=/run/ignition.env
-ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=kargs
+ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=kargs ${IGNITION_ARGS}
 # MountFlags=slave is so the umount of /boot is guaranteed to happen.
 # /boot will only be mounted for the lifetime of the unit.
 MountFlags=slave
diff --git a/dracut/30ignition/ignition-mount.service b/dracut/30ignition/ignition-mount.service
index cb0d6ff4..2800345f 100644
--- a/dracut/30ignition/ignition-mount.service
+++ b/dracut/30ignition/ignition-mount.service
@@ -29,5 +29,5 @@ After=ignition-remount-sysroot.service
 Type=oneshot
 RemainAfterExit=yes
 EnvironmentFile=/run/ignition.env
-ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=mount --log-to-stdout
-ExecStop=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=umount --log-to-stdout
+ExecStart=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=mount ${IGNITION_ARGS}
+ExecStop=/usr/bin/ignition --root=/sysroot --platform=${PLATFORM_ID} --stage=umount ${IGNITION_ARGS}
diff --git a/dracut/30ignition/module-setup.sh b/dracut/30ignition/module-setup.sh
index e30ceeed..51bec7e7 100755
--- a/dracut/30ignition/module-setup.sh
+++ b/dracut/30ignition/module-setup.sh
@@ -2,6 +2,13 @@
 # -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
 # ex: ts=8 sw=4 sts=4 et filetype=sh
 
+check() {
+    # Only include this if another module requests it.
+    # In our case it'll be the distro provided module with integration and customizations
+    # (coreos-ignition/ignition-microos/...).
+    return 255
+}
+
 depends() {
     echo qemu systemd url-lib network
 }
@@ -11,8 +18,9 @@ install_ignition_unit() {
     local target="${1:-ignition-complete.target}"; shift
     local instantiated="${1:-$unit}"; shift
     inst_simple "$moddir/$unit" "$systemdsystemunitdir/$unit"
-    mkdir -p "$initdir/$systemdsystemunitdir/$target.requires"
-    ln_r "../$unit" "$systemdsystemunitdir/$target.requires/$instantiated"
+    # note we `|| exit 1` here so we error out if e.g. the units are missing
+    # see https://github.com/coreos/fedora-coreos-config/issues/799
+    $SYSTEMCTL -q --root="$initdir" add-requires "$target" "$instantiated" || exit 1
 }
 
 install() {
@@ -47,7 +55,8 @@ install() {
         clevis-luks-common-functions \
         clevis-luks-unlock \
         pwmake \
-        tpm2_create
+        tpm2_create \
+        tpm2_createpolicy
 
     # Required by s390x's z/VM installation.
     # Supporting https://github.com/coreos/ignition/pull/865
@@ -94,3 +103,14 @@ install() {
     # needed for openstack config drive support
     inst_rules 60-cdrom_id.rules
 }
+
+installkernel() {
+     # required by hyperv platform to read kvp from the kernel
+     instmods hv_utils
+
+     # required by applehv platform to read ignition file through vsock
+     instmods -c vsock
+     instmods -c vmw_vsock_virtio_transport_common
+     instmods -c vmw_vsock_virtio_transport
+}
+
diff --git a/generate b/generate
index 0e4bb90a..15b780da 100755
--- a/generate
+++ b/generate
@@ -12,10 +12,18 @@ hash schematyper 2>/dev/null || {
     exit 1
 }
 
-specs="v3_0 v3_1 v3_2 v3_3 v3_4_experimental"
+specs="v3_0 v3_1 v3_2 v3_3 v3_4 v3_5_experimental"
 
 for spec in $specs
 do
-	echo "Generating schema..."
+	echo "Generating $spec schema..."
 	schematyper --package=types "config/${spec}/schema/ignition.json" -o "config/${spec}/types/schema.go" --root-type=Config
 done
+
+echo "Generating docs..."
+eval $(go env)
+if [ -z ${BIN_PATH+a} ]; then
+	export BIN_PATH=${PWD}/bin/${GOARCH}
+fi
+go build -o ${BIN_PATH}/doc internal/doc/main.go
+${BIN_PATH}/doc ${PWD}/docs
diff --git a/go.mod b/go.mod
index 06d80e65..f749e0d5 100644
--- a/go.mod
+++ b/go.mod
@@ -1,27 +1,65 @@
 module github.com/coreos/ignition/v2
 
-go 1.15
+go 1.20
 
 require (
-	cloud.google.com/go v0.58.0
-	cloud.google.com/go/storage v1.9.0
-	github.com/aws/aws-sdk-go v1.30.28
-	github.com/beevik/etree v1.1.1-0.20200718192613-4a2f8b9d084c
-	github.com/coreos/go-semver v0.3.0
-	github.com/coreos/go-systemd/v22 v22.0.0
-	github.com/coreos/vcontext v0.0.0-20211021162308-f1dbbca7bef4
-	github.com/google/renameio v0.1.0
-	github.com/google/uuid v1.1.1
+	cloud.google.com/go/compute/metadata v0.2.3
+	cloud.google.com/go/storage v1.38.0
+	github.com/aws/aws-sdk-go v1.50.25
+	github.com/beevik/etree v1.3.0
+	github.com/containers/libhvee v0.6.0
+	github.com/coreos/go-semver v0.3.1
+	github.com/coreos/go-systemd/v22 v22.5.0
+	github.com/coreos/vcontext v0.0.0-20230201181013-d72178a18687
+	github.com/google/renameio/v2 v2.0.0
+	github.com/google/uuid v1.6.0
+	github.com/mdlayher/vsock v1.2.1
+	github.com/mitchellh/copystructure v1.2.0
 	github.com/pin/tftp v2.1.0+incompatible
 	github.com/spf13/pflag v1.0.6-0.20210604193023-d5e0c0615ace
-	github.com/stretchr/testify v1.7.0
+	github.com/stretchr/testify v1.8.4
 	github.com/vincent-petithory/dataurl v1.0.0
 	github.com/vmware/vmw-guestinfo v0.0.0-20220317130741-510905f0efa3
-	go.opencensus.io v0.22.5 // indirect
-	golang.org/x/net v0.0.0-20200602114024-627f9648deb9
-	golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d
-	golang.org/x/sys v0.0.0-20200610111108-226ff32320da
-	golang.org/x/tools v0.0.0-20200610160956-3e83d1e96d0e // indirect
-	google.golang.org/api v0.26.0
-	google.golang.org/genproto v0.0.0-20200610104632-a5b850bcf112 // indirect
+	golang.org/x/net v0.21.0
+	golang.org/x/oauth2 v0.17.0
+	golang.org/x/sys v0.17.0
+	google.golang.org/api v0.167.0
+	gopkg.in/yaml.v3 v3.0.1
+)
+
+require (
+	cloud.google.com/go v0.112.0 // indirect
+	cloud.google.com/go/compute v1.23.4 // indirect
+	cloud.google.com/go/iam v1.1.6 // indirect
+	github.com/coreos/go-json v0.0.0-20230131223807-18775e0fb4fb // indirect
+	github.com/davecgh/go-spew v1.1.1 // indirect
+	github.com/felixge/httpsnoop v1.0.4 // indirect
+	github.com/go-logr/logr v1.4.1 // indirect
+	github.com/go-logr/stdr v1.2.2 // indirect
+	github.com/godbus/dbus/v5 v5.0.4 // indirect
+	github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect
+	github.com/golang/protobuf v1.5.3 // indirect
+	github.com/google/s2a-go v0.1.7 // indirect
+	github.com/googleapis/enterprise-certificate-proxy v0.3.2 // indirect
+	github.com/googleapis/gax-go/v2 v2.12.1 // indirect
+	github.com/jmespath/go-jmespath v0.4.0 // indirect
+	github.com/mdlayher/socket v0.4.1 // indirect
+	github.com/mitchellh/reflectwalk v1.0.2 // indirect
+	github.com/pmezard/go-difflib v1.0.0 // indirect
+	go.opencensus.io v0.24.0 // indirect
+	go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.48.0 // indirect
+	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.48.0 // indirect
+	go.opentelemetry.io/otel v1.23.0 // indirect
+	go.opentelemetry.io/otel/metric v1.23.0 // indirect
+	go.opentelemetry.io/otel/trace v1.23.0 // indirect
+	golang.org/x/crypto v0.19.0 // indirect
+	golang.org/x/sync v0.6.0 // indirect
+	golang.org/x/text v0.14.0 // indirect
+	golang.org/x/time v0.5.0 // indirect
+	google.golang.org/appengine v1.6.8 // indirect
+	google.golang.org/genproto v0.0.0-20240205150955-31a09d347014 // indirect
+	google.golang.org/genproto/googleapis/api v0.0.0-20240205150955-31a09d347014 // indirect
+	google.golang.org/genproto/googleapis/rpc v0.0.0-20240213162025-012b6fc9bca9 // indirect
+	google.golang.org/grpc v1.61.1 // indirect
+	google.golang.org/protobuf v1.32.0 // indirect
 )
diff --git a/go.sum b/go.sum
index 097b98c7..dac484dc 100644
--- a/go.sum
+++ b/go.sum
@@ -1,377 +1,215 @@
 cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
-cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
-cloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=
-cloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=
-cloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
-cloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=
-cloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=
-cloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=
-cloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=
-cloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=
-cloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=
-cloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=
-cloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=
-cloud.google.com/go v0.58.0 h1:vtAfVc723K3xKq1BQydk/FyCldnaNFhGhpJxaJzgRMQ=
-cloud.google.com/go v0.58.0/go.mod h1:W+9FnSUw6nhVwXlFcp1eL+krq5+HQUJeUogSeJZZiWg=
-cloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=
-cloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=
-cloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=
-cloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=
-cloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=
-cloud.google.com/go/bigquery v1.8.0 h1:PQcPefKFdaIzjQFbiyOgAqyx8q5djaE7x9Sqe712DPA=
-cloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=
-cloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=
-cloud.google.com/go/datastore v1.1.0 h1:/May9ojXjRkPBNVrq+oWLqmWCkr4OU5uRY29bu0mRyQ=
-cloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=
-cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=
-cloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=
-cloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=
-cloud.google.com/go/pubsub v1.3.1 h1:ukjixP1wl0LpnZ6LWtZJ0mX5tBmjp1f8Sqer8Z2OMUU=
-cloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=
-cloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=
-cloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=
-cloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=
-cloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=
-cloud.google.com/go/storage v1.9.0 h1:oXnZyBjHB6hC8TnSle0AWW6pGJ29EuSo5ww+SFmdNBg=
-cloud.google.com/go/storage v1.9.0/go.mod h1:m+/etGaqZbylxaNT876QGXqEHp4PR2Rq5GMqICWb9bU=
-dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=
-github.com/BurntSushi/toml v0.3.1 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ=
+cloud.google.com/go v0.112.0 h1:tpFCD7hpHFlQ8yPwT3x+QeXqc2T6+n6T+hmABHfDUSM=
+cloud.google.com/go v0.112.0/go.mod h1:3jEEVwZ/MHU4djK5t5RHuKOA/GbLddgTdVubX1qnPD4=
+cloud.google.com/go/compute v1.23.4 h1:EBT9Nw4q3zyE7G45Wvv3MzolIrCJEuHys5muLY0wvAw=
+cloud.google.com/go/compute v1.23.4/go.mod h1:/EJMj55asU6kAFnuZET8zqgwgJ9FvXWXOkkfQZa4ioI=
+cloud.google.com/go/compute/metadata v0.2.3 h1:mg4jlk7mCAj6xXp9UJ4fjI9VUI5rubuGBW5aJ7UnBMY=
+cloud.google.com/go/compute/metadata v0.2.3/go.mod h1:VAV5nSsACxMJvgaAuX6Pk2AawlZn8kiOGuCv6gTkwuA=
+cloud.google.com/go/iam v1.1.6 h1:bEa06k05IO4f4uJonbB5iAgKTPpABy1ayxaIZV/GHVc=
+cloud.google.com/go/iam v1.1.6/go.mod h1:O0zxdPeGBoFdWW3HWmBxJsk0pfvNM/p/qa82rWOGTwI=
+cloud.google.com/go/storage v1.38.0 h1:Az68ZRGlnNTpIBbLjSMIV2BDcwwXYlRlQzis0llkpJg=
+cloud.google.com/go/storage v1.38.0/go.mod h1:tlUADB0mAb9BgYls9lq+8MGkfzOXuLrnHXlpHmvFJoY=
 github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
-github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=
-github.com/aws/aws-sdk-go v1.30.28 h1:SaPM7dlmp7h3Lj1nJ4jdzOkTdom08+g20k7AU5heZYg=
-github.com/aws/aws-sdk-go v1.30.28/go.mod h1:5zCpMtNQVjRREroY7sYe8lOMRSxkhG6MZveU8YkpAk0=
-github.com/beevik/etree v1.1.1-0.20200718192613-4a2f8b9d084c h1:uYq6BD31fkfeNKQmfLj7ODcEfkb5JLsKrXVSqgnfGg8=
-github.com/beevik/etree v1.1.1-0.20200718192613-4a2f8b9d084c/go.mod h1:0yGO2rna3S9DkITDWHY1bMtcY4IJ4w+4S+EooZUR0bE=
+github.com/aws/aws-sdk-go v1.50.25 h1:vhiHtLYybv1Nhx3Kv18BBC6L0aPJHaG9aeEsr92W99c=
+github.com/aws/aws-sdk-go v1.50.25/go.mod h1:LF8svs817+Nz+DmiMQKTO3ubZ/6IaTpq3TjupRn3Eqk=
+github.com/beevik/etree v1.3.0 h1:hQTc+pylzIKDb23yYprodCWWTt+ojFfUZyzU09a/hmU=
+github.com/beevik/etree v1.3.0/go.mod h1:aiPf89g/1k3AShMVAzriilpcE4R/Vuor90y83zVZWFc=
 github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
-github.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=
-github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=
-github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=
 github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
 github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
-github.com/coreos/go-json v0.0.0-20211020211907-c63f628265de h1:qZvNu52Tv7Jfbgxdw3ONHf0BK9UpuSxi9FA9Y+qU5VU=
-github.com/coreos/go-json v0.0.0-20211020211907-c63f628265de/go.mod h1:lryFBkhadOfv8Jue2Vr/f/Yviw8h1DQPQojbXqEChY0=
-github.com/coreos/go-semver v0.3.0 h1:wkHLiw0WNATZnSG7epLsujiMCgPAc9xhjJ4tgnAxmfM=
-github.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
-github.com/coreos/go-systemd/v22 v22.0.0 h1:XJIw/+VlJ+87J+doOxznsAWIdmWuViOVhkQamW5YV28=
-github.com/coreos/go-systemd/v22 v22.0.0/go.mod h1:xO0FLkIi5MaZafQlIrOotqXZ90ih+1atmu1JpKERPPk=
-github.com/coreos/vcontext v0.0.0-20211021162308-f1dbbca7bef4 h1:pfSsrvbjUFGINaPGy0mm2QKQKTdq7IcbUa+nQwsz2UM=
-github.com/coreos/vcontext v0.0.0-20211021162308-f1dbbca7bef4/go.mod h1:HckqHnP/HI41vS0bfVjJ20u6jD0biI5+68QwZm5Xb9U=
-github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=
+github.com/cncf/xds/go v0.0.0-20231109132714-523115ebc101 h1:7To3pQ+pZo0i3dsWEbinPNFs5gPSBOsJtx3wTT94VBY=
+github.com/containers/libhvee v0.6.0 h1:tUzwSz8R0GjR6IctgDnkTMjdtCk5Mxhpai4Vyv6UeF4=
+github.com/containers/libhvee v0.6.0/go.mod h1:f/q1wCdQqOLiK3IZqqBfOD7exMZYBU5pDYsrMa/pSFg=
+github.com/coreos/go-json v0.0.0-20230131223807-18775e0fb4fb h1:rmqyI19j3Z/74bIRhuC59RB442rXUazKNueVpfJPxg4=
+github.com/coreos/go-json v0.0.0-20230131223807-18775e0fb4fb/go.mod h1:rcFZM3uxVvdyNmsAV2jopgPD1cs5SPWJWU5dOz2LUnw=
+github.com/coreos/go-semver v0.3.1 h1:yi21YpKnrx1gt5R+la8n5WgS0kCrsPp33dmEyHReZr4=
+github.com/coreos/go-semver v0.3.1/go.mod h1:irMmmIw/7yzSRPWryHsK7EYSg09caPQL03VsM8rvUec=
+github.com/coreos/go-systemd/v22 v22.5.0 h1:RrqgGjYQKalulkV8NGVIfkXQf6YYmOyiJKk8iXXhfZs=
+github.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=
+github.com/coreos/vcontext v0.0.0-20230201181013-d72178a18687 h1:uSmlDgJGbUB0bwQBcZomBTottKwEDF5fF8UjSwKSzWM=
+github.com/coreos/vcontext v0.0.0-20230201181013-d72178a18687/go.mod h1:Salmysdw7DAVuobBW/LwsKKgpyCPHUhjyJoMJD+ZJiI=
 github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
+github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
 github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
 github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
 github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
-github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=
-github.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
-github.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
-github.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=
-github.com/godbus/dbus/v5 v5.0.3 h1:ZqHaoEF7TBzh4jzPmqVhE/5A1z9of6orkAe5uHoAeME=
-github.com/godbus/dbus/v5 v5.0.3/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
+github.com/envoyproxy/protoc-gen-validate v1.0.2 h1:QkIBuU5k+x7/QXPvPPnWXWlCdaBFApVqftFV6k087DA=
+github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
+github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
+github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
+github.com/go-logr/logr v1.4.1 h1:pKouT5E8xu9zeFC39JXRDukb6JFQPXM5p5I91188VAQ=
+github.com/go-logr/logr v1.4.1/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
+github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
+github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
+github.com/godbus/dbus/v5 v5.0.4 h1:9349emZab16e7zQvpmsbtjc18ykshndd8y2PG3sgJbA=
+github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
 github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
-github.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
-github.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
-github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e h1:1r7pUrabqp18hOBcwBwiTsbnFeTZHV9eER/QT5JVZxY=
 github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
+github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=
+github.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
 github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
-github.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
-github.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=
-github.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
-github.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
-github.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
 github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
-github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
 github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
-github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
-github.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
-github.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=
 github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
 github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
 github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
 github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
 github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
 github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
-github.com/golang/protobuf v1.4.2 h1:+Z5KGCizgyZCbGh1KZqA0fcLLkwbsjIzS4aV2v7wJX0=
-github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
-github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
-github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
+github.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
+github.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=
+github.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
+github.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=
+github.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=
 github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
 github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
 github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
 github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
-github.com/google/go-cmp v0.4.1 h1:/exdXoGamhu5ONeUJH0deniYLWYvQwW66yvlfiiKTu0=
-github.com/google/go-cmp v0.4.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
-github.com/google/martian v2.1.0+incompatible h1:/CP5g8u/VJHijgedC/Legn3BAbAaWPgecwXBIDzw5no=
-github.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=
-github.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
-github.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
-github.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
-github.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
-github.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
-github.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
-github.com/google/pprof v0.0.0-20200507031123-427632fa3b1c/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
-github.com/google/renameio v0.1.0 h1:GOZbcHa3HfsPKPlmyPyN2KEohoMXOhdMbHrvbpl2QaA=
-github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
-github.com/google/uuid v1.1.1 h1:Gkbcsh/GbpXz7lPftLA3P6TYMwjCLYm83jiFQZF/3gY=
-github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
-github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=
-github.com/googleapis/gax-go/v2 v2.0.5 h1:sjZBwGj9Jlw33ImPtvFviGYvseOtDM7hkSKB7+Tv3SM=
-github.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=
-github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
-github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
-github.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
-github.com/jmespath/go-jmespath v0.3.0 h1:OS12ieG61fsCg5+qLJ+SsW9NicxNkg3b25OyT2yCeUc=
-github.com/jmespath/go-jmespath v0.3.0/go.mod h1:9QtRXoHjLGCJ5IBSaohpXITPlowMeeYCZ7fLUTSywik=
-github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=
-github.com/jstemmer/go-junit-report v0.9.1 h1:6QPYqodiu3GuPL+7mfx+NwDdp2eTkp9IfEUpgAwUN0o=
-github.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=
-github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
-github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
-github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
-github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
-github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
-github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
+github.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
+github.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
+github.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
+github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
+github.com/google/martian/v3 v3.3.2 h1:IqNFLAmvJOgVlpdEBiQbDc2EwKW77amAycfTuWKdfvw=
+github.com/google/renameio/v2 v2.0.0 h1:UifI23ZTGY8Tt29JbYFiuyIU3eX+RNFtUwefq9qAhxg=
+github.com/google/renameio/v2 v2.0.0/go.mod h1:BtmJXm5YlszgC+TD4HOEEUFgkJP3nLxehU6hfe7jRt4=
+github.com/google/s2a-go v0.1.7 h1:60BLSyTrOV4/haCDW4zb1guZItoSq8foHCXrAnjBo/o=
+github.com/google/s2a-go v0.1.7/go.mod h1:50CgR4k1jNlWBu4UfS4AcfhVe1r6pdZPygJ3R8F0Qdw=
+github.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
+github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
+github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
+github.com/googleapis/enterprise-certificate-proxy v0.3.2 h1:Vie5ybvEvT75RniqhfFxPRy3Bf7vr3h0cechB90XaQs=
+github.com/googleapis/enterprise-certificate-proxy v0.3.2/go.mod h1:VLSiSSBs/ksPL8kq3OBOQ6WRI2QnaFynd1DCjZ62+V0=
+github.com/googleapis/gax-go/v2 v2.12.1 h1:9F8GV9r9ztXyAi00gsMQHNoF51xPZm8uj1dpYt2ZETM=
+github.com/googleapis/gax-go/v2 v2.12.1/go.mod h1:61M8vcyyXR2kqKFxKrfA22jaA8JGF7Dc8App1U3H6jc=
+github.com/jmespath/go-jmespath v0.4.0 h1:BEgLn5cpjn8UN1mAw4NjwDrS35OdebyEtFe+9YPoQUg=
+github.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=
+github.com/jmespath/go-jmespath/internal/testify v1.5.1 h1:shLQSRRSCCPj3f2gpwzGwWFoC7ycTf1rcQZHOlsJ6N8=
+github.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=
+github.com/mdlayher/socket v0.4.1 h1:eM9y2/jlbs1M615oshPQOHZzj6R6wMT7bX5NPiQvn2U=
+github.com/mdlayher/socket v0.4.1/go.mod h1:cAqeGjoufqdxWkD7DkpyS+wcefOtmu5OQ8KuoJGIReA=
+github.com/mdlayher/vsock v1.2.1 h1:pC1mTJTvjo1r9n9fbm7S1j04rCgCzhCOS5DY0zqHlnQ=
+github.com/mdlayher/vsock v1.2.1/go.mod h1:NRfCibel++DgeMD8z/hP+PPTjlNJsdPOmxcnENvE+SE=
+github.com/mitchellh/copystructure v1.2.0 h1:vpKXTN4ewci03Vljg/q9QvCGUDttBOGBIa15WveJJGw=
+github.com/mitchellh/copystructure v1.2.0/go.mod h1:qLl+cE2AmVv+CoeAwDPye/v+N2HKCj9FbZEVFJRxO9s=
+github.com/mitchellh/reflectwalk v1.0.2 h1:G2LzWKi524PWgd3mLHV8Y5k7s6XUvT0Gef6zxSIeXaQ=
+github.com/mitchellh/reflectwalk v1.0.2/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=
 github.com/pin/tftp v2.1.0+incompatible h1:Yng4J7jv6lOc6IF4XoB5mnd3P7ZrF60XQq+my3FAMus=
 github.com/pin/tftp v2.1.0+incompatible/go.mod h1:xVpZOMCXTy+A5QMjEVN0Glwa1sUvaJhFXbr/aAxuxGY=
-github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
 github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
 github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
 github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
-github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
 github.com/spf13/pflag v1.0.6-0.20210604193023-d5e0c0615ace h1:9PNP1jnUjRhfmGMlkXHjYPishpcw4jpSt/V/xYY3FMA=
 github.com/spf13/pflag v1.0.6-0.20210604193023-d5e0c0615ace/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
 github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
-github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
-github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
-github.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=
-github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
+github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
+github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
+github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
+github.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=
+github.com/stretchr/testify v1.8.4 h1:CcVxjf3Q8PM0mHUKJCdn+eZZtm5yQwehR5yeSVQQcUk=
+github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
 github.com/vincent-petithory/dataurl v1.0.0 h1:cXw+kPto8NLuJtlMsI152irrVw9fRDX8AbShPRpg2CI=
 github.com/vincent-petithory/dataurl v1.0.0/go.mod h1:FHafX5vmDzyP+1CQATJn7WFKc9CvnvxyvZy6I1MrG/U=
 github.com/vmware/vmw-guestinfo v0.0.0-20220317130741-510905f0efa3 h1:v6jG/tdl4O07LNVp74Nt7/OyL+1JsIW1M2f/nSvQheY=
 github.com/vmware/vmw-guestinfo v0.0.0-20220317130741-510905f0efa3/go.mod h1:CSBTxrhePCm0cmXNKDGeu+6bOQzpaEklfCqEpn89JWk=
-github.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
-github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
-go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=
-go.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=
-go.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
-go.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
-go.opencensus.io v0.22.5 h1:dntmOdLpSpHlVqbW5Eay97DelsZHe+55D+xC6i0dDS0=
-go.opencensus.io v0.22.5/go.mod h1:5pWMHQbX5EPX2/62yrJeAkowc+lfs/XD7Uxpq3pI6kk=
+github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
+go.opencensus.io v0.24.0 h1:y73uSU6J157QMP2kn2r30vwW1A2W2WFwSCGnAVxeaD0=
+go.opencensus.io v0.24.0/go.mod h1:vNK8G9p7aAivkbmorf4v+7Hgx+Zs0yY+0fOtgBfjQKo=
+go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.48.0 h1:P+/g8GpuJGYbOp2tAdKrIPUX9JO02q8Q0YNlHolpibA=
+go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.48.0/go.mod h1:tIKj3DbO8N9Y2xo52og3irLsPI4GW02DSMtrVgNMgxg=
+go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.48.0 h1:doUP+ExOpH3spVTLS0FcWGLnQrPct/hD/bCPbDRUEAU=
+go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.48.0/go.mod h1:rdENBZMT2OE6Ne/KLwpiXudnAsbdrdBaqBvTN8M8BgA=
+go.opentelemetry.io/otel v1.23.0 h1:Df0pqjqExIywbMCMTxkAwzjLZtRf+bBKLbUcpxO2C9E=
+go.opentelemetry.io/otel v1.23.0/go.mod h1:YCycw9ZeKhcJFrb34iVSkyT0iczq/zYDtZYFufObyB0=
+go.opentelemetry.io/otel/metric v1.23.0 h1:pazkx7ss4LFVVYSxYew7L5I6qvLXHA0Ap2pwV+9Cnpo=
+go.opentelemetry.io/otel/metric v1.23.0/go.mod h1:MqUW2X2a6Q8RN96E2/nqNoT+z9BSms20Jb7Bbp+HiTo=
+go.opentelemetry.io/otel/sdk v1.21.0 h1:FTt8qirL1EysG6sTQRZ5TokkU8d0ugCj8htOgThZXQ8=
+go.opentelemetry.io/otel/trace v1.23.0 h1:37Ik5Ib7xfYVb4V1UtnT97T1jI+AoIYkJyPkuL4iJgI=
+go.opentelemetry.io/otel/trace v1.23.0/go.mod h1:GSGTbIClEsuZrGIzoEHqsVfxgn5UkggkflQwDScNUsk=
 golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
-golang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
-golang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
-golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
+golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
+golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
+golang.org/x/crypto v0.19.0 h1:ENy+Az/9Y1vSrlrvBSyna3PITt4tiZLf7sgCjZBX7Wo=
+golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=
 golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
-golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
-golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
-golang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=
-golang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=
-golang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
-golang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
-golang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
-golang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=
-golang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=
-golang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=
-golang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
 golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
 golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
-golang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
 golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
-golang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
-golang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
-golang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
-golang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=
-golang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
-golang.org/x/lint v0.0.0-20200302205851-738671d3881b h1:Wh+f8QHJXR411sJR8/vRBTZ7YapZaRvUcLFFJhusH0k=
-golang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
-golang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=
-golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=
-golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
-golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
-golang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
-golang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
-golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
-golang.org/x/mod v0.3.0 h1:RM4zey1++hCTbCVQfnWeKs9/IEsaBLA8vTkd0WVtmH4=
-golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
+golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
-golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
 golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
-golang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
-golang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
-golang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
 golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
-golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
-golang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
-golang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
-golang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
-golang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
-golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
-golang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
-golang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
-golang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
-golang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
-golang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
-golang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
-golang.org/x/net v0.0.0-20200602114024-627f9648deb9 h1:pNX+40auqi2JqRfOP1akLGtYcn15TUbkhwuCO3foqqM=
-golang.org/x/net v0.0.0-20200602114024-627f9648deb9/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
+golang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
+golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
+golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
+golang.org/x/net v0.21.0 h1:AQyQV4dYCvJ7vGmJyKki9+PBdyvhkSd8EIx/qb0AYv4=
+golang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=
 golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
-golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
-golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
-golang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
-golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d h1:TzXSXBo42m9gQenoE3b9BGiEpg5IG2JkU5FkPIawgtw=
-golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
+golang.org/x/oauth2 v0.17.0 h1:6m3ZPmLEFdVxKKWnKq4VqZ60gutO35zm+zrAHVmHyDQ=
+golang.org/x/oauth2 v0.17.0/go.mod h1:OzPDGQiuQMguemayvdylqddI7qcD9lnSDb+1FiwQ5HA=
 golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
-golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
-golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
-golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
-golang.org/x/sync v0.0.0-20200317015054-43a5402ce75a h1:WXEvlFVvvGxCJLG6REjsT03iWnKLEWinaScsxF2Vm2o=
-golang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sync v0.6.0 h1:5BMeUDZ7vkXGfEr1x9B4bRcTH4lpkTkpdh0T/J+qjbQ=
+golang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
 golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
-golang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/sys v0.0.0-20200610111108-226ff32320da h1:bGb80FudwxpeucJUjPYJXuJ8Hk91vNtfvrymzwiei38=
-golang.org/x/sys v0.0.0-20200610111108-226ff32320da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
-golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
+golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.17.0 h1:25cE3gD+tdBA7lp7QfhuV+rJiE9YXTcS3VG1SqssI/Y=
+golang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
+golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
+golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
-golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
-golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
-golang.org/x/text v0.3.3 h1:cokOdA+Jmi5PJGXLlLllQSgYigAEfHXJAERHVMaCc2k=
 golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
-golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
-golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
-golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
+golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
+golang.org/x/text v0.3.8/go.mod h1:E6s5w1FMmriuDzIBO73fBruAKo1PCIq6d2Q6DHfQ8WQ=
+golang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=
+golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
+golang.org/x/time v0.5.0 h1:o7cqy6amK/52YcAKIPlM3a+Fpj35zvRj2TP+e1xFSfk=
+golang.org/x/time v0.5.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=
 golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
 golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
 golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
 golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
-golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
-golang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
-golang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
-golang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
 golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
-golang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
-golang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
-golang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
-golang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
-golang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
-golang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
-golang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
-golang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
 golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
-golang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
-golang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
-golang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
-golang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
-golang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
-golang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=
-golang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
-golang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
-golang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
-golang.org/x/tools v0.0.0-20200601175630-2caf76543d99/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
-golang.org/x/tools v0.0.0-20200606014950-c42cb6316fb6/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
-golang.org/x/tools v0.0.0-20200610160956-3e83d1e96d0e h1:e4QHf+oWc6QYokfYSNYRbbyKYP01forNHSVGS06jJ54=
-golang.org/x/tools v0.0.0-20200610160956-3e83d1e96d0e/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
+golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
 golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
-golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
-golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543 h1:E7g+9GITq07hpfrRu66IVDexMakfv52eLZ2CXBWiKr4=
 golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
-google.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=
-google.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=
-google.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
-google.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
-google.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
-google.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
-google.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
-google.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
-google.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
-google.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
-google.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
-google.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
-google.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
-google.golang.org/api v0.26.0 h1:VJZ8h6E8ip82FRpQl848c5vAadxlTXrUh8RzQzSRm08=
-google.golang.org/api v0.26.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
+golang.org/x/xerrors v0.0.0-20231012003039-104605ab7028 h1:+cNy6SZtPcJQH3LJVLOSmiC7MMxXNOb3PU/VUEz+EhU=
+google.golang.org/api v0.167.0 h1:CKHrQD1BLRii6xdkatBDXyKzM0mkawt2QP+H3LtPmSE=
+google.golang.org/api v0.167.0/go.mod h1:4FcBc686KFi7QI/U51/2GKKevfZMpM17sCdibqe/bSA=
 google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
 google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
-google.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
-google.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=
-google.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
-google.golang.org/appengine v1.6.6 h1:lMO5rYAqUxkmaj76jAkRUvt5JZgFymx/+Q5Mzfivuhc=
-google.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
+google.golang.org/appengine v1.6.8 h1:IhEN5q69dyKagZPYMSdIjS2HqprW324FRQZJcGqPAsM=
+google.golang.org/appengine v1.6.8/go.mod h1:1jJ3jBArFh5pcgW8gCtRJnepW8FzD1V44FJffLiz/Ds=
 google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
-google.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
-google.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
-google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
-google.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
-google.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
 google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
-google.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=
-google.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
-google.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
-google.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
-google.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
-google.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
-google.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
-google.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=
-google.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
-google.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
-google.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
-google.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
-google.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
-google.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
-google.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
-google.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
-google.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=
 google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
-google.golang.org/genproto v0.0.0-20200603110839-e855014d5736/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
-google.golang.org/genproto v0.0.0-20200608115520-7c474a2e3482/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
-google.golang.org/genproto v0.0.0-20200610104632-a5b850bcf112 h1:iwoQI4kCHAgRg0oltV6+Jnq5COzoS0NN+QLqHewrf5U=
-google.golang.org/genproto v0.0.0-20200610104632-a5b850bcf112/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
+google.golang.org/genproto v0.0.0-20240205150955-31a09d347014 h1:g/4bk7P6TPMkAUbUhquq98xey1slwvuVJPosdBqYJlU=
+google.golang.org/genproto v0.0.0-20240205150955-31a09d347014/go.mod h1:xEgQu1e4stdSSsxPDK8Azkrk/ECl5HvdPf6nbZrTS5M=
+google.golang.org/genproto/googleapis/api v0.0.0-20240205150955-31a09d347014 h1:x9PwdEgd11LgK+orcck69WVRo7DezSO4VUMPI4xpc8A=
+google.golang.org/genproto/googleapis/api v0.0.0-20240205150955-31a09d347014/go.mod h1:rbHMSEDyoYX62nRVLOCc4Qt1HbsdytAYoVwgjiOhF3I=
+google.golang.org/genproto/googleapis/rpc v0.0.0-20240213162025-012b6fc9bca9 h1:hZB7eLIaYlW9qXRfCq/qDaPdbeY3757uARz5Vvfv+cY=
+google.golang.org/genproto/googleapis/rpc v0.0.0-20240213162025-012b6fc9bca9/go.mod h1:YUWgXUFRPfoYK1IHMuxH5K6nPEXSCzIMljnQ59lLRCk=
 google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
-google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=
-google.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=
 google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
 google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
-google.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
 google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
-google.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
-google.golang.org/grpc v1.28.0/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=
-google.golang.org/grpc v1.29.1 h1:EC2SB8S04d2r73uptxphDSUG+kTKVgjRPF+N3xpxRB4=
-google.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=
+google.golang.org/grpc v1.33.2/go.mod h1:JMHMWHQWaTccqQQlmk3MJZS+GWXOdAesneDmEnv2fbc=
+google.golang.org/grpc v1.61.1 h1:kLAiWrZs7YeDM6MumDe7m3y4aM6wacLzM1Y/wiLP9XY=
+google.golang.org/grpc v1.61.1/go.mod h1:VUbo7IFqmF1QtCAstipjG0GIoq49KvMe9+h1jFLBNJs=
 google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
 google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
 google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
@@ -380,25 +218,17 @@ google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzi
 google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
 google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
 google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
-google.golang.org/protobuf v1.24.0 h1:UhZDfRO8JRQru4/+LlLE0BRKGF8L+PICnvYZmx/fEGA=
-google.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=
+google.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=
+google.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=
+google.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=
+google.golang.org/protobuf v1.32.0 h1:pPC6BG5ex8PDFnkbrGU3EixyhKcQ2aDuBS36lqK/C7I=
+google.golang.org/protobuf v1.32.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
-gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=
-gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
-gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
-gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=
-gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
+gopkg.in/yaml.v2 v2.2.8 h1:obN1ZagJSUGI0Ek/LBmuj4SNLPfIny3KsKFopxRdj10=
+gopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
 gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
-gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b h1:h8qDotaEPuJATrMmW04NCwg7v22aHH28wwpauUhK9Oo=
-gopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
+gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
+gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
 honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
-honnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
-honnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
 honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
-honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=
-honnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
-honnef.co/go/tools v0.0.1-2020.1.4 h1:UoveltGrhghAA7ePc+e+QYDHXrBps2PqFZiHkGR/xK8=
-honnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
-rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=
-rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
-rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=
diff --git a/grub2/ignition.cfg b/grub2/ignition.cfg
new file mode 100644
index 00000000..8334b5c2
--- /dev/null
+++ b/grub2/ignition.cfg
@@ -0,0 +1,19 @@
+# This GRUB config snippet implements the `ignition.firstboot` semantic using a
+# stamp file in the bootfs. This is used at least on CoreOS-based systems where
+# it's injected by https://github.com/coreos/bootupd.
+
+# Determine if this is a first boot and set the ${ignition_firstboot} variable
+# which is used in the kernel command line.
+set ignition_firstboot=""
+if [ -f "/ignition.firstboot" ]; then
+    # Default networking parameters to be used with Ignition.
+    set ignition_network_kcmdline=''
+
+    # Source in the `ignition.firstboot` file which could override the
+    # above $ignition_network_kcmdline with static networking config.
+    # This override feature is also used by coreos-installer to persist static
+    # networking config provided during install to the first boot of the machine.
+    source "/ignition.firstboot"
+
+    set ignition_firstboot="ignition.firstboot ${ignition_network_kcmdline}"
+fi
diff --git a/internal/apply/apply.go b/internal/apply/apply.go
index d4ac38ff..33113c5c 100644
--- a/internal/apply/apply.go
+++ b/internal/apply/apply.go
@@ -34,7 +34,7 @@ import (
 	"github.com/coreos/ignition/v2/internal/state"
 	"github.com/coreos/ignition/v2/internal/util"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 )
 
 type Flags struct {
diff --git a/internal/doc/header.md b/internal/doc/header.md
new file mode 100644
index 00000000..86e835d4
--- /dev/null
+++ b/internal/doc/header.md
@@ -0,0 +1,18 @@
+---
+# This file is automatically generated from config/doc and internal/doc.
+# Do not edit.
+title: Config Spec v{{ .Version }}
+parent: Configuration specifications
+nav_order: {{ .NavOrder }}
+---
+
+# Configuration Specification v{{.Version}}
+
+{{ if .Version.PreRelease -}}
+_NOTE_: This pre-release version of the specification is experimental and is subject to change without notice or regard to backward compatibility.
+
+{{ end -}}
+The Ignition configuration is a JSON document conforming to the following specification, with **_italicized_** entries being optional:
+
+<div id="spec-docs"></div>
+
diff --git a/internal/doc/main.go b/internal/doc/main.go
new file mode 100644
index 00000000..ee9024c0
--- /dev/null
+++ b/internal/doc/main.go
@@ -0,0 +1,125 @@
+// Copyright 2023 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package main
+
+import (
+	_ "embed"
+	"errors"
+	"fmt"
+	"io/fs"
+	"os"
+	"path/filepath"
+	"text/template"
+
+	"github.com/coreos/go-semver/semver"
+
+	"github.com/coreos/ignition/v2/config/doc"
+	v30 "github.com/coreos/ignition/v2/config/v3_0/types"
+	v31 "github.com/coreos/ignition/v2/config/v3_1/types"
+	v32 "github.com/coreos/ignition/v2/config/v3_2/types"
+	v33 "github.com/coreos/ignition/v2/config/v3_3/types"
+	v34 "github.com/coreos/ignition/v2/config/v3_4/types"
+	v35 "github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+)
+
+var (
+	//go:embed header.md
+	headerRaw string
+	header    = template.Must(template.New("header").Parse(headerRaw))
+)
+
+func generate(dir string) error {
+	configs := []struct {
+		version string
+		config  any
+	}{
+		// generate in inverse order of website navbar
+		{"3.5.0-experimental", v35.Config{}},
+		{"3.0.0", v30.Config{}},
+		{"3.1.0", v31.Config{}},
+		{"3.2.0", v32.Config{}},
+		{"3.3.0", v33.Config{}},
+		{"3.4.0", v34.Config{}},
+	}
+
+	if err := os.MkdirAll(dir, 0755); err != nil {
+		return err
+	}
+
+	// parse input config
+	comps, err := doc.IgnitionComponents()
+	if err != nil {
+		return err
+	}
+
+	for i, c := range configs {
+		ver := *semver.New(c.version)
+
+		// clean up any previous experimental spec doc, for use
+		// during spec stabilization
+		experimentalPath := filepath.Join(dir, fmt.Sprintf("configuration-v%d_%d_experimental.md", ver.Major, ver.Minor))
+		if err := os.Remove(experimentalPath); err != nil && !errors.Is(err, fs.ErrNotExist) {
+			return err
+		}
+
+		// open file
+		var path string
+		switch ver.PreRelease {
+		case "":
+			path = filepath.Join(dir, fmt.Sprintf("configuration-v%d_%d.md", ver.Major, ver.Minor))
+		case "experimental":
+			path = experimentalPath
+		default:
+			panic(fmt.Errorf("unexpected prerelease: %v", ver.PreRelease))
+		}
+		f, err := os.OpenFile(path, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
+		if err != nil {
+			return err
+		}
+		defer f.Close()
+
+		// write header
+		args := struct {
+			Version  semver.Version
+			NavOrder int
+		}{
+			Version:  ver,
+			NavOrder: 50 - i,
+		}
+		if err := header.Execute(f, args); err != nil {
+			return fmt.Errorf("writing header for %s: %w", c.version, err)
+		}
+
+		// write docs
+		vers := doc.VariantVersions{
+			doc.IGNITION_VARIANT: ver,
+		}
+		if err := comps.Generate(vers, c.config, nil, f); err != nil {
+			return fmt.Errorf("generating doc for %s: %w", c.version, err)
+		}
+	}
+	return nil
+}
+
+func main() {
+	if len(os.Args) != 2 {
+		fmt.Fprintf(os.Stderr, "Usage: %s <directory>\n", os.Args[0])
+		os.Exit(1)
+	}
+	if err := generate(os.Args[1]); err != nil {
+		fmt.Fprintf(os.Stderr, "%s\n", err)
+		os.Exit(1)
+	}
+}
diff --git a/internal/exec/config_fetcher.go b/internal/exec/config_fetcher.go
index 6d1b8cab..388e1b2a 100644
--- a/internal/exec/config_fetcher.go
+++ b/internal/exec/config_fetcher.go
@@ -27,8 +27,8 @@ import (
 	"github.com/coreos/ignition/v2/internal/state"
 	"github.com/coreos/ignition/v2/internal/util"
 
-	latest "github.com/coreos/ignition/v2/config/v3_4_experimental"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	latest "github.com/coreos/ignition/v2/config/v3_5_experimental"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 )
 
 type ConfigFetcher struct {
diff --git a/internal/exec/engine.go b/internal/exec/engine.go
index efe5dba2..0ae8b985 100644
--- a/internal/exec/engine.go
+++ b/internal/exec/engine.go
@@ -17,7 +17,6 @@ package exec
 import (
 	"encoding/json"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"strconv"
 	"strings"
@@ -25,13 +24,12 @@ import (
 
 	"github.com/coreos/go-systemd/v22/journal"
 	"github.com/coreos/ignition/v2/config/shared/errors"
-	latest "github.com/coreos/ignition/v2/config/v3_4_experimental"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	latest "github.com/coreos/ignition/v2/config/v3_5_experimental"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
 	executil "github.com/coreos/ignition/v2/internal/exec/util"
 	"github.com/coreos/ignition/v2/internal/log"
 	"github.com/coreos/ignition/v2/internal/platform"
-	"github.com/coreos/ignition/v2/internal/providers"
 	"github.com/coreos/ignition/v2/internal/providers/cmdline"
 	"github.com/coreos/ignition/v2/internal/providers/system"
 	"github.com/coreos/ignition/v2/internal/resource"
@@ -39,7 +37,7 @@ import (
 
 	"github.com/coreos/vcontext/report"
 	"github.com/coreos/vcontext/validate"
-	"github.com/google/renameio"
+	"github.com/google/renameio/v2"
 )
 
 const (
@@ -78,7 +76,7 @@ func (e Engine) Run(stageName string) error {
 
 	systemBaseConfig, r, err := system.FetchBaseConfig(e.Logger, e.PlatformConfig.Name())
 	e.Logger.LogReport(r)
-	if err != nil && err != providers.ErrNoProvider {
+	if err != nil && err != platform.ErrNoProvider {
 		e.Logger.Crit("failed to acquire system base config: %v", err)
 		return err
 	} else if err == nil {
@@ -98,7 +96,7 @@ func (e Engine) Run(stageName string) error {
 	// Run the platform config's Init function pre-config fetch
 	// to perform any additional fetcher configuration  e.x.
 	// configuring the S3RegionHint when running on AWS.
-	err = e.PlatformConfig.InitFunc()(e.Fetcher)
+	err = e.PlatformConfig.Init(e.Fetcher)
 	if err == resource.ErrNeedNet && stageName == "fetch-offline" {
 		err = e.signalNeedNet()
 		if err != nil {
@@ -198,7 +196,7 @@ func (e *Engine) acquireConfig(stageName string) (cfg types.Config, err error) {
 // available
 func (e *Engine) acquireCachedConfig() (cfg types.Config, err error) {
 	var b []byte
-	b, err = ioutil.ReadFile(e.ConfigCache)
+	b, err = os.ReadFile(e.ConfigCache)
 	if err != nil {
 		return
 	}
@@ -288,25 +286,20 @@ func (e *Engine) acquireProviderConfig() (cfg types.Config, err error) {
 // is unavailable. This will also render the config (see renderConfig) before
 // returning.
 func (e *Engine) fetchProviderConfig() (types.Config, error) {
-	// note this is an array because iteration order is important; see comment
-	// block just above
-	fetchers := []struct {
-		name      string
-		fetchFunc providers.FuncFetchConfig
-	}{
-		{"cmdline", cmdline.FetchConfig},
-		{"system", system.FetchConfig},
-		{e.PlatformConfig.Name(), e.PlatformConfig.FetchFunc()},
+	platformConfigs := []platform.Config{
+		cmdline.Config,
+		system.Config,
+		e.PlatformConfig,
 	}
 	var cfg types.Config
 	var r report.Report
 	var err error
 	var providerKey string
-	for _, fetcher := range fetchers {
-		cfg, r, err = fetcher.fetchFunc(e.Fetcher)
-		if err != providers.ErrNoProvider {
+	for _, platformConfig := range platformConfigs {
+		cfg, r, err = platformConfig.Fetch(e.Fetcher, e.State)
+		if err != platform.ErrNoProvider {
 			// successful, or failed on another error
-			providerKey = fetcher.name
+			providerKey = platformConfig.Name()
 			break
 		}
 	}
diff --git a/internal/exec/stages/disks/disks.go b/internal/exec/stages/disks/disks.go
index 745fa19c..880fb3b6 100644
--- a/internal/exec/stages/disks/disks.go
+++ b/internal/exec/stages/disks/disks.go
@@ -19,11 +19,13 @@
 package disks
 
 import (
+	"context"
 	"errors"
 	"fmt"
 	"os/exec"
+	"path/filepath"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
 	"github.com/coreos/ignition/v2/internal/exec/util"
@@ -105,35 +107,39 @@ func (s stage) Run(config types.Config) error {
 		return fmt.Errorf("failed to create filesystems: %v", err)
 	}
 
-	// udevd registers an IN_CLOSE_WRITE inotify watch on block device
-	// nodes, and synthesizes udev "change" events when the watch fires.
-	// mkfs.btrfs triggers multiple such events, the first of which
-	// occurs while there is no recognizable filesystem on the
-	// partition. Thus, if an existing partition is reformatted as
-	// btrfs while keeping the same filesystem label, there will be a
-	// synthesized uevent that deletes the /dev/disk/by-label symlink
-	// and a second one that restores it. If we didn't account for this,
-	// a systemd unit that depended on the by-label symlink (e.g.
-	// systemd-fsck-root.service) could have the symlink deleted out
-	// from under it.
-	//
-	// There's no way to fix this completely. We can't wait for the
-	// restoring uevent to propagate, since we can't determine which
-	// specific uevents were triggered by the mkfs. We can wait for
-	// udev to settle, though it's conceivable that the deleting uevent
-	// has already been processed and the restoring uevent is still
-	// sitting in the inotify queue. In practice the uevent queue will
-	// be the slow one, so this should be good enough.
-	//
-	// Test case: boot failure in coreos.ignition.*.btrfsroot kola test.
-	//
-	// Additionally, partitioning (and possibly creating raid) suffers
-	// the same problem. To be safe, always settle.
-	if _, err := s.Logger.LogCmd(
-		exec.Command(distro.UdevadmCmd(), "settle"),
-		"waiting for udev to settle",
-	); err != nil {
-		return fmt.Errorf("udevadm settle failed: %v", err)
+	return nil
+}
+
+// waitForUdev triggers a tagged event and waits for it to bubble up
+// again. This ensures that udev processed the device changes.
+// The requirement is that the used device path exists and itself is
+// not recreated by udev seeing the changes done. Thus, resolve a
+// /dev/disk/by-something/X symlink before performing the device
+// changes (i.e., pass /run/ignition/dev_aliases/X) and, e.g., don't
+// call it for a partition but the full disk if you modified the
+// partition table.
+func (s stage) waitForUdev(dev string) error {
+	// Resolve the original /dev/ABC entry because udevadm wants
+	// this as argument instead of a symlink like
+	// /run/ignition/dev_aliases/X.
+	devPath, err := filepath.EvalSymlinks(dev)
+	if err != nil {
+		return fmt.Errorf("failed to resolve device alias %q: %v", dev, err)
+	}
+	// By triggering our own event and waiting for it we know that udev
+	// will have processed the device changes, a bare "udevadm settle"
+	// is prone to races with the inotify queue. We expect the /dev/DISK
+	// entry to exist because this function is either called for the full
+	// disk and only the /dev/DISKpX partition entries will change, or the
+	// function is called for a partition where the contents changed and
+	// nothing causes the kernel/udev to reread the partition table and
+	// recreate the /dev/DISKpX entries. If that was the case best we could
+	// do here is to add a retry loop (and relax the function comment).
+	_, err = s.Logger.LogCmd(
+		exec.Command(distro.UdevadmCmd(), "trigger", "--settle",
+			devPath), "waiting for triggered uevent")
+	if err != nil {
+		return fmt.Errorf("udevadm trigger failed: %v", err)
 	}
 
 	return nil
@@ -143,7 +149,7 @@ func (s stage) Run(config types.Config) error {
 // using ctxt for the logging and systemd unit identity.
 func (s stage) waitOnDevices(devs []string, ctxt string) error {
 	if err := s.LogOp(
-		func() error { return systemd.WaitOnDevices(devs, ctxt) },
+		func() error { return systemd.WaitOnDevices(context.Background(), devs, ctxt) },
 		"waiting for devices %v", devs,
 	); err != nil {
 		return fmt.Errorf("failed to wait on %s devs: %v", ctxt, err)
diff --git a/internal/exec/stages/disks/filesystems.go b/internal/exec/stages/disks/filesystems.go
index 0c5eeff1..d33c1153 100644
--- a/internal/exec/stages/disks/filesystems.go
+++ b/internal/exec/stages/disks/filesystems.go
@@ -26,7 +26,7 @@ import (
 	"strings"
 
 	cutil "github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/exec/util"
 )
@@ -210,6 +210,29 @@ func (s stage) createFilesystem(fs types.Filesystem) error {
 		return fmt.Errorf("mkfs failed: %v", err)
 	}
 
+	// udevd registers an IN_CLOSE_WRITE inotify watch on block device
+	// nodes, and synthesizes udev "change" events when the watch fires.
+	// mkfs.btrfs triggers multiple such events, the first of which
+	// occurs while there is no recognizable filesystem on the
+	// partition. Thus, if an existing partition is reformatted as
+	// btrfs while keeping the same filesystem label, there will be a
+	// synthesized uevent that deletes the /dev/disk/by-label symlink
+	// and a second one that restores it. If we didn't account for this,
+	// a systemd unit that depended on the by-label symlink (e.g.
+	// systemd-fsck-root.service) could have the symlink deleted out
+	// from under it.
+	// Trigger a tagged uevent and wait for it because a bare "udevadm
+	// settle" does not guarantee that all changes were processed
+	// because it's conceivable that only the deleting uevent has
+	// already been processed (or none!) while the restoring uevent
+	// is still sitting in the inotify queue. By triggering our own
+	// event and waiting for it we know that udev will have processed
+	// the device changes.
+	// Test case: boot failure in coreos.ignition.*.btrfsroot kola test.
+	if err := s.waitForUdev(devAlias); err != nil {
+		return fmt.Errorf("failed to wait for udev on %q after formatting: %v", devAlias, err)
+	}
+
 	return nil
 }
 
diff --git a/internal/exec/stages/disks/luks.go b/internal/exec/stages/disks/luks.go
index 5fa15e70..5117234e 100644
--- a/internal/exec/stages/disks/luks.go
+++ b/internal/exec/stages/disks/luks.go
@@ -20,7 +20,6 @@ import (
 	"encoding/json"
 	"errors"
 	"fmt"
-	"io/ioutil"
 	"net/url"
 	"os"
 	"os/exec"
@@ -28,9 +27,10 @@ import (
 	"strings"
 
 	"github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	execUtil "github.com/coreos/ignition/v2/internal/exec/util"
+	"github.com/coreos/ignition/v2/internal/log"
 	"github.com/coreos/ignition/v2/internal/resource"
 
 	"github.com/vincent-petithory/dataurl"
@@ -42,8 +42,9 @@ var (
 
 // https://github.com/latchset/clevis/blob/master/src/pins/tang/clevis-encrypt-tang.1.adoc#config
 type Tang struct {
-	URL        string `json:"url"`
-	Thumbprint string `json:"thp,omitempty"`
+	URL           string `json:"url"`
+	Thumbprint    string `json:"thp,omitempty"`
+	Advertisement any    `json:"adv,omitempty"`
 }
 
 // https://github.com/latchset/clevis/blob/master/README.md#pin-shamir-secret-sharing
@@ -115,7 +116,7 @@ func (s *stage) createLuks(config types.Config) error {
 		// so that it can be removed
 		var ignitionCreatedKeyFile bool
 		// create keyfile, remove on the way out
-		keyFile, err := ioutil.TempFile("", "ignition-luks-")
+		keyFile, err := os.CreateTemp("", "ignition-luks-")
 		if err != nil {
 			return fmt.Errorf("creating keyfile: %w", err)
 		}
@@ -129,7 +130,7 @@ func (s *stage) createLuks(config types.Config) error {
 			if err != nil {
 				return fmt.Errorf("generating keyfile: %v", err)
 			}
-			if err := ioutil.WriteFile(keyFilePath, []byte(key), 0400); err != nil {
+			if err := os.WriteFile(keyFilePath, []byte(key), 0400); err != nil {
 				return fmt.Errorf("creating keyfile: %v", err)
 			}
 			ignitionCreatedKeyFile = true
@@ -158,7 +159,7 @@ func (s *stage) createLuks(config types.Config) error {
 		}
 		// store the key to be persisted into the real root
 		// do this here so device reuse works correctly
-		key, err := ioutil.ReadFile(keyFilePath)
+		key, err := os.ReadFile(keyFilePath)
 		if err != nil {
 			return fmt.Errorf("failed to read keyfile %q: %w", keyFilePath, err)
 		}
@@ -168,7 +169,11 @@ func (s *stage) createLuks(config types.Config) error {
 			// If the volume isn't forcefully being created, then we need
 			// to check if it is of the correct type or that no volume exists.
 
-			if s.isLuksDevice(*luks.Device) {
+			isLuks, err := s.isLuksDevice(*luks.Device)
+			if err != nil {
+				return err
+			}
+			if isLuks {
 				// try to reuse the LUKS device; device will be opened
 				// if successful.
 				if err := s.reuseLuksDevice(luks, keyFilePath); err != nil {
@@ -182,7 +187,7 @@ func (s *stage) createLuks(config types.Config) error {
 			}
 
 			var info execUtil.FilesystemInfo
-			err := s.Logger.LogOp(
+			err = s.Logger.LogOp(
 				func() error {
 					var err error
 					info, err = execUtil.GetFilesystemInfo(devAlias, false)
@@ -251,7 +256,7 @@ func (s *stage) createLuks(config types.Config) error {
 
 		// open the device
 		if _, err := s.Logger.LogCmd(
-			exec.Command(distro.CryptsetupCmd(), "luksOpen", devAlias, luks.Name, "--key-file", keyFilePath),
+			exec.Command(distro.CryptsetupCmd(), luksOpenArgs(luks, keyFilePath)...),
 			"opening luks device %v", luks.Name,
 		); err != nil {
 			return fmt.Errorf("opening luks device: %v", err)
@@ -274,9 +279,17 @@ func (s *stage) createLuks(config types.Config) error {
 					c.Threshold = *luks.Clevis.Threshold
 				}
 				for _, tang := range luks.Clevis.Tang {
+					var adv any
+					if tang.Advertisement != nil {
+						err := json.Unmarshal([]byte(*tang.Advertisement), &adv)
+						if err != nil {
+							return fmt.Errorf("unmarshalling advertisement: %v", err)
+						}
+					}
 					c.Pins.Tang = append(c.Pins.Tang, Tang{
-						URL:        tang.URL,
-						Thumbprint: *tang.Thumbprint,
+						URL:           tang.URL,
+						Thumbprint:    *tang.Thumbprint,
+						Advertisement: adv,
 					})
 				}
 				if luks.Clevis.Tpm2 != nil {
@@ -295,36 +308,53 @@ func (s *stage) createLuks(config types.Config) error {
 			// pass the device to clevis. We have to loop each device as
 			// the devices could be on different NICs that haven't come
 			// up yet.
+
+			// A running count of tang servers without an advertisement
+			tangServersWithoutAdv := 0
 			for _, tang := range luks.Clevis.Tang {
 				u, err := url.Parse(tang.URL)
 				if err != nil {
 					return fmt.Errorf("parsing tang URL: %v", err)
 				}
-				u.Path = path.Join(u.Path, "adv")
-				_, err = s.Fetcher.FetchToBuffer(*u, resource.FetchOptions{})
-				if err != nil {
-					return fmt.Errorf("fetching tang advertisement: %v", err)
+				if util.NilOrEmpty(tang.Advertisement) {
+					tangServersWithoutAdv++
+					u.Path = path.Join(u.Path, "adv")
+					_, err = s.Fetcher.FetchToBuffer(*u, resource.FetchOptions{})
+					if err != nil {
+						return fmt.Errorf("fetching tang advertisement: %v", err)
+					}
 				}
 			}
 
+			// lets bind our device
 			if _, err := s.Logger.LogCmd(
 				exec.Command(distro.ClevisCmd(), "luks", "bind", "-f", "-k", keyFilePath, "-d", devAlias, pin, config), "Clevis bind",
 			); err != nil {
 				return fmt.Errorf("binding clevis device: %v", err)
 			}
-
-			// close & re-open Clevis devices to make sure that we can unlock them
-			if _, err := s.Logger.LogCmd(
-				exec.Command(distro.CryptsetupCmd(), "luksClose", luks.Name),
-				"closing clevis luks device %v", luks.Name,
-			); err != nil {
-				return fmt.Errorf("closing luks device: %v", err)
+			intTpm2 := 0
+			if util.IsTrue(luks.Clevis.Tpm2) {
+				intTpm2 = 1
 			}
-			if _, err := s.Logger.LogCmd(
-				exec.Command(distro.ClevisCmd(), "luks", "unlock", "-d", devAlias, "-n", luks.Name),
-				"reopening clevis luks device %s", luks.Name,
-			); err != nil {
-				return fmt.Errorf("reopening luks device %s: %v", luks.Name, err)
+			threshold := 1
+			if luks.Clevis.Threshold != nil {
+				threshold = *luks.Clevis.Threshold
+			}
+			// Check if we can safely close and re-open the device
+			if tangServersWithoutAdv+intTpm2 >= threshold {
+				// close & re-open Clevis devices to make sure that we can unlock them
+				if _, err := s.Logger.LogCmd(
+					exec.Command(distro.CryptsetupCmd(), "luksClose", luks.Name),
+					"closing clevis luks device %v", luks.Name,
+				); err != nil {
+					return fmt.Errorf("closing luks device: %v", err)
+				}
+				if _, err := s.Logger.LogCmd(
+					exec.Command(distro.ClevisCmd(), "luks", "unlock", "-d", devAlias, "-n", luks.Name),
+					"reopening clevis luks device %s", luks.Name,
+				); err != nil {
+					return fmt.Errorf("reopening luks device %s: %v", luks.Name, err)
+				}
 			}
 		}
 
@@ -338,21 +368,60 @@ func (s *stage) createLuks(config types.Config) error {
 			}
 			delete(s.State.LuksPersistKeyFiles, luks.Name)
 		}
+
+		// It's best to wait here for the /dev/disk/by-*/X entries to be
+		// (re)created, not only for other parts of the initramfs but
+		// also because s.waitOnDevices() can still race with udev's
+		// disk entry recreation.
+		if err := s.waitForUdev(devAlias); err != nil {
+			return fmt.Errorf("failed to wait for udev on %q after LUKS: %v", devAlias, err)
+		}
 	}
 
 	return nil
 }
 
-func (s *stage) isLuksDevice(device string) bool {
-	devAlias := execUtil.DeviceAlias(device)
-	if _, err := s.Logger.LogCmd(
-		exec.Command(distro.CryptsetupCmd(), "isLuks", "--type", "luks2", devAlias),
-		"checking if %v is a luks device", device,
-	); err != nil {
-		// isLuks returns exit status 1 if the device is not LUKS
-		return false
+func (s *stage) isLuksDevice(device string) (bool, error) {
+	checkLuks := func(luks2 bool) (bool, error) {
+		ret := true
+		desc := "luks"
+		if luks2 {
+			desc = "luks2"
+		}
+		err := s.LogOp(func() error {
+			devAlias := execUtil.DeviceAlias(device)
+			cmd := exec.Command(distro.CryptsetupCmd(), "isLuks", devAlias)
+			if luks2 {
+				cmd.Args = append(cmd.Args, "--type", "luks2")
+			}
+			cmdLine := log.QuotedCmd(cmd)
+			s.Debug("executing: %s", cmdLine)
+
+			if err := cmd.Run(); err != nil {
+				if _, ok := err.(*exec.ExitError); ok {
+					ret = false
+				} else {
+					return fmt.Errorf("%w: Cmd: %s", err, cmdLine)
+				}
+			}
+			return nil
+		}, "checking if %v is a %v device", device, desc)
+		return ret, err
+	}
+
+	// check for luks2
+	isLuks, err := checkLuks(true)
+	if isLuks || err != nil {
+		return isLuks, err
+	}
+	// not luks2; check for luks1
+	isLuks, err = checkLuks(false)
+	if isLuks && err == nil {
+		// we can't reuse the volume but it is LUKS.
+		// fail to avoid data loss.
+		return false, fmt.Errorf("%v is a luks device but not luks2; Ignition cannot reuse it", device)
 	}
-	return true
+	return false, err
 }
 
 // Check LUKS device against config and open it.
@@ -392,12 +461,73 @@ func (s *stage) reuseLuksDevice(luks types.Luks, keyFilePath string) error {
 		}
 	}
 
+	dump, err := newLuksDump(devAlias)
+	if err != nil {
+		return err
+	}
+	if dump.hasFlag("allow-discards") != util.IsTrue(luks.Discard) {
+		return fmt.Errorf("volume allow-discards flag %v doesn't match expected value %v", dump.hasFlag("allow-discards"), util.IsTrue(luks.Discard))
+	}
+
 	// open the device to make sure the keyfile is valid
 	if _, err := s.Logger.LogCmd(
-		exec.Command(distro.CryptsetupCmd(), "luksOpen", devAlias, luks.Name, "--key-file", keyFilePath),
+		exec.Command(distro.CryptsetupCmd(), luksOpenArgs(luks, keyFilePath)...),
 		"opening luks device %v", luks.Name,
 	); err != nil {
 		return fmt.Errorf("failed to open device using specified keyfile")
 	}
 	return nil
 }
+
+func luksOpenArgs(luks types.Luks, keyFilePath string) []string {
+	ret := []string{
+		"luksOpen",
+		execUtil.DeviceAlias(*luks.Device),
+		luks.Name,
+		"--key-file",
+		keyFilePath,
+		// store presence/absence of --allow-discards and open options
+		"--persistent",
+	}
+	if util.IsTrue(luks.Discard) {
+		// clevis luks unlock doesn't have an option to enable
+		// discard, so we persist the setting to the LUKS superblock
+		// with --persistent, then omit it from the crypttab (since
+		// crypttab would be misleading about where the setting is
+		// really coming from).
+		// https://github.com/latchset/clevis/issues/286
+		ret = append(ret, "--allow-discards")
+	}
+	for _, opt := range luks.OpenOptions {
+		// support persisting other options too
+		ret = append(ret, string(opt))
+	}
+	return ret
+}
+
+type LuksDump struct {
+	Config struct {
+		Flags []string `json:"flags"`
+	} `json:"config"`
+}
+
+func newLuksDump(devAlias string) (LuksDump, error) {
+	dump, err := exec.Command(distro.CryptsetupCmd(), "luksDump", "--dump-json-metadata", devAlias).CombinedOutput()
+	if err != nil {
+		return LuksDump{}, err
+	}
+	var ret LuksDump
+	if err := json.Unmarshal(dump, &ret); err != nil {
+		return LuksDump{}, fmt.Errorf("parsing luks metadata: %w", err)
+	}
+	return ret, nil
+}
+
+func (d LuksDump) hasFlag(flag string) bool {
+	for _, v := range d.Config.Flags {
+		if v == flag {
+			return true
+		}
+	}
+	return false
+}
diff --git a/internal/exec/stages/disks/partitions.go b/internal/exec/stages/disks/partitions.go
index 54730b41..cb55c376 100644
--- a/internal/exec/stages/disks/partitions.go
+++ b/internal/exec/stages/disks/partitions.go
@@ -27,7 +27,7 @@ import (
 	"strings"
 
 	cutil "github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/exec/util"
 	"github.com/coreos/ignition/v2/internal/sgdisk"
 )
@@ -324,7 +324,12 @@ func (s stage) partitionDisk(dev types.Disk, devAlias string) error {
 		s.Logger.Info("wiping partition table requested on %q", devAlias)
 		op.WipeTable(true)
 		if err := op.Commit(); err != nil {
-			return err
+			// `sgdisk --zap-all` will exit code 2 if the table was corrupted; retry it
+			// https://github.com/coreos/fedora-coreos-tracker/issues/1596
+			s.Logger.Info("potential error encountered while wiping table... retrying")
+			if err := op.Commit(); err != nil {
+				return err
+			}
 		}
 	}
 
@@ -394,5 +399,14 @@ func (s stage) partitionDisk(dev types.Disk, devAlias string) error {
 	if err := op.Commit(); err != nil {
 		return fmt.Errorf("commit failure: %v", err)
 	}
+
+	// It's best to wait here for the /dev/ABC entries to be
+	// (re)created, not only for other parts of the initramfs but
+	// also because s.waitOnDevices() can still race with udev's
+	// partition entry recreation.
+	if err := s.waitForUdev(devAlias); err != nil {
+		return fmt.Errorf("failed to wait for udev on %q after partitioning: %v", devAlias, err)
+	}
+
 	return nil
 }
diff --git a/internal/exec/stages/disks/raid.go b/internal/exec/stages/disks/raid.go
index f838f349..795dd42b 100644
--- a/internal/exec/stages/disks/raid.go
+++ b/internal/exec/stages/disks/raid.go
@@ -22,8 +22,9 @@ package disks
 import (
 	"fmt"
 	"os/exec"
+	"strings"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/exec/util"
 )
@@ -78,6 +79,17 @@ func (s stage) createRaids(config types.Config) error {
 		); err != nil {
 			return fmt.Errorf("mdadm failed: %v", err)
 		}
+
+		devName := md.Name
+		if !strings.HasPrefix(devName, "/dev") {
+			devName = "/dev/md/" + md.Name
+		}
+		// Wait for the created device node to show up, no udev
+		// race prevention required because this node did not
+		// exist before.
+		if err := s.waitOnDevices([]string{devName}, "raids"); err != nil {
+			return err
+		}
 	}
 
 	return nil
diff --git a/internal/exec/stages/fetch/fetch.go b/internal/exec/stages/fetch/fetch.go
index f163509e..4511ebf0 100644
--- a/internal/exec/stages/fetch/fetch.go
+++ b/internal/exec/stages/fetch/fetch.go
@@ -19,7 +19,7 @@
 package fetch
 
 import (
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
 	"github.com/coreos/ignition/v2/internal/exec/util"
 	"github.com/coreos/ignition/v2/internal/log"
diff --git a/internal/exec/stages/fetch_offline/fetch-offline.go b/internal/exec/stages/fetch_offline/fetch-offline.go
index dcea43a8..281980d7 100644
--- a/internal/exec/stages/fetch_offline/fetch-offline.go
+++ b/internal/exec/stages/fetch_offline/fetch-offline.go
@@ -23,7 +23,7 @@ import (
 	"reflect"
 
 	cfgutil "github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
 	executil "github.com/coreos/ignition/v2/internal/exec/util"
 	"github.com/coreos/ignition/v2/internal/log"
@@ -84,13 +84,23 @@ func configNeedsNet(cfg *types.Config) (bool, error) {
 func configNeedsNetRecurse(v reflect.Value) (bool, error) {
 	t := v.Type()
 	k := t.Kind()
+
 	switch {
 	case cfgutil.IsPrimitive(k):
 		return false, nil
 	case t == reflect.TypeOf(types.Resource{}):
 		return sourceNeedsNet(v.Interface().(types.Resource))
 	case t == reflect.TypeOf(types.Tang{}):
+		tang := v.Interface().(types.Tang)
+		if !cfgutil.NilOrEmpty(tang.Advertisement) {
+			return false, nil
+		}
 		return true, nil
+	case t == reflect.TypeOf(types.ClevisCustom{}):
+		cc := v.Interface().(types.ClevisCustom)
+		if cc.NeedsNetwork != nil {
+			return *cc.NeedsNetwork, nil
+		}
 	case k == reflect.Struct:
 		for i := 0; i < v.NumField(); i += 1 {
 			if needsNet, err := configNeedsNetRecurse(v.Field(i)); err != nil {
diff --git a/internal/exec/stages/fetch_offline/fetch_offline_test.go b/internal/exec/stages/fetch_offline/fetch_offline_test.go
index 11f133ff..fb45e966 100644
--- a/internal/exec/stages/fetch_offline/fetch_offline_test.go
+++ b/internal/exec/stages/fetch_offline/fetch_offline_test.go
@@ -18,7 +18,7 @@ import (
 	"testing"
 
 	"github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 
 	"github.com/stretchr/testify/assert"
 )
@@ -29,62 +29,197 @@ func checkNeedsNet(t *testing.T, cfg *types.Config) bool {
 	return needsNet
 }
 
-func assertNeedsNet(t *testing.T, cfg *types.Config) {
-	assert.Equal(t, checkNeedsNet(t, cfg), true, "unexpected config doesn't need net: %v", *cfg)
-}
+func TestConfigNotNeedsNet(t *testing.T) {
+	tests := []types.Config{
+		// Test ClevisCustom NeedsNetwork set to false
+		{
+			Storage: types.Storage{
+				Luks: []types.Luks{
+					{
+						Name:   "foobar",
+						Device: util.StrToPtr("foo"),
+						Clevis: types.Clevis{
+							Custom: types.ClevisCustom{
+								NeedsNetwork: util.BoolToPtr(false),
+							},
+						},
+					},
+				},
+			},
+		},
+		// Source with no URL
+		{
+			Ignition: types.Ignition{
+				Version: "3.3.0",
+				Config: types.IgnitionConfig{
+					Replace: types.Resource{
+						Source: util.StrToPtr(""),
+					},
+				},
+			},
+		},
+		// Source with Nil
+		{
+			Ignition: types.Ignition{
+				Version: "3.3.0",
+				Config: types.IgnitionConfig{
+					Replace: types.Resource{
+						Source: nil,
+					},
+				},
+			},
+		},
+		// Empty Config
+		{},
+		// Tang with adv set does not need networking on first boot.
+		{
+			Storage: types.Storage{
+				Luks: []types.Luks{
+					{
+						Name:   "foobar",
+						Device: util.StrToPtr("foo"),
+						Clevis: types.Clevis{
+							Tang: []types.Tang{
+								{
+									Thumbprint:    util.StrToPtr("mythumbprint"),
+									URL:           "http://mytang.example.com",
+									Advertisement: util.StrToPtr(" {\"payload\": \"...\",\"protected\":\"...\",\"signature\":\"...\"}"),
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+	}
 
-func assertNotNeedsNet(t *testing.T, cfg *types.Config) {
-	assert.Equal(t, checkNeedsNet(t, cfg), false, "unexpected config needs net: %v", *cfg)
+	for i, test := range tests {
+		assert.Equal(t, checkNeedsNet(t, &test), false, "#%d: unexpected config needs net: %v", i, test)
+	}
 }
 
 func TestConfigNeedsNet(t *testing.T) {
-	cfg := types.Config{
-		Ignition: types.Ignition{
-			Version: "3.3.0",
-			Config: types.IgnitionConfig{
-				Replace: types.Resource{
-					Source: util.StrToPtr("http://example.com/config.ign"),
+	tests := []types.Config{
+		// Tang with no adv set needs networking on first boot.
+		{
+			Storage: types.Storage{
+				Luks: []types.Luks{
+					{
+						Name:   "foobar",
+						Device: util.StrToPtr("bazboo"),
+						Clevis: types.Clevis{
+							Tang: []types.Tang{
+								{
+									Thumbprint: util.StrToPtr("mythumbprint"),
+									URL:        "http://tang.example.com",
+								},
+							},
+						},
+					},
 				},
 			},
 		},
-	}
-	assertNeedsNet(t, &cfg)
-	cfg.Ignition.Config.Replace.Source = nil
-	assertNotNeedsNet(t, &cfg)
-	cfg.Storage.Files = []types.File{
+		// Source with URL needs Net
 		{
-			Node: types.Node{
-				Path: "/etc/foobar.conf",
+			Ignition: types.Ignition{
+				Version: "3.3.0",
+				Config: types.IgnitionConfig{
+					Replace: types.Resource{
+						Source: util.StrToPtr("http://example.com/config.ign"),
+					},
+				},
 			},
-			FileEmbedded1: types.FileEmbedded1{
-				Contents: types.Resource{
-					Source: util.StrToPtr("data:,hello"),
+		},
+		// CustomClevis with NeedsNetwork set to true
+		{
+			Storage: types.Storage{
+				Luks: []types.Luks{
+					{
+						Name:   "foobar",
+						Device: util.StrToPtr("foo"),
+						Clevis: types.Clevis{
+							Custom: types.ClevisCustom{
+								NeedsNetwork: util.BoolToPtr(true),
+							},
+						},
+					},
 				},
 			},
 		},
-	}
-	assertNotNeedsNet(t, &cfg)
-	cfg.Storage.Files[0].Contents.Source = util.StrToPtr("")
-	assertNotNeedsNet(t, &cfg)
-	cfg.Storage.Files[0].Contents.Source = nil
-	assertNotNeedsNet(t, &cfg)
-	cfg.Storage.Files[0].Contents.Source = util.StrToPtr("http://example.com/payload")
-	assertNeedsNet(t, &cfg)
-	cfg.Storage.Files[0].Contents.Source = nil
-	assertNotNeedsNet(t, &cfg)
-	cfg.Storage.Luks = []types.Luks{
+		// Tang with adv explicitly set to nil needs networking on first boot.
 		{
-			Name:   "foobar",
-			Device: util.StrToPtr("bazboo"),
-			Clevis: types.Clevis{
-				Tang: []types.Tang{
+			Storage: types.Storage{
+				Luks: []types.Luks{
 					{
-						Thumbprint: util.StrToPtr("mythumbprint"),
-						URL:        "http://tang.example.com",
+						Name:   "foobar",
+						Device: util.StrToPtr("foo"),
+						Clevis: types.Clevis{
+							Tang: []types.Tang{
+								{
+									Thumbprint:    util.StrToPtr("mythumbprint"),
+									URL:           "http://mytang.example.com",
+									Advertisement: nil,
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		// Multiple Tangs; one with adv set, one without needs networking on first boot.
+		{
+			Storage: types.Storage{
+				Luks: []types.Luks{
+					{
+						Name:   "foobar",
+						Device: util.StrToPtr("foo"),
+						Clevis: types.Clevis{
+							Tang: []types.Tang{
+								{
+									Thumbprint:    util.StrToPtr("mythumbprint"),
+									URL:           "http://mytang.example.com",
+									Advertisement: util.StrToPtr(" {\"payload\": \"...\",\"protected\":\"...\",\"signature\":\"...\"}"),
+								},
+								{
+									Thumbprint:    util.StrToPtr("mythumbprint"),
+									URL:           "http://mytang.example.com",
+									Advertisement: nil,
+								},
+							},
+						},
+					},
+				},
+			},
+		},
+		// Multiple Tangs with no adv set needs networking on first boot.
+		{
+			Storage: types.Storage{
+				Luks: []types.Luks{
+					{
+						Name:   "foobar",
+						Device: util.StrToPtr("foo"),
+						Clevis: types.Clevis{
+							Tang: []types.Tang{
+								{
+									Thumbprint:    util.StrToPtr("mythumbprint"),
+									URL:           "http://mytang.example.com",
+									Advertisement: util.StrToPtr(""),
+								},
+								{
+									Thumbprint:    util.StrToPtr("mythumbprint"),
+									URL:           "http://mytang.example.com",
+									Advertisement: nil,
+								},
+							},
+						},
 					},
 				},
 			},
 		},
 	}
-	assertNeedsNet(t, &cfg)
+
+	for i, test := range tests {
+		assert.Equal(t, checkNeedsNet(t, &test), true, "#%d: unexpected config doesn't need net: %v", i, test)
+	}
+
 }
diff --git a/internal/exec/stages/files/files.go b/internal/exec/stages/files/files.go
index 7d97df5f..5ab5242a 100644
--- a/internal/exec/stages/files/files.go
+++ b/internal/exec/stages/files/files.go
@@ -17,9 +17,10 @@ package files
 import (
 	"errors"
 	"fmt"
+	"os"
 	"path/filepath"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
 	"github.com/coreos/ignition/v2/internal/exec/util"
@@ -108,6 +109,11 @@ func (s stage) runImpl(config types.Config, isApply bool, applyIgnoreUnsupported
 			return fmt.Errorf("creating crypttab entries: %v", err)
 		}
 
+		// !isApply: we don't support arbitrary providers
+		if err := s.createProviderOutputFiles(); err != nil {
+			return fmt.Errorf("creating provider state files: %v", err)
+		}
+
 		// !isApply: we support running Ignition multiple times
 		if err := s.createResultFile(); err != nil {
 			return fmt.Errorf("creating result file: %v", err)
@@ -165,7 +171,18 @@ func (s *stage) relabelFiles() error {
 
 	keys := make([]string, 0, len(s.toRelabel))
 	for key := range s.toRelabel {
-		keys = append(keys, key)
+		// Filter out non-existent entries; some of the code that mark files for
+		// relabeling may not actually end up creating those files in the end.
+		if _, err := os.Stat(key); err == nil {
+			keys = append(keys, key)
+		} else if !errors.Is(err, os.ErrNotExist) {
+			return err
+		}
 	}
+
+	if len(keys) == 0 {
+		return nil
+	}
+
 	return s.RelabelFiles(keys)
 }
diff --git a/internal/exec/stages/files/files_test.go b/internal/exec/stages/files/files_test.go
index 9428b883..31741541 100644
--- a/internal/exec/stages/files/files_test.go
+++ b/internal/exec/stages/files/files_test.go
@@ -19,7 +19,7 @@ import (
 	"sort"
 	"testing"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/exec/util"
 )
 
diff --git a/internal/exec/stages/files/filesystemEntries.go b/internal/exec/stages/files/filesystemEntries.go
index c61824ba..4df1f00c 100644
--- a/internal/exec/stages/files/filesystemEntries.go
+++ b/internal/exec/stages/files/filesystemEntries.go
@@ -17,7 +17,6 @@ package files
 import (
 	"encoding/json"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"os/exec"
 	"path/filepath"
@@ -26,7 +25,7 @@ import (
 	"time"
 
 	cutil "github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/exec/util"
 	"github.com/coreos/ignition/v2/internal/log"
@@ -132,6 +131,22 @@ func (s *stage) createCrypttabEntries(config types.Config) error {
 	return nil
 }
 
+// createProviderOutputFiles writes out any files saved in state by
+// provider fetch.
+func (s *stage) createProviderOutputFiles() error {
+	var entries []filesystemEntry
+	for _, file := range s.State.ProviderOutputFiles {
+		path, err := s.JoinPath(file.Path)
+		if err != nil {
+			return fmt.Errorf("calculating path for %q: %w", file.Path, err)
+		}
+		entry := fileEntry(file)
+		entry.Path = path
+		entries = append(entries, entry)
+	}
+	return s.createEntries(entries)
+}
+
 // createResultFile creates a report recording some details about the
 // Ignition run.
 func (s *stage) createResultFile() error {
@@ -147,7 +162,7 @@ func (s *stage) createResultFile() error {
 	if err != nil {
 		return fmt.Errorf("building previous result file path: %w", err)
 	}
-	prevData, err := ioutil.ReadFile(prevPath)
+	prevData, err := os.ReadFile(prevPath)
 	if err != nil && !os.IsNotExist(err) {
 		return fmt.Errorf("reading previous report: %w", err)
 	}
@@ -165,7 +180,7 @@ func (s *stage) createResultFile() error {
 		}
 	}
 
-	bootIDBytes, err := ioutil.ReadFile(distro.BootIDPath())
+	bootIDBytes, err := os.ReadFile(distro.BootIDPath())
 	if err != nil {
 		return fmt.Errorf("reading boot ID: %w", err)
 	}
diff --git a/internal/exec/stages/files/passwd.go b/internal/exec/stages/files/passwd.go
index 2c5e2d9d..3c6b571f 100644
--- a/internal/exec/stages/files/passwd.go
+++ b/internal/exec/stages/files/passwd.go
@@ -19,7 +19,7 @@ import (
 	"path/filepath"
 
 	"github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 )
 
 func (s *stage) expandGlobList(globs ...string) ([]string, error) {
diff --git a/internal/exec/stages/files/units.go b/internal/exec/stages/files/units.go
index f7ded9e8..03f51790 100644
--- a/internal/exec/stages/files/units.go
+++ b/internal/exec/stages/files/units.go
@@ -15,13 +15,15 @@
 package files
 
 import (
+	"context"
 	"fmt"
 	"path/filepath"
+	"sort"
 	"strings"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
 	cutil "github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/exec/util"
 	"github.com/coreos/ignition/v2/internal/systemd"
 )
@@ -38,7 +40,7 @@ type Preset struct {
 // warnOnOldSystemdVersion checks the version of Systemd
 // in a given system and prints a warning if older than 240.
 func (s *stage) warnOnOldSystemdVersion() error {
-	systemdVersion, err := systemd.GetSystemdVersion()
+	systemdVersion, err := systemd.GetSystemdVersion(context.Background())
 	if err != nil {
 		return err
 	}
@@ -150,7 +152,17 @@ func (s *stage) createSystemdPresetFile(presets map[string]*Preset) error {
 		return err
 	}
 	hasInstanceUnit := false
-	for _, value := range presets {
+
+	// sort the units before writing to the systemd presets file to ensure
+	// the file is written in a consistent order across multiple runs
+	unitNames := make([]string, 0, len(presets))
+	for unit := range presets {
+		unitNames = append(unitNames, unit)
+	}
+	sort.Strings(unitNames)
+
+	for _, name := range unitNames {
+		value := presets[name]
 		unitString := value.unit
 		if value.instantiatable {
 			hasInstanceUnit = true
diff --git a/internal/exec/stages/files/units_test.go b/internal/exec/stages/files/units_test.go
index b7020f7e..3408b2bd 100644
--- a/internal/exec/stages/files/units_test.go
+++ b/internal/exec/stages/files/units_test.go
@@ -19,7 +19,7 @@ import (
 	"testing"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 )
 
 func TestParseInstanceUnit(t *testing.T) {
diff --git a/internal/exec/stages/kargs/kargs.go b/internal/exec/stages/kargs/kargs.go
index 7267709f..f7980c89 100644
--- a/internal/exec/stages/kargs/kargs.go
+++ b/internal/exec/stages/kargs/kargs.go
@@ -19,7 +19,7 @@ import (
 	"fmt"
 	"os/exec"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
 	"github.com/coreos/ignition/v2/internal/exec/util"
diff --git a/internal/exec/stages/mount/mount.go b/internal/exec/stages/mount/mount.go
index 1c25dfed..8898bcf0 100644
--- a/internal/exec/stages/mount/mount.go
+++ b/internal/exec/stages/mount/mount.go
@@ -28,7 +28,7 @@ import (
 	"strings"
 
 	cutil "github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
 	"github.com/coreos/ignition/v2/internal/exec/util"
@@ -123,29 +123,25 @@ func (s stage) mountFs(fs types.Filesystem) error {
 		return err
 	}
 
-	var firstMissing string
-	if distro.SelinuxRelabel() {
-		var err error
-		firstMissing, err = util.FindFirstMissingPathComponent(path)
+	if _, err := os.Stat(path); err != nil && os.IsNotExist(err) {
+		firstMissing, err := util.FindFirstMissingPathComponent(path)
 		if err != nil {
 			return err
 		}
-	}
 
-	if _, err := os.Stat(path); err != nil && os.IsNotExist(err) {
 		// Record created directories for use by the files stage.
 		// NotateMkdirAll() is relative to the DestDir.
 		if err := s.NotateMkdirAll(relpath, 0755); err != nil {
 			return err
 		}
-	} else if err != nil {
-		return err
-	}
 
-	if distro.SelinuxRelabel() {
-		if err := s.RelabelFiles([]string{firstMissing}); err != nil {
-			return err
+		if distro.SelinuxRelabel() {
+			if err := s.RelabelFiles([]string{firstMissing}); err != nil {
+				return err
+			}
 		}
+	} else if err != nil {
+		return err
 	}
 
 	args := translateOptionSliceToString(fs.MountOptions, ",")
diff --git a/internal/exec/stages/stages.go b/internal/exec/stages/stages.go
index dc4d7d3e..721b57c8 100644
--- a/internal/exec/stages/stages.go
+++ b/internal/exec/stages/stages.go
@@ -15,7 +15,7 @@
 package stages
 
 import (
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/log"
 	"github.com/coreos/ignition/v2/internal/registry"
 	"github.com/coreos/ignition/v2/internal/resource"
diff --git a/internal/exec/stages/umount/umount.go b/internal/exec/stages/umount/umount.go
index d7b7fbba..610c64f2 100644
--- a/internal/exec/stages/umount/umount.go
+++ b/internal/exec/stages/umount/umount.go
@@ -23,7 +23,7 @@ import (
 	"sort"
 
 	cutil "github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
 	"github.com/coreos/ignition/v2/internal/exec/util"
 	"github.com/coreos/ignition/v2/internal/log"
diff --git a/internal/exec/util/file.go b/internal/exec/util/file.go
index d5a680d4..6668945e 100644
--- a/internal/exec/util/file.go
+++ b/internal/exec/util/file.go
@@ -19,7 +19,6 @@ import (
 	"fmt"
 	"hash"
 	"io"
-	"io/ioutil"
 	"net/http"
 	"net/url"
 	"os"
@@ -28,7 +27,7 @@ import (
 	"syscall"
 
 	cutil "github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/log"
 	"github.com/coreos/ignition/v2/internal/resource"
 	"github.com/coreos/ignition/v2/internal/util"
@@ -196,13 +195,13 @@ func (u Util) PerformFetch(f FetchOp) error {
 	}
 
 	// Create a temporary file in the same directory to ensure it's on the same filesystem
-	tmp, err := ioutil.TempFile(filepath.Dir(path), "tmp")
+	tmp, err := os.CreateTemp(filepath.Dir(path), "tmp")
 	if err != nil {
 		return err
 	}
 	defer tmp.Close()
 
-	// ioutil.TempFile defaults to 0600
+	// os.CreateTemp defaults to 0600
 	if err := tmp.Chmod(DefaultFilePermissions); err != nil {
 		return err
 	}
diff --git a/internal/exec/util/passwd.go b/internal/exec/util/passwd.go
index e6050d04..085cc3f2 100644
--- a/internal/exec/util/passwd.go
+++ b/internal/exec/util/passwd.go
@@ -25,7 +25,7 @@ import (
 
 	"github.com/coreos/go-systemd/v22/journal"
 	"github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/as_user"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"golang.org/x/sys/unix"
diff --git a/internal/exec/util/unit.go b/internal/exec/util/unit.go
index d42c51ad..809507b7 100644
--- a/internal/exec/util/unit.go
+++ b/internal/exec/util/unit.go
@@ -22,7 +22,7 @@ import (
 	"path/filepath"
 	"syscall"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 
 	"github.com/vincent-petithory/dataurl"
@@ -153,6 +153,12 @@ func (ut Util) EnableUnit(enabledUnit string) error {
 }
 
 func (ut Util) DisableUnit(disabledUnit string) error {
+	// check if the unit is currently enabled to see if we need to disable it
+	// if it's not enabled or does not exist, we don't need to do anything
+	args := []string{"--root", ut.DestDir, "is-enabled", disabledUnit}
+	if err := exec.Command(distro.SystemctlCmd(), args...).Run(); err != nil {
+		return nil
+	}
 	// We need to delete any enablement symlinks for a unit before sending it to a
 	// preset directive. This will help to disable that unit completely.
 	// For more information: https://github.com/coreos/fedora-coreos-tracker/issues/392
diff --git a/internal/exec/util/user_group_lookup_test.go b/internal/exec/util/user_group_lookup_test.go
index c30e1550..2482d710 100644
--- a/internal/exec/util/user_group_lookup_test.go
+++ b/internal/exec/util/user_group_lookup_test.go
@@ -15,7 +15,6 @@
 package util
 
 import (
-	"io/ioutil"
 	"os"
 	"os/user"
 	"path/filepath"
@@ -26,7 +25,7 @@ import (
 
 // tempBase() slaps together a minimal /etc/{passwd,group} for the lookup test.
 func tempBase() (string, error) {
-	td, err := ioutil.TempDir("", "ign-usr-lookup-test")
+	td, err := os.MkdirTemp("", "ign-usr-lookup-test")
 	if err != nil {
 		return "", err
 	}
@@ -36,19 +35,19 @@ func tempBase() (string, error) {
 	}
 
 	gp := filepath.Join(td, "etc/group")
-	err = ioutil.WriteFile(gp, []byte("foo:x:4242:\n"), 0644)
+	err = os.WriteFile(gp, []byte("foo:x:4242:\n"), 0644)
 	if err != nil {
 		return "", err
 	}
 
 	pp := filepath.Join(td, "etc/passwd")
-	err = ioutil.WriteFile(pp, []byte("foo:x:44:4242::/home/foo:/bin/false"), 0644)
+	err = os.WriteFile(pp, []byte("foo:x:44:4242::/home/foo:/bin/false"), 0644)
 	if err != nil {
 		return "", err
 	}
 
 	nsp := filepath.Join(td, "etc/nsswitch.conf")
-	err = ioutil.WriteFile(nsp, []byte("passwd: files\ngroup: files\nshadow: files\ngshadow: files\n"), 0644)
+	err = os.WriteFile(nsp, []byte("passwd: files\ngroup: files\nshadow: files\ngshadow: files\n"), 0644)
 	if err != nil {
 		return "", err
 	}
diff --git a/internal/main.go b/internal/main.go
index 809a92b5..80f85453 100644
--- a/internal/main.go
+++ b/internal/main.go
@@ -17,7 +17,7 @@ package main
 import (
 	"flag"
 	"fmt"
-	"io/ioutil"
+	"io"
 	"os"
 	"path/filepath"
 	"time"
@@ -26,15 +26,9 @@ import (
 	"github.com/coreos/ignition/v2/internal/apply"
 	"github.com/coreos/ignition/v2/internal/exec"
 	"github.com/coreos/ignition/v2/internal/exec/stages"
-	_ "github.com/coreos/ignition/v2/internal/exec/stages/disks"
-	_ "github.com/coreos/ignition/v2/internal/exec/stages/fetch"
-	_ "github.com/coreos/ignition/v2/internal/exec/stages/fetch_offline"
-	_ "github.com/coreos/ignition/v2/internal/exec/stages/files"
-	_ "github.com/coreos/ignition/v2/internal/exec/stages/kargs"
-	_ "github.com/coreos/ignition/v2/internal/exec/stages/mount"
-	_ "github.com/coreos/ignition/v2/internal/exec/stages/umount"
 	"github.com/coreos/ignition/v2/internal/log"
 	"github.com/coreos/ignition/v2/internal/platform"
+	_ "github.com/coreos/ignition/v2/internal/register"
 	"github.com/coreos/ignition/v2/internal/state"
 	"github.com/coreos/ignition/v2/internal/version"
 	"github.com/spf13/pflag"
@@ -99,7 +93,7 @@ func ignitionMain() {
 	logger.Info("Stage: %v", flags.stage)
 
 	platformConfig := platform.MustGet(flags.platform.String())
-	fetcher, err := platformConfig.NewFetcherFunc()(&logger)
+	fetcher, err := platformConfig.NewFetcher(&logger)
 	if err != nil {
 		logger.Crit("failed to generate fetcher: %s", err)
 		os.Exit(3)
@@ -168,10 +162,10 @@ func ignitionApplyMain() {
 	var blob []byte
 	var err error
 	if cfgArg == "-" {
-		blob, err = ioutil.ReadAll(os.Stdin)
+		blob, err = io.ReadAll(os.Stdin)
 	} else {
 		// XXX: could in the future support fetching directly from HTTP(S) + `-checksum|-insecure` ?
-		blob, err = ioutil.ReadFile(cfgArg)
+		blob, err = os.ReadFile(cfgArg)
 	}
 	if err != nil {
 		logger.Crit("couldn't read config: %v", err)
@@ -228,7 +222,7 @@ func ignitionRmCfgMain() {
 	logger.Info(version.String)
 
 	platformConfig := platform.MustGet(flags.platform)
-	fetcher, err := platformConfig.NewFetcherFunc()(&logger)
+	fetcher, err := platformConfig.NewFetcher(&logger)
 	if err != nil {
 		logger.Crit("failed to generate fetcher: %s", err)
 		os.Exit(3)
diff --git a/internal/platform/platform.go b/internal/platform/platform.go
index 23339439..48d60615 100644
--- a/internal/platform/platform.go
+++ b/internal/platform/platform.go
@@ -18,90 +18,87 @@ import (
 	"errors"
 	"fmt"
 
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/log"
-	"github.com/coreos/ignition/v2/internal/providers"
-	"github.com/coreos/ignition/v2/internal/providers/aliyun"
-	"github.com/coreos/ignition/v2/internal/providers/aws"
-	"github.com/coreos/ignition/v2/internal/providers/azure"
-	"github.com/coreos/ignition/v2/internal/providers/azurestack"
-	"github.com/coreos/ignition/v2/internal/providers/cloudstack"
-	"github.com/coreos/ignition/v2/internal/providers/digitalocean"
-	"github.com/coreos/ignition/v2/internal/providers/exoscale"
-	"github.com/coreos/ignition/v2/internal/providers/file"
-	"github.com/coreos/ignition/v2/internal/providers/gcp"
-	"github.com/coreos/ignition/v2/internal/providers/ibmcloud"
-	"github.com/coreos/ignition/v2/internal/providers/kubevirt"
-	"github.com/coreos/ignition/v2/internal/providers/noop"
-	"github.com/coreos/ignition/v2/internal/providers/nutanix"
-	"github.com/coreos/ignition/v2/internal/providers/openstack"
-	"github.com/coreos/ignition/v2/internal/providers/packet"
-	"github.com/coreos/ignition/v2/internal/providers/powervs"
-	"github.com/coreos/ignition/v2/internal/providers/qemu"
-	"github.com/coreos/ignition/v2/internal/providers/virtualbox"
-	"github.com/coreos/ignition/v2/internal/providers/vmware"
-	"github.com/coreos/ignition/v2/internal/providers/vultr"
-	"github.com/coreos/ignition/v2/internal/providers/zvm"
 	"github.com/coreos/ignition/v2/internal/registry"
 	"github.com/coreos/ignition/v2/internal/resource"
+	"github.com/coreos/ignition/v2/internal/state"
+
+	"github.com/coreos/vcontext/report"
 )
 
 var (
 	ErrCannotDelete = errors.New("cannot delete config on this platform")
+	ErrNoProvider   = errors.New("config provider was not online")
 )
 
-// Config represents a set of options that map to a particular platform.
+// Config defines the capabilities of a particular platform, for use by the
+// rest of Ignition.
 type Config struct {
-	name       string
-	fetch      providers.FuncFetchConfig
-	init       providers.FuncInit
-	newFetcher providers.FuncNewFetcher
-	status     providers.FuncPostStatus
-	delConfig  providers.FuncDelConfig
+	// don't allow direct access to fields
+	p Provider
 }
 
-func (c Config) Name() string {
-	return c.name
+// Provider is the struct that platform implementations use to define their
+// capabilities for use by this package.
+type Provider struct {
+	Name       string
+	NewFetcher func(logger *log.Logger) (resource.Fetcher, error)
+	Fetch      func(f *resource.Fetcher) (types.Config, report.Report, error)
+	Init       func(f *resource.Fetcher) error
+	Status     func(stageName string, f resource.Fetcher, e error) error
+	DelConfig  func(f *resource.Fetcher) error
+
+	// Fetch, and also save output files to be written during files stage.
+	// Avoid, unless you're certain you need it.
+	FetchWithFiles func(f *resource.Fetcher) ([]types.File, types.Config, report.Report, error)
 }
 
-func (c Config) FetchFunc() providers.FuncFetchConfig {
-	return c.fetch
+func (c Config) Name() string {
+	return c.p.Name
 }
 
-func (c Config) NewFetcherFunc() providers.FuncNewFetcher {
-	if c.newFetcher != nil {
-		return c.newFetcher
+func (c Config) Fetch(f *resource.Fetcher, state *state.State) (types.Config, report.Report, error) {
+	if c.p.FetchWithFiles != nil {
+		files, config, report, err := c.p.FetchWithFiles(f)
+		state.ProviderOutputFiles = files
+		return config, report, err
+	} else {
+		return c.p.Fetch(f)
 	}
-	return func(l *log.Logger) (resource.Fetcher, error) {
+}
+
+func (c Config) NewFetcher(l *log.Logger) (resource.Fetcher, error) {
+	if c.p.NewFetcher != nil {
+		return c.p.NewFetcher(l)
+	} else {
 		return resource.Fetcher{
 			Logger: l,
 		}, nil
 	}
 }
 
-// InitFunc returns a function that performs additional fetcher
-// configuration post-config fetch. This ensures that networking
-// is already available if a platform needs to reach out to the
-// metadata service to fetch additional options / data.
-func (c Config) InitFunc() providers.FuncInit {
-	if c.init != nil {
-		return c.init
-	}
-	return func(f *resource.Fetcher) error {
-		return nil
+// Init performs additional fetcher configuration post-config fetch.  This
+// ensures that networking is already available if a platform needs to reach
+// out to the metadata service to fetch additional options / data.
+func (c Config) Init(f *resource.Fetcher) error {
+	if c.p.Init != nil {
+		return c.p.Init(f)
 	}
+	return nil
 }
 
 // Status takes a Fetcher and the error from Run (from engine)
 func (c Config) Status(stageName string, f resource.Fetcher, statusErr error) error {
-	if c.status != nil {
-		return c.status(stageName, f, statusErr)
+	if c.p.Status != nil {
+		return c.p.Status(stageName, f, statusErr)
 	}
 	return nil
 }
 
 func (c Config) DelConfig(f *resource.Fetcher) error {
-	if c.delConfig != nil {
-		return c.delConfig(f)
+	if c.p.DelConfig != nil {
+		return c.p.DelConfig(f)
 	} else {
 		return ErrCannotDelete
 	}
@@ -109,100 +106,16 @@ func (c Config) DelConfig(f *resource.Fetcher) error {
 
 var configs = registry.Create("platform configs")
 
-func init() {
-	configs.Register(Config{
-		name:  "aliyun",
-		fetch: aliyun.FetchConfig,
-	})
-	configs.Register(Config{
-		name:       "aws",
-		fetch:      aws.FetchConfig,
-		init:       aws.Init,
-		newFetcher: aws.NewFetcher,
-	})
-	configs.Register(Config{
-		name:  "azure",
-		fetch: azure.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "azurestack",
-		fetch: azurestack.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "brightbox",
-		fetch: openstack.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "cloudstack",
-		fetch: cloudstack.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "digitalocean",
-		fetch: digitalocean.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "exoscale",
-		fetch: exoscale.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "file",
-		fetch: file.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "gcp",
-		fetch: gcp.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "ibmcloud",
-		fetch: ibmcloud.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "kubevirt",
-		fetch: kubevirt.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "metal",
-		fetch: noop.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "nutanix",
-		fetch: nutanix.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "openstack",
-		fetch: openstack.FetchConfig,
-	})
-	configs.Register(Config{
-		name:   "packet",
-		fetch:  packet.FetchConfig,
-		status: packet.PostStatus,
-	})
-	configs.Register(Config{
-		name:  "powervs",
-		fetch: powervs.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "qemu",
-		fetch: qemu.FetchConfig,
-	})
-	configs.Register(Config{
-		name:      "virtualbox",
-		fetch:     virtualbox.FetchConfig,
-		delConfig: virtualbox.DelConfig,
-	})
-	configs.Register(Config{
-		name:      "vmware",
-		fetch:     vmware.FetchConfig,
-		delConfig: vmware.DelConfig,
-	})
-	configs.Register(Config{
-		name:  "vultr",
-		fetch: vultr.FetchConfig,
-	})
-	configs.Register(Config{
-		name:  "zvm",
-		fetch: zvm.FetchConfig,
-	})
+func Register(provider Provider) {
+	configs.Register(NewConfig(provider))
+}
+
+// Helper function for wrapping a Provider, for use by specialized providers
+// that don't want to add themselves to the registry.
+func NewConfig(provider Provider) Config {
+	return Config{
+		p: provider,
+	}
 }
 
 func Get(name string) (config Config, ok bool) {
diff --git a/internal/providers/aliyun/aliyun.go b/internal/providers/aliyun/aliyun.go
index 2da29f86..4bb6239d 100644
--- a/internal/providers/aliyun/aliyun.go
+++ b/internal/providers/aliyun/aliyun.go
@@ -20,7 +20,8 @@ package aliyun
 import (
 	"net/url"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -35,7 +36,14 @@ var (
 	}
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "aliyun",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	data, err := f.FetchToBuffer(userdataUrl, resource.FetchOptions{})
 	if err != nil && err != resource.ErrNotFound {
 		return types.Config{}, report.Report{}, err
diff --git a/internal/providers/applehv/applehv.go b/internal/providers/applehv/applehv.go
new file mode 100644
index 00000000..cbb68c66
--- /dev/null
+++ b/internal/providers/applehv/applehv.go
@@ -0,0 +1,108 @@
+// Copyright 2023 Red Hat
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package applehv
+
+import (
+	"context"
+	"fmt"
+	"io"
+	"net"
+	"net/http"
+	"os/exec"
+
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/distro"
+	"github.com/coreos/ignition/v2/internal/platform"
+	"github.com/coreos/ignition/v2/internal/providers/util"
+	"github.com/coreos/ignition/v2/internal/resource"
+	"github.com/coreos/vcontext/report"
+	"github.com/mdlayher/vsock"
+)
+
+/*
+	This provider is specific to virtual machines running under Apple Hypervisor on macOS on Apple hardware.
+
+	It should however be possible to emulate the platform setup with QEMU, using [1] to assign a vsock to the
+	guest and then forward the request from the Ignition process running in the virtual machine to an HTTP
+	server running on the host, using the vsock support in socat for example.
+
+	[1] https://wiki.qemu.org/Features/VirtioVsock
+*/
+
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "applehv",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+	// the vsock module must be built into the kernel or loaded so we can communicate
+	// with the host
+	if _, err := f.Logger.LogCmd(exec.Command(distro.ModprobeCmd(), "vsock"), "Loading vsock kernel module"); err != nil {
+		f.Logger.Err("failed to install vsock kernel module: %v", err)
+		return types.Config{}, report.Report{}, fmt.Errorf("failed to install vsock kernel module: %v", err)
+	}
+
+	// we use a http GET over vsock to fetch the ignition file.  the
+	// vsock connection itself is begun here. the "host" will need an HTTPD
+	// server listen on the the other end of the vsock connection on port 1024. The
+	// port is trivial and was just chosen by author
+	// ID =2 is shorthand for "the host"
+	//
+	conn, err := vsock.Dial(2, 1024, &vsock.Config{})
+	if err != nil {
+		return types.Config{}, report.Report{}, err
+	}
+	defer func() {
+		if err := conn.Close(); err != nil {
+			f.Logger.Err("unable to close vsock connection: %v", err)
+		}
+	}()
+
+	// The host portion of the URL is arbitrary here.  The schema is important however.  Because
+	// this is more or less HTTP over a UDS, then the host name is discarded.
+	req, err := http.NewRequest(http.MethodGet, "http://d/", nil)
+	if err != nil {
+		return types.Config{}, report.Report{}, err
+	}
+	req.Header.Set("Accept", "application/json")
+
+	client := http.Client{
+		Transport: &http.Transport{
+			DialContext: func(ctx context.Context, _, _ string) (net.Conn, error) {
+				return conn, nil
+			},
+		},
+	}
+
+	resp, err := client.Do(req)
+	if err != nil {
+		return types.Config{}, report.Report{}, err
+	}
+
+	defer func() {
+		if err := resp.Body.Close(); err != nil {
+			f.Logger.Err("unable to close response body: %v", err)
+		}
+	}()
+
+	b, err := io.ReadAll(resp.Body)
+	if err != nil {
+		return types.Config{}, report.Report{}, err
+	}
+
+	return util.ParseConfig(f.Logger, b)
+}
diff --git a/internal/providers/aws/aws.go b/internal/providers/aws/aws.go
index b2385ac8..5ac3dcb6 100644
--- a/internal/providers/aws/aws.go
+++ b/internal/providers/aws/aws.go
@@ -22,8 +22,9 @@ import (
 	"net/http"
 	"net/url"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -48,7 +49,16 @@ var (
 	errIMDSV2 = errors.New("failed to fetch IMDSv2 session token")
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:       "aws",
+		NewFetcher: newFetcher,
+		Fetch:      fetchConfig,
+		Init:       doInit,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	data, err := fetchFromAWSMetadata(userdataURL, resource.FetchOptions{}, f)
 	if err != nil && err != resource.ErrNotFound {
 		return types.Config{}, report.Report{}, err
@@ -57,7 +67,7 @@ func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	return util.ParseConfig(f.Logger, data)
 }
 
-func NewFetcher(l *log.Logger) (resource.Fetcher, error) {
+func newFetcher(l *log.Logger) (resource.Fetcher, error) {
 	sess, err := session.NewSession(&aws.Config{})
 	if err != nil {
 		return resource.Fetcher{}, err
@@ -70,8 +80,8 @@ func NewFetcher(l *log.Logger) (resource.Fetcher, error) {
 	}, nil
 }
 
-// Init prepares the fetcher for this platform
-func Init(f *resource.Fetcher) error {
+// doInit prepares the fetcher for this platform
+func doInit(f *resource.Fetcher) error {
 	// During the fetch stage we might be running before the networking
 	// is fully ready. Perform an HTTP fetch against the IMDS token URL
 	// to ensure that networking is up before we attempt to fetch the
diff --git a/internal/providers/azure/azure.go b/internal/providers/azure/azure.go
index 7948e7fe..caddcff5 100644
--- a/internal/providers/azure/azure.go
+++ b/internal/providers/azure/azure.go
@@ -19,7 +19,6 @@ package azure
 import (
 	"encoding/base64"
 	"fmt"
-	"io/ioutil"
 	"net/http"
 	"net/url"
 	"os"
@@ -27,9 +26,10 @@ import (
 	"time"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	execUtil "github.com/coreos/ignition/v2/internal/exec/util"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -69,8 +69,15 @@ var (
 	}
 )
 
-// FetchConfig wraps fetchFromAzureMetadata to implement the platform.NewFetcher interface.
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "azure",
+		Fetch: fetchConfig,
+	})
+}
+
+// fetchConfig wraps fetchFromAzureMetadata to implement the provider fetch interface.
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	return fetchFromAzureMetadata(f)
 }
 
@@ -105,7 +112,16 @@ func fetchFromIMDS(f *resource.Fetcher) ([]byte, error) {
 	headers := make(http.Header)
 	headers.Set("Metadata", "true")
 
-	data, err := f.FetchToBuffer(imdsUserdataURL, resource.FetchOptions{Headers: headers})
+	// Azure IMDS expects some codes <500 to still be retried...
+	// Here, we match the cloud-init set.
+	// https://github.com/canonical/cloud-init/commit/c1a2047cf291
+	// https://github.com/coreos/ignition/issues/1806
+	retryCodes := []int{
+		404, // not found
+		410, // gone
+		429, // rate-limited
+	}
+	data, err := f.FetchToBuffer(imdsUserdataURL, resource.FetchOptions{Headers: headers, RetryCodes: retryCodes})
 	if err != nil {
 		return nil, fmt.Errorf("fetching to buffer: %w", err)
 	}
@@ -129,7 +145,7 @@ func fetchFromIMDS(f *resource.Fetcher) ([]byte, error) {
 	return userData[:l], nil
 }
 
-// FetchFromOvfDevice has the return signature of platform.NewFetcher. It is
+// FetchFromOvfDevice has the NewFetcher return signature. It is
 // wrapped by this and AzureStack packages.
 func FetchFromOvfDevice(f *resource.Fetcher, ovfFsTypes []string) (types.Config, report.Report, error) {
 	logger := f.Logger
@@ -166,7 +182,7 @@ func FetchFromOvfDevice(f *resource.Fetcher, ovfFsTypes []string) (types.Config,
 // getRawConfig returns the config by mounting the given block device
 func getRawConfig(f *resource.Fetcher, devicePath string, fstype string) ([]byte, error) {
 	logger := f.Logger
-	mnt, err := ioutil.TempDir("", "ignition-azure")
+	mnt, err := os.MkdirTemp("", "ignition-azure")
 	if err != nil {
 		return nil, fmt.Errorf("failed to create temp directory: %v", err)
 	}
@@ -193,7 +209,7 @@ func getRawConfig(f *resource.Fetcher, devicePath string, fstype string) ([]byte
 	}
 
 	logger.Debug("reading config")
-	rawConfig, err := ioutil.ReadFile(filepath.Join(mnt, configPath))
+	rawConfig, err := os.ReadFile(filepath.Join(mnt, configPath))
 	if err != nil && !os.IsNotExist(err) {
 		return nil, fmt.Errorf("failed to read config from device %q: %v", devicePath, err)
 	}
diff --git a/internal/providers/azurestack/azurestack.go b/internal/providers/azurestack/azurestack.go
index 10da8d23..26334dee 100644
--- a/internal/providers/azurestack/azurestack.go
+++ b/internal/providers/azurestack/azurestack.go
@@ -18,7 +18,8 @@
 package azurestack
 
 import (
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/azure"
 	"github.com/coreos/ignition/v2/internal/resource"
 	"github.com/coreos/vcontext/report"
@@ -32,7 +33,14 @@ const (
 	CDS_FSTYPE_ISO9660 = "iso9660"
 )
 
-// FetchConfig implements the platform.NewFetcher interface.
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "azurestack",
+		Fetch: fetchConfig,
+	})
+}
+
+// fetchConfig implements the fetcher interface.
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	return azure.FetchFromOvfDevice(f, []string{CDS_FSTYPE_UDF, CDS_FSTYPE_ISO9660})
 }
diff --git a/internal/providers/cloudstack/cloudstack.go b/internal/providers/cloudstack/cloudstack.go
index 4e94faef..9cc0ec54 100644
--- a/internal/providers/cloudstack/cloudstack.go
+++ b/internal/providers/cloudstack/cloudstack.go
@@ -22,7 +22,6 @@ import (
 	"bufio"
 	"context"
 	"fmt"
-	"io/ioutil"
 	"net"
 	"net/url"
 	"os"
@@ -31,9 +30,10 @@ import (
 	"strings"
 	"time"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 	ut "github.com/coreos/ignition/v2/internal/util"
@@ -46,7 +46,14 @@ const (
 	LeaseRetryInterval      = 500 * time.Millisecond
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "cloudstack",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	// The fetch-offline approach doesn't work well here because of the "split
 	// personality" of this provider. See:
 	// https://github.com/coreos/ignition/issues/1081
@@ -190,7 +197,7 @@ func fetchConfigFromDevice(logger *log.Logger, ctx context.Context, label string
 	}
 
 	logger.Debug("creating temporary mount point")
-	mnt, err := ioutil.TempDir("", "ignition-configdrive")
+	mnt, err := os.MkdirTemp("", "ignition-configdrive")
 	if err != nil {
 		return nil, fmt.Errorf("failed to create temp directory: %v", err)
 	}
@@ -213,7 +220,7 @@ func fetchConfigFromDevice(logger *log.Logger, ctx context.Context, label string
 		return nil, nil
 	}
 
-	return ioutil.ReadFile(filepath.Join(mnt, configDriveUserdataPath))
+	return os.ReadFile(filepath.Join(mnt, configDriveUserdataPath))
 }
 
 func fetchConfigFromMetadataService(f *resource.Fetcher) ([]byte, error) {
diff --git a/internal/providers/cmdline/cmdline.go b/internal/providers/cmdline/cmdline.go
index 37d246c7..0a279257 100644
--- a/internal/providers/cmdline/cmdline.go
+++ b/internal/providers/cmdline/cmdline.go
@@ -18,14 +18,14 @@
 package cmdline
 
 import (
-	"io/ioutil"
 	"net/url"
+	"os"
 	"strings"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
-	"github.com/coreos/ignition/v2/internal/providers"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -36,14 +36,23 @@ const (
 	cmdlineUrlFlag = "ignition.config.url"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+var (
+	// we are a special-cased system provider; don't register ourselves
+	// for lookup by name
+	Config = platform.NewConfig(platform.Provider{
+		Name:  "cmdline",
+		Fetch: fetchConfig,
+	})
+)
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	url, err := readCmdline(f.Logger)
 	if err != nil {
 		return types.Config{}, report.Report{}, err
 	}
 
 	if url == nil {
-		return types.Config{}, report.Report{}, providers.ErrNoProvider
+		return types.Config{}, report.Report{}, platform.ErrNoProvider
 	}
 
 	data, err := f.FetchToBuffer(*url, resource.FetchOptions{})
@@ -55,7 +64,7 @@ func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 }
 
 func readCmdline(logger *log.Logger) (*url.URL, error) {
-	args, err := ioutil.ReadFile(distro.KernelCmdlinePath())
+	args, err := os.ReadFile(distro.KernelCmdlinePath())
 	if err != nil {
 		logger.Err("couldn't read cmdline: %v", err)
 		return nil, err
diff --git a/internal/providers/digitalocean/digitalocean.go b/internal/providers/digitalocean/digitalocean.go
index 928bd272..67d0a852 100644
--- a/internal/providers/digitalocean/digitalocean.go
+++ b/internal/providers/digitalocean/digitalocean.go
@@ -20,7 +20,8 @@ package digitalocean
 import (
 	"net/url"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -35,7 +36,14 @@ var (
 	}
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "digitalocean",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	data, err := f.FetchToBuffer(userdataUrl, resource.FetchOptions{})
 	if err != nil {
 		return types.Config{}, report.Report{}, err
diff --git a/internal/providers/exoscale/exoscale.go b/internal/providers/exoscale/exoscale.go
index 265e904d..44455acf 100644
--- a/internal/providers/exoscale/exoscale.go
+++ b/internal/providers/exoscale/exoscale.go
@@ -20,7 +20,8 @@ package exoscale
 import (
 	"net/url"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -35,8 +36,15 @@ var (
 	}
 )
 
-// FetchConfig fetch Exoscale ign user-data config
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "exoscale",
+		Fetch: fetchConfig,
+	})
+}
+
+// fetchConfig fetch Exoscale ign user-data config
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	data, err := f.FetchToBuffer(userdataURL, resource.FetchOptions{})
 	if err != nil && err != resource.ErrNotFound {
 		return types.Config{}, report.Report{}, err
diff --git a/internal/providers/file/file.go b/internal/providers/file/file.go
index 794df19a..02244911 100644
--- a/internal/providers/file/file.go
+++ b/internal/providers/file/file.go
@@ -15,10 +15,10 @@
 package file
 
 import (
-	"io/ioutil"
 	"os"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -30,7 +30,14 @@ const (
 	defaultFilename   = "config.ign"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "file",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	filename := os.Getenv(cfgFilenameEnvVar)
 	if filename == "" {
 		filename = defaultFilename
@@ -38,7 +45,7 @@ func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	}
 	f.Logger.Info("using config file at %q", filename)
 
-	rawConfig, err := ioutil.ReadFile(filename)
+	rawConfig, err := os.ReadFile(filename)
 	if err != nil {
 		f.Logger.Err("couldn't read config %q: %v", filename, err)
 		return types.Config{}, report.Report{}, err
diff --git a/internal/providers/gcp/gcp.go b/internal/providers/gcp/gcp.go
index 5fbdd648..c8663614 100644
--- a/internal/providers/gcp/gcp.go
+++ b/internal/providers/gcp/gcp.go
@@ -21,7 +21,8 @@ import (
 	"net/http"
 	"net/url"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -38,7 +39,14 @@ var (
 	metadataHeaderVal = "Google"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "gcp",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	headers := make(http.Header)
 	headers.Set(metadataHeaderKey, metadataHeaderVal)
 	data, err := f.FetchToBuffer(userdataUrl, resource.FetchOptions{
diff --git a/internal/providers/hetzner/hetzner.go b/internal/providers/hetzner/hetzner.go
new file mode 100644
index 00000000..34aa9b84
--- /dev/null
+++ b/internal/providers/hetzner/hetzner.go
@@ -0,0 +1,54 @@
+// Copyright 2023 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// The hetzner provider fetches a remote configuration from the Hetzner Cloud
+// user-data metadata service URL.
+
+package hetzner
+
+import (
+	"net/url"
+
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
+	"github.com/coreos/ignition/v2/internal/providers/util"
+	"github.com/coreos/ignition/v2/internal/resource"
+
+	"github.com/coreos/vcontext/report"
+)
+
+var (
+	userdataURL = url.URL{
+		Scheme: "http",
+		Host:   "169.254.169.254",
+		Path:   "hetzner/v1/userdata",
+	}
+)
+
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "hetzner",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+	data, err := f.FetchToBuffer(userdataURL, resource.FetchOptions{})
+
+	if err != nil && err != resource.ErrNotFound {
+		return types.Config{}, report.Report{}, err
+	}
+
+	return util.ParseConfig(f.Logger, data)
+}
diff --git a/internal/providers/hyperv/kvp.go b/internal/providers/hyperv/kvp.go
new file mode 100644
index 00000000..13e43491
--- /dev/null
+++ b/internal/providers/hyperv/kvp.go
@@ -0,0 +1,106 @@
+// Copyright 2023 Red Hat
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package hyperv
+
+import (
+	"fmt"
+	"os/exec"
+	"path/filepath"
+
+	"github.com/containers/libhvee/pkg/kvp"
+	"github.com/coreos/ignition/v2/config/shared/errors"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/distro"
+	"github.com/coreos/ignition/v2/internal/platform"
+	"github.com/coreos/ignition/v2/internal/providers/util"
+	"github.com/coreos/ignition/v2/internal/resource"
+	"github.com/coreos/vcontext/report"
+)
+
+const singleKey = "ignition.config"
+
+// Prefix for multiple config fragments to reassemble.  The suffix is a
+// sequential integer starting from 0.
+const splitKeyPrefix = "ignition.config."
+
+func init() {
+	platform.Register(platform.Provider{
+		Name:           "hyperv",
+		FetchWithFiles: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) ([]types.File, types.Config, report.Report, error) {
+	var kvpFiles []types.File
+
+	// To read key-value pairs from the Windows host, the hv_util kernel
+	// module must be loaded to create the kernel device
+	_, err := f.Logger.LogCmd(exec.Command(distro.ModprobeCmd(), "hv_utils"), "loading hv_utils kernel module")
+	if err != nil {
+		return nil, types.Config{}, report.Report{}, fmt.Errorf("loading hv_utils kernel module: %w", err)
+	}
+
+	keyValuePairs, err := kvp.GetKeyValuePairs()
+	if err != nil {
+		return nil, types.Config{}, report.Report{}, fmt.Errorf("reading key-value pairs: %w", err)
+	}
+
+	var ign string
+	kv, err := keyValuePairs[kvp.DefaultKVPPoolID].GetValueByKey(singleKey)
+	if err == nil {
+		f.Logger.Debug("found single KVP key")
+		ign = kv.Value
+	} else if err != kvp.ErrKeyNotFound {
+		return nil, types.Config{}, report.Report{}, fmt.Errorf("looking up single KVP key: %w", err)
+	}
+
+	if ign == "" {
+		ign, err = keyValuePairs.GetSplitKeyValues(splitKeyPrefix, kvp.DefaultKVPPoolID)
+		if err == nil {
+			f.Logger.Debug("found concatenated KVP keys")
+		} else if err != kvp.ErrNoKeyValuePairsFound {
+			return nil, types.Config{}, report.Report{}, fmt.Errorf("reassembling split config: %w", err)
+		}
+	}
+
+	// hv_kvp_daemon writes pools to the filesystem in /var/lib/hyperv.
+	// We've already read the pool data, and the host won't send it again
+	// on this boot, so we need to write the files ourselves.
+	for poolID := range keyValuePairs {
+		// hv_kvp_daemon writes the pool files with mode 644 in a
+		// directory with mode 755.  This isn't safe for us, since
+		// it leaks the config to non-root users, including on
+		// subsequent boots.
+		// - There's no API that lets us delete the KVPs from the host.
+		// - We could filter out the KVPs when writing the pools,
+		//   but if hv_kvp_daemon runs on subsequent boots, it could
+		//   re-add them.
+		// - The caller doesn't give us a way to create directory
+		//   entries, only files; and we probably shouldn't set
+		//   restrictive permissions on /var/lib/hyperv because it
+		//   hypothetically might be used for other purposes.
+		// Avoid the issue by setting the files to mode 600.
+		// hv_kvp_daemon won't change the mode afterward.
+		poolPath := filepath.Join(kvp.DefaultKVPFilePath, fmt.Sprintf("%s%d", kvp.DefaultKVPBaseName, poolID))
+		kvpFiles = append(kvpFiles, util.MakeProviderOutputFile(poolPath, 0600, keyValuePairs.EncodePoolFile(poolID)))
+	}
+
+	if ign == "" {
+		return kvpFiles, types.Config{}, report.Report{}, errors.ErrEmpty
+	}
+
+	c, r, err := util.ParseConfig(f.Logger, []byte(ign))
+	return kvpFiles, c, r, err
+}
diff --git a/internal/providers/ibmcloud/ibmcloud.go b/internal/providers/ibmcloud/ibmcloud.go
index 83bb8952..fb742b92 100644
--- a/internal/providers/ibmcloud/ibmcloud.go
+++ b/internal/providers/ibmcloud/ibmcloud.go
@@ -22,15 +22,15 @@ package ibmcloud
 import (
 	"context"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"os/exec"
 	"path/filepath"
 	"time"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 	ut "github.com/coreos/ignition/v2/internal/util"
@@ -43,7 +43,14 @@ const (
 	deviceLabel = "cidata"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "ibmcloud",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	var data []byte
 	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
 
@@ -92,7 +99,7 @@ func fetchConfigFromDevice(logger *log.Logger, ctx context.Context, path string)
 	}
 
 	logger.Debug("creating temporary mount point")
-	mnt, err := ioutil.TempDir("", "ignition-configdrive")
+	mnt, err := os.MkdirTemp("", "ignition-configdrive")
 	if err != nil {
 		return nil, fmt.Errorf("failed to create temp directory: %v", err)
 	}
@@ -115,5 +122,5 @@ func fetchConfigFromDevice(logger *log.Logger, ctx context.Context, path string)
 		return nil, nil
 	}
 
-	return ioutil.ReadFile(filepath.Join(mnt, cidataPath))
+	return os.ReadFile(filepath.Join(mnt, cidataPath))
 }
diff --git a/internal/providers/kubevirt/kubevirt.go b/internal/providers/kubevirt/kubevirt.go
index ca7ef67b..88d1e2b6 100644
--- a/internal/providers/kubevirt/kubevirt.go
+++ b/internal/providers/kubevirt/kubevirt.go
@@ -20,15 +20,15 @@ package kubevirt
 
 import (
 	"fmt"
-	"io/ioutil"
 	"os"
 	"os/exec"
 	"path/filepath"
 	"time"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 	ut "github.com/coreos/ignition/v2/internal/util"
@@ -40,7 +40,14 @@ const (
 	configDriveUserdataPath = "/openstack/latest/user_data"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "kubevirt",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	data, err := fetchConfigFromDevice(f.Logger, filepath.Join(distro.DiskByLabelDir(), "config-2"))
 	if err != nil {
 		return types.Config{}, report.Report{}, err
@@ -63,7 +70,7 @@ func fetchConfigFromDevice(logger *log.Logger, path string) ([]byte, error) {
 	}
 
 	logger.Debug("creating temporary mount point")
-	mnt, err := ioutil.TempDir("", "ignition-configdrive")
+	mnt, err := os.MkdirTemp("", "ignition-configdrive")
 	if err != nil {
 		return nil, fmt.Errorf("failed to create temp directory: %v", err)
 	}
@@ -87,5 +94,5 @@ func fetchConfigFromDevice(logger *log.Logger, path string) ([]byte, error) {
 		return nil, nil
 	}
 
-	return ioutil.ReadFile(mntConfigDriveUserdataPath)
+	return os.ReadFile(mntConfigDriveUserdataPath)
 }
diff --git a/internal/providers/noop/noop.go b/internal/providers/metal/metal.go
similarity index 68%
rename from internal/providers/noop/noop.go
rename to internal/providers/metal/metal.go
index cfc20174..1b65c11a 100644
--- a/internal/providers/noop/noop.go
+++ b/internal/providers/metal/metal.go
@@ -12,19 +12,27 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-// The noop provider does nothing, for use by unimplemented platforms.
+// The metal provider does nothing.
 
-package noop
+package metal
 
 import (
 	"github.com/coreos/ignition/v2/config/shared/errors"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/resource"
 
 	"github.com/coreos/vcontext/report"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
-	f.Logger.Debug("noop provider fetching empty config")
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "metal",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+	f.Logger.Debug("metal provider fetching empty config")
 	return types.Config{}, report.Report{}, errors.ErrEmpty
 }
diff --git a/internal/providers/nutanix/nutanix.go b/internal/providers/nutanix/nutanix.go
index c46beab4..7fbcad58 100644
--- a/internal/providers/nutanix/nutanix.go
+++ b/internal/providers/nutanix/nutanix.go
@@ -20,15 +20,15 @@ package nutanix
 
 import (
 	"fmt"
-	"io/ioutil"
 	"os"
 	"os/exec"
 	"path/filepath"
 	"time"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 	ut "github.com/coreos/ignition/v2/internal/util"
@@ -40,7 +40,14 @@ const (
 	configDriveUserdataPath = "/openstack/latest/user_data"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "nutanix",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	data, err := fetchConfigFromDevice(f.Logger, filepath.Join(distro.DiskByLabelDir(), "config-2"))
 	if err != nil {
 		return types.Config{}, report.Report{}, err
@@ -62,7 +69,7 @@ func fetchConfigFromDevice(logger *log.Logger, path string) ([]byte, error) {
 	}
 
 	logger.Debug("creating temporary mount point")
-	mnt, err := ioutil.TempDir("", "ignition-configdrive")
+	mnt, err := os.MkdirTemp("", "ignition-configdrive")
 	if err != nil {
 		return nil, fmt.Errorf("failed to create temp directory: %v", err)
 	}
@@ -86,5 +93,5 @@ func fetchConfigFromDevice(logger *log.Logger, path string) ([]byte, error) {
 		return nil, nil
 	}
 
-	return ioutil.ReadFile(mntConfigDriveUserdataPath)
+	return os.ReadFile(mntConfigDriveUserdataPath)
 }
diff --git a/internal/providers/openstack/openstack.go b/internal/providers/openstack/openstack.go
index 832cbf08..4ef352cf 100644
--- a/internal/providers/openstack/openstack.go
+++ b/internal/providers/openstack/openstack.go
@@ -22,16 +22,16 @@ package openstack
 import (
 	"context"
 	"fmt"
-	"io/ioutil"
 	"net/url"
 	"os"
 	"os/exec"
 	"path/filepath"
 	"time"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 	ut "github.com/coreos/ignition/v2/internal/util"
@@ -51,7 +51,19 @@ var (
 	}
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "openstack",
+		Fetch: fetchConfig,
+	})
+	// the brightbox platform ID just uses the OpenStack provider code
+	platform.Register(platform.Provider{
+		Name:  "brightbox",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	// The fetch-offline approach doesn't work well here because of the "split
 	// personality" of this provider. See:
 	// https://github.com/coreos/ignition/issues/1081
@@ -128,7 +140,7 @@ func fetchConfigFromDevice(logger *log.Logger, ctx context.Context, path string)
 	}
 
 	logger.Debug("creating temporary mount point")
-	mnt, err := ioutil.TempDir("", "ignition-configdrive")
+	mnt, err := os.MkdirTemp("", "ignition-configdrive")
 	if err != nil {
 		return nil, fmt.Errorf("failed to create temp directory: %v", err)
 	}
@@ -151,7 +163,7 @@ func fetchConfigFromDevice(logger *log.Logger, ctx context.Context, path string)
 		return nil, nil
 	}
 
-	return ioutil.ReadFile(filepath.Join(mnt, configDriveUserdataPath))
+	return os.ReadFile(filepath.Join(mnt, configDriveUserdataPath))
 }
 
 func fetchConfigFromMetadataService(f *resource.Fetcher) ([]byte, error) {
diff --git a/internal/providers/packet/packet.go b/internal/providers/packet/packet.go
index 29b6c161..c2ecbfc1 100644
--- a/internal/providers/packet/packet.go
+++ b/internal/providers/packet/packet.go
@@ -25,7 +25,8 @@ import (
 	"net/url"
 	"strings"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -52,7 +53,15 @@ var (
 	}
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:   "packet",
+		Fetch:  fetchConfig,
+		Status: postStatus,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	// Packet's metadata service returns "Not Acceptable" when queried
 	// with the default Accept header.
 	headers := make(http.Header)
@@ -68,7 +77,7 @@ func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 }
 
 // PostStatus posts a message that will show on the Packet Instance Timeline
-func PostStatus(stageName string, f resource.Fetcher, errMsg error) error {
+func postStatus(stageName string, f resource.Fetcher, errMsg error) error {
 	f.Logger.Info("POST message to Packet Timeline")
 	// fetch JSON from https://metadata.packet.net/metadata
 	headers := make(http.Header)
diff --git a/internal/providers/powervs/powervs.go b/internal/providers/powervs/powervs.go
index fe41ec95..918277a1 100644
--- a/internal/providers/powervs/powervs.go
+++ b/internal/providers/powervs/powervs.go
@@ -19,15 +19,15 @@ package powervs
 
 import (
 	"fmt"
-	"io/ioutil"
 	"os"
 	"os/exec"
 	"path/filepath"
 	"time"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 	ut "github.com/coreos/ignition/v2/internal/util"
@@ -39,7 +39,14 @@ const (
 	configDriveUserdataPath = "/openstack/latest/user_data"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "powervs",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	data, err := fetchConfigFromDevice(f.Logger, filepath.Join(distro.DiskByLabelDir(), "config-2"))
 	if err != nil {
 		return types.Config{}, report.Report{}, err
@@ -60,7 +67,7 @@ func fetchConfigFromDevice(logger *log.Logger, path string) ([]byte, error) {
 	}
 
 	logger.Debug("creating temporary mount point")
-	mnt, err := ioutil.TempDir("", "ignition-configdrive")
+	mnt, err := os.MkdirTemp("", "ignition-configdrive")
 	if err != nil {
 		return nil, fmt.Errorf("failed to create temp directory: %v", err)
 	}
@@ -83,5 +90,5 @@ func fetchConfigFromDevice(logger *log.Logger, path string) ([]byte, error) {
 		return nil, nil
 	}
 
-	return ioutil.ReadFile(filepath.Join(mnt, configDriveUserdataPath))
+	return os.ReadFile(filepath.Join(mnt, configDriveUserdataPath))
 }
diff --git a/internal/providers/providers.go b/internal/providers/providers.go
index daa80bfb..1edc2b9c 100644
--- a/internal/providers/providers.go
+++ b/internal/providers/providers.go
@@ -13,23 +13,3 @@
 // limitations under the License.
 
 package providers
-
-import (
-	"errors"
-
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
-	"github.com/coreos/ignition/v2/internal/log"
-	"github.com/coreos/ignition/v2/internal/resource"
-
-	"github.com/coreos/vcontext/report"
-)
-
-var (
-	ErrNoProvider = errors.New("config provider was not online")
-)
-
-type FuncFetchConfig func(f *resource.Fetcher) (types.Config, report.Report, error)
-type FuncInit func(f *resource.Fetcher) error
-type FuncNewFetcher func(logger *log.Logger) (resource.Fetcher, error)
-type FuncPostStatus func(stageName string, f resource.Fetcher, e error) error
-type FuncDelConfig func(f *resource.Fetcher) error
diff --git a/internal/providers/qemu/qemu_blockdev.go b/internal/providers/qemu/qemu_blockdev.go
index ba05ff6d..778a151d 100644
--- a/internal/providers/qemu/qemu_blockdev.go
+++ b/internal/providers/qemu/qemu_blockdev.go
@@ -23,13 +23,14 @@ package qemu
 import (
 	"bytes"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"os/exec"
 	"time"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -42,10 +43,17 @@ const (
 	blockDevicePollingInterval = 5 * time.Second
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "qemu",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	f.Logger.Warning("Fetching the Ignition config via the Virtio block driver is currently experimental and subject to change.")
 
-	_, err := f.Logger.LogCmd(exec.Command("modprobe", "virtio_blk"), "loading Virtio block driver module")
+	_, err := f.Logger.LogCmd(exec.Command(distro.ModprobeCmd(), "virtio_blk"), "loading Virtio block driver module")
 	if err != nil {
 		return types.Config{}, report.Report{}, err
 	}
@@ -64,7 +72,7 @@ func fetchConfigFromBlockDevice(logger *log.Logger) ([]byte, error) {
 	go func() {
 		var err error
 		for {
-			if data, err = ioutil.ReadFile(ignitionBlockDevicePath); err != nil {
+			if data, err = os.ReadFile(ignitionBlockDevicePath); err != nil {
 				if !os.IsNotExist(err) {
 					break
 				}
diff --git a/internal/providers/qemu/qemu_fwcfg.go b/internal/providers/qemu/qemu_fwcfg.go
index 65c76875..9451981b 100644
--- a/internal/providers/qemu/qemu_fwcfg.go
+++ b/internal/providers/qemu/qemu_fwcfg.go
@@ -23,14 +23,15 @@ package qemu
 
 import (
 	"errors"
-	"io/ioutil"
 	"os"
 	"os/exec"
 	"strconv"
 	"strings"
 	"time"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/distro"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -42,15 +43,22 @@ const (
 	firmwareConfigSizePath = "/sys/firmware/qemu_fw_cfg/by_name/opt/com.coreos/config/size"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "qemu",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	// load qemu_fw_cfg module
-	_, err := f.Logger.LogCmd(exec.Command("modprobe", "qemu_fw_cfg"), "loading QEMU firmware config module")
+	_, err := f.Logger.LogCmd(exec.Command(distro.ModprobeCmd(), "qemu_fw_cfg"), "loading QEMU firmware config module")
 	if err != nil {
 		return types.Config{}, report.Report{}, err
 	}
 
 	// get size of firmware blob, if it exists
-	sizeBytes, err := ioutil.ReadFile(firmwareConfigSizePath)
+	sizeBytes, err := os.ReadFile(firmwareConfigSizePath)
 	if os.IsNotExist(err) {
 		f.Logger.Info("QEMU firmware config was not found. Ignoring...")
 		return util.ParseConfig(f.Logger, []byte{})
@@ -66,7 +74,7 @@ func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 
 	// Read firmware blob.  We need to make as few, large read() calls as
 	// possible, since the qemu_fw_cfg kernel module takes O(offset)
-	// time for each read syscall.  ioutil.ReadFile() would eventually
+	// time for each read syscall.  os.ReadFile() would eventually
 	// converge on the correct read size (one page) but we can do
 	// better, and without reallocating.
 	// Leave an extra guard byte to check for EOF
diff --git a/internal/providers/scaleway/scaleway.go b/internal/providers/scaleway/scaleway.go
new file mode 100644
index 00000000..230519fe
--- /dev/null
+++ b/internal/providers/scaleway/scaleway.go
@@ -0,0 +1,62 @@
+// Copyright 2024 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+// The Scaleway provider fetches a remote configuration from the Scaleway
+// user-data metadata service URL.
+// NOTE: For security reason, Scaleway requires to query user data with a source port below 1024.
+
+package scaleway
+
+import (
+	"math/rand"
+	"net/url"
+
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
+	"github.com/coreos/ignition/v2/internal/providers/util"
+	"github.com/coreos/ignition/v2/internal/resource"
+
+	"github.com/coreos/vcontext/report"
+)
+
+var (
+	userdataURL = url.URL{
+		Scheme: "http",
+		Host:   "169.254.42.42",
+		Path:   "user_data/cloud-init",
+	}
+)
+
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "scaleway",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+	// For security reason, Scaleway requires to query user data with a source port below 1024.
+	port := func() int {
+		return rand.Intn(1022) + 1
+	}
+
+	data, err := f.FetchToBuffer(userdataURL, resource.FetchOptions{
+		LocalPort: port,
+	})
+	if err != nil && err != resource.ErrNotFound {
+		return types.Config{}, report.Report{}, err
+	}
+
+	return util.ParseConfig(f.Logger, data)
+}
diff --git a/internal/providers/system/system.go b/internal/providers/system/system.go
index 36cc2b9f..8762c2a0 100644
--- a/internal/providers/system/system.go
+++ b/internal/providers/system/system.go
@@ -15,15 +15,14 @@
 package system
 
 import (
-	"io/ioutil"
 	"os"
 	"path/filepath"
 
-	latest "github.com/coreos/ignition/v2/config/v3_4_experimental"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	latest "github.com/coreos/ignition/v2/config/v3_5_experimental"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
-	"github.com/coreos/ignition/v2/internal/providers"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -34,6 +33,15 @@ const (
 	userFilename = "user.ign"
 )
 
+var (
+	// we are a special-cased system provider; don't register ourselves
+	// for lookup by name
+	Config = platform.NewConfig(platform.Provider{
+		Name:  "system",
+		Fetch: fetchConfig,
+	})
+)
+
 // FetchBaseConfig fetches base config fragments from the `base.d` and platform config fragments from
 // the `base.platform.d/platform`(if available), and merge them in the right order.
 func FetchBaseConfig(logger *log.Logger, platformName string) (types.Config, report.Report, error) {
@@ -52,18 +60,18 @@ func FetchBaseConfig(logger *log.Logger, platformName string) (types.Config, rep
 	return fullBaseConfig, fullReport, nil
 }
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
-	return fetchConfig(f.Logger, userFilename)
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+	return doFetchConfig(f.Logger, userFilename)
 }
 
-func fetchConfig(logger *log.Logger, filename string) (types.Config, report.Report, error) {
+func doFetchConfig(logger *log.Logger, filename string) (types.Config, report.Report, error) {
 	path := filepath.Join(distro.SystemConfigDir(), filename)
 	logger.Info("reading system config file %q", path)
 
-	rawConfig, err := ioutil.ReadFile(path)
+	rawConfig, err := os.ReadFile(path)
 	if os.IsNotExist(err) {
 		logger.Info("no config at %q", path)
-		return types.Config{}, report.Report{}, providers.ErrNoProvider
+		return types.Config{}, report.Report{}, platform.ErrNoProvider
 	} else if err != nil {
 		logger.Err("couldn't read config %q: %v", path, err)
 		return types.Config{}, report.Report{}, err
@@ -76,7 +84,7 @@ func fetchBaseDirectoryConfig(logger *log.Logger, dir string) (types.Config, rep
 	var baseConfig types.Config
 	var report report.Report
 	path := filepath.Join(distro.SystemConfigDir(), dir)
-	configs, err := ioutil.ReadDir(path)
+	configs, err := os.ReadDir(path)
 	if os.IsNotExist(err) {
 		logger.Info("no config dir at %q", path)
 		return types.Config{}, report, nil
@@ -89,7 +97,7 @@ func fetchBaseDirectoryConfig(logger *log.Logger, dir string) (types.Config, rep
 		return types.Config{}, report, nil
 	}
 	for _, config := range configs {
-		intermediateConfig, intermediateReport, err := fetchConfig(logger, filepath.Join(dir, config.Name()))
+		intermediateConfig, intermediateReport, err := doFetchConfig(logger, filepath.Join(dir, config.Name()))
 		if err != nil {
 			return types.Config{}, intermediateReport, err
 		}
diff --git a/internal/providers/util/config.go b/internal/providers/util/config.go
index 59e4f9b8..a2a56b7d 100644
--- a/internal/providers/util/config.go
+++ b/internal/providers/util/config.go
@@ -19,7 +19,7 @@ import (
 	"encoding/hex"
 
 	"github.com/coreos/ignition/v2/config"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/log"
 
 	"github.com/coreos/vcontext/report"
diff --git a/internal/providers/util/file.go b/internal/providers/util/file.go
new file mode 100644
index 00000000..054219cb
--- /dev/null
+++ b/internal/providers/util/file.go
@@ -0,0 +1,42 @@
+// Copyright 2023 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package util
+
+import (
+	"github.com/coreos/ignition/v2/config/util"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+
+	"github.com/vincent-petithory/dataurl"
+)
+
+// MakeProviderOutputFile is a helper function to create an output File for
+// FetchWithFiles.
+func MakeProviderOutputFile(path string, mode int, data []byte) types.File {
+	url := dataurl.EncodeBytes(data)
+	return types.File{
+		Node: types.Node{
+			Path: path,
+			// Ignition is not designed to run twice, but don't
+			// introduce a hard failure if it does
+			Overwrite: util.BoolToPtr(true),
+		},
+		FileEmbedded1: types.FileEmbedded1{
+			Contents: types.Resource{
+				Source: &url,
+			},
+			Mode: &mode,
+		},
+	}
+}
diff --git a/internal/providers/virtualbox/virtualbox.c b/internal/providers/virtualbox/virtualbox.c
index a2783d8a..9ae3e199 100644
--- a/internal/providers/virtualbox/virtualbox.c
+++ b/internal/providers/virtualbox/virtualbox.c
@@ -96,6 +96,9 @@ static int get_prop(int fd, uint32_t client_id, const char *name, void **value,
 	// init header
 	size_t msg_size = sizeof(struct vbg_ioctl_hgcm_call) + 4 * sizeof(struct vmmdev_hgcm_function_parameter64);
 	struct vbg_ioctl_hgcm_call _cleanup_free_ *msg = calloc(1, msg_size);
+	if (msg == NULL) {
+		return VERR_NO_MEMORY;
+	}
 	// init_header re-adds the size of msg->hdr
 	init_header(&msg->hdr, msg_size - sizeof(msg->hdr), msg_size - sizeof(msg->hdr));
 	msg->client_id = client_id;
@@ -131,6 +134,9 @@ static int get_prop(int fd, uint32_t client_id, const char *name, void **value,
 		; // labels can't point to declarations
 		size_t buf_size = params[3].u.value32;
 		void _cleanup_free_ *buf = malloc(buf_size);
+		if (buf == NULL) {
+			return VERR_NO_MEMORY;
+		}
 		params[1].u.pointer.size = buf_size;
 		params[1].u.pointer.u.linear_addr = (uintptr_t) buf;
 
@@ -161,6 +167,9 @@ static int del_prop(int fd, uint32_t client_id, const char *name) {
 	// init header
 	size_t msg_size = sizeof(struct vbg_ioctl_hgcm_call) + sizeof(struct vmmdev_hgcm_function_parameter64);
 	struct vbg_ioctl_hgcm_call _cleanup_free_ *msg = calloc(1, msg_size);
+	if (msg == NULL) {
+		return VERR_NO_MEMORY;
+	}
 	// init_header re-adds the size of msg->hdr
 	init_header(&msg->hdr, msg_size - sizeof(msg->hdr), msg_size - sizeof(msg->hdr));
 	msg->client_id = client_id;
diff --git a/internal/providers/virtualbox/virtualbox.go b/internal/providers/virtualbox/virtualbox.go
index e37304c0..dcf18367 100644
--- a/internal/providers/virtualbox/virtualbox.go
+++ b/internal/providers/virtualbox/virtualbox.go
@@ -32,7 +32,8 @@ import (
 	"unsafe"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -44,7 +45,15 @@ const (
 	configEncodingProperty = "/Ignition/Config/Encoding"
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:      "virtualbox",
+		Fetch:     fetchConfig,
+		DelConfig: delConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	f.Logger.Debug("reading Ignition config from VirtualBox guest property")
 
 	// for forward compatibility, check an encoding property analogous
@@ -69,7 +78,7 @@ func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	return util.ParseConfig(f.Logger, config)
 }
 
-func DelConfig(f *resource.Fetcher) error {
+func delConfig(f *resource.Fetcher) error {
 	f.Logger.Info("deleting Ignition config from VirtualBox guest property")
 	err := deleteProperty(configEncodingProperty)
 	if err != nil {
diff --git a/internal/providers/vmware/ovf.go b/internal/providers/vmware/ovf.go
index c95e4cac..7a035a08 100644
--- a/internal/providers/vmware/ovf.go
+++ b/internal/providers/vmware/ovf.go
@@ -27,30 +27,30 @@ const (
 	XMLNS = "http://schemas.dmtf.org/ovf/environment/1"
 )
 
-type environment struct {
-	Platform   platform   `xml:"PlatformSection"`
-	Properties []property `xml:"PropertySection>Property"`
+type ovfEnvironment struct {
+	Platform   ovfPlatform   `xml:"PlatformSection"`
+	Properties []ovfProperty `xml:"PropertySection>Property"`
 }
 
-type platform struct {
+type ovfPlatform struct {
 	Kind    string `xml:"Kind"`
 	Version string `xml:"Version"`
 	Vendor  string `xml:"Vendor"`
 	Locale  string `xml:"Locale"`
 }
 
-type property struct {
+type ovfProperty struct {
 	Key   string `xml:"key,attr"`
 	Value string `xml:"value,attr"`
 }
 
 type OvfEnvironment struct {
-	Platform   platform
+	Platform   ovfPlatform
 	Properties map[string]string
 }
 
 func ReadOvfEnvironment(doc []byte) (OvfEnvironment, error) {
-	var env environment
+	var env ovfEnvironment
 	if err := xml.Unmarshal(doc, &env); err != nil {
 		return OvfEnvironment{}, err
 	}
diff --git a/internal/providers/vmware/vmware.go b/internal/providers/vmware/vmware.go
index 6fd53ed7..a490d609 100644
--- a/internal/providers/vmware/vmware.go
+++ b/internal/providers/vmware/vmware.go
@@ -21,7 +21,7 @@ import (
 	"compress/gzip"
 	"encoding/base64"
 	"fmt"
-	"io/ioutil"
+	"io"
 	"strings"
 )
 
@@ -70,5 +70,5 @@ func decodeGzipData(data string) ([]byte, error) {
 	}
 	defer reader.Close()
 
-	return ioutil.ReadAll(reader)
+	return io.ReadAll(reader)
 }
diff --git a/internal/providers/vmware/vmware_amd64.go b/internal/providers/vmware/vmware_amd64.go
index 186ec97d..b9777fcd 100644
--- a/internal/providers/vmware/vmware_amd64.go
+++ b/internal/providers/vmware/vmware_amd64.go
@@ -20,8 +20,8 @@ package vmware
 import (
 	"fmt"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
-	"github.com/coreos/ignition/v2/internal/providers"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -43,11 +43,19 @@ const (
 	OVF_USERDATA_ENCODING = OVF_PREFIX + GUESTINFO_USERDATA_ENCODING
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:      "vmware",
+		Fetch:     fetchConfig,
+		DelConfig: delConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	if isVM, err := vmcheck.IsVirtualWorld(true); err != nil {
 		return types.Config{}, report.Report{}, err
 	} else if !isVM {
-		return types.Config{}, report.Report{}, providers.ErrNoProvider
+		return types.Config{}, report.Report{}, platform.ErrNoProvider
 	}
 
 	config, err := fetchRawConfig(f)
@@ -103,7 +111,7 @@ func fetchRawConfig(f *resource.Fetcher) (config, error) {
 	}, nil
 }
 
-func DelConfig(f *resource.Fetcher) error {
+func delConfig(f *resource.Fetcher) error {
 	info := rpcvmx.NewConfig()
 
 	// delete userdata if set and not already a deletion marker
@@ -133,7 +141,7 @@ func DelConfig(f *resource.Fetcher) error {
 
 	ovfEnv, err := info.String(GUESTINFO_OVF, "")
 	if err != nil {
-		// unlike FetchConfig, don't ignore errors, since that could
+		// unlike fetchConfig, don't ignore errors, since that could
 		// have security implications
 		return fmt.Errorf("reading OVF environment: %w", err)
 	}
diff --git a/internal/providers/vmware/vmware_unsupported.go b/internal/providers/vmware/vmware_unsupported.go
index e9e26cca..a1ea208e 100644
--- a/internal/providers/vmware/vmware_unsupported.go
+++ b/internal/providers/vmware/vmware_unsupported.go
@@ -23,16 +23,25 @@ package vmware
 import (
 	"errors"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/resource"
 
 	"github.com/coreos/vcontext/report"
 )
 
-func FetchConfig(_ *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:      "vmware",
+		Fetch:     fetchConfig,
+		DelConfig: delConfig,
+	})
+}
+
+func fetchConfig(_ *resource.Fetcher) (types.Config, report.Report, error) {
 	return types.Config{}, report.Report{}, errors.New("vmware provider is not supported on this architecture")
 }
 
-func DelConfig(_ *resource.Fetcher) error {
+func delConfig(_ *resource.Fetcher) error {
 	return errors.New("vmware provider is not supported on this architecture")
 }
diff --git a/internal/providers/vultr/vultr.go b/internal/providers/vultr/vultr.go
index e691d20b..496653b9 100644
--- a/internal/providers/vultr/vultr.go
+++ b/internal/providers/vultr/vultr.go
@@ -21,7 +21,8 @@ package vultr
 import (
 	"net/url"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 
@@ -36,7 +37,14 @@ var (
 	}
 )
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "vultr",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	data, err := f.FetchToBuffer(userdataUrl, resource.FetchOptions{})
 	if err != nil && err != resource.ErrNotFound {
 		return types.Config{}, report.Report{}, err
diff --git a/internal/providers/zvm/zvm.go b/internal/providers/zvm/zvm.go
index d8a743c6..84f66ec3 100644
--- a/internal/providers/zvm/zvm.go
+++ b/internal/providers/zvm/zvm.go
@@ -20,14 +20,15 @@ package zvm
 import (
 	"bytes"
 	"fmt"
-	"io/ioutil"
+	"os"
 	"os/exec"
 	"strings"
 
 	"github.com/coreos/ignition/v2/config/shared/errors"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
+	"github.com/coreos/ignition/v2/internal/platform"
 	"github.com/coreos/ignition/v2/internal/providers/util"
 	"github.com/coreos/ignition/v2/internal/resource"
 	"github.com/coreos/vcontext/report"
@@ -35,7 +36,14 @@ import (
 
 const readerDevice string = "000c"
 
-func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
+func init() {
+	platform.Register(platform.Provider{
+		Name:  "zvm",
+		Fetch: fetchConfig,
+	})
+}
+
+func fetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 	// Fetch config files directly from reader device.
 	_, err := f.Logger.LogCmd(exec.Command(distro.ModprobeCmd(), "vmur"), "Loading zVM control program module")
 	if err != nil {
@@ -75,7 +83,7 @@ func FetchConfig(f *resource.Fetcher) (types.Config, report.Report, error) {
 				return types.Config{}, report.Report{}, err
 			}
 			f.Logger.Info("using config file at %q", file)
-			rawConfig, err := ioutil.ReadFile(file)
+			rawConfig, err := os.ReadFile(file)
 			if err != nil {
 				f.Logger.Err("Couldn't read config from configFile %q: %v", file, err)
 				break
diff --git a/internal/register/providers.go b/internal/register/providers.go
new file mode 100644
index 00000000..e7a06b38
--- /dev/null
+++ b/internal/register/providers.go
@@ -0,0 +1,43 @@
+// Copyright 2023 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package register
+
+import (
+	_ "github.com/coreos/ignition/v2/internal/providers/aliyun"
+	_ "github.com/coreos/ignition/v2/internal/providers/applehv"
+	_ "github.com/coreos/ignition/v2/internal/providers/aws"
+	_ "github.com/coreos/ignition/v2/internal/providers/azure"
+	_ "github.com/coreos/ignition/v2/internal/providers/azurestack"
+	_ "github.com/coreos/ignition/v2/internal/providers/cloudstack"
+	_ "github.com/coreos/ignition/v2/internal/providers/digitalocean"
+	_ "github.com/coreos/ignition/v2/internal/providers/exoscale"
+	_ "github.com/coreos/ignition/v2/internal/providers/file"
+	_ "github.com/coreos/ignition/v2/internal/providers/gcp"
+	_ "github.com/coreos/ignition/v2/internal/providers/hetzner"
+	_ "github.com/coreos/ignition/v2/internal/providers/hyperv"
+	_ "github.com/coreos/ignition/v2/internal/providers/ibmcloud"
+	_ "github.com/coreos/ignition/v2/internal/providers/kubevirt"
+	_ "github.com/coreos/ignition/v2/internal/providers/metal"
+	_ "github.com/coreos/ignition/v2/internal/providers/nutanix"
+	_ "github.com/coreos/ignition/v2/internal/providers/openstack"
+	_ "github.com/coreos/ignition/v2/internal/providers/packet"
+	_ "github.com/coreos/ignition/v2/internal/providers/powervs"
+	_ "github.com/coreos/ignition/v2/internal/providers/qemu"
+	_ "github.com/coreos/ignition/v2/internal/providers/scaleway"
+	_ "github.com/coreos/ignition/v2/internal/providers/virtualbox"
+	_ "github.com/coreos/ignition/v2/internal/providers/vmware"
+	_ "github.com/coreos/ignition/v2/internal/providers/vultr"
+	_ "github.com/coreos/ignition/v2/internal/providers/zvm"
+)
diff --git a/internal/register/stages.go b/internal/register/stages.go
new file mode 100644
index 00000000..98c05214
--- /dev/null
+++ b/internal/register/stages.go
@@ -0,0 +1,25 @@
+// Copyright 2023 Red Hat, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package register
+
+import (
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/disks"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/fetch"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/fetch_offline"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/files"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/kargs"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/mount"
+	_ "github.com/coreos/ignition/v2/internal/exec/stages/umount"
+)
diff --git a/internal/resource/http.go b/internal/resource/http.go
index 471349a1..872ce253 100644
--- a/internal/resource/http.go
+++ b/internal/resource/http.go
@@ -29,7 +29,7 @@ import (
 	"time"
 
 	ignerrors "github.com/coreos/ignition/v2/config/shared/errors"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/earlyrand"
 	"github.com/coreos/ignition/v2/internal/log"
 	"github.com/coreos/ignition/v2/internal/util"
@@ -263,6 +263,21 @@ func (f *Fetcher) newHttpClient() error {
 	return nil
 }
 
+func shouldRetryHttp(statusCode int, opts FetchOptions) bool {
+	// we always retry 500+
+	if statusCode >= 500 {
+		return true
+	}
+
+	for _, retryCode := range opts.RetryCodes {
+		if statusCode == retryCode {
+			return true
+		}
+	}
+
+	return false
+}
+
 // httpReaderWithHeader performs an HTTP request on the provided URL with the
 // provided request header & method and returns the response body Reader, HTTP
 // status code, a cancel function for the result's context, and error (if any).
@@ -298,7 +313,7 @@ func (c HttpClient) httpReaderWithHeader(opts FetchOptions, url string) (io.Read
 
 		if err == nil {
 			c.logger.Info("%s result: %s", opts.HTTPVerb, http.StatusText(resp.StatusCode))
-			if resp.StatusCode < 500 {
+			if !shouldRetryHttp(resp.StatusCode, opts) {
 				return resp.Body, resp.StatusCode, cancelFn, nil
 			}
 			resp.Body.Close()
diff --git a/internal/resource/url.go b/internal/resource/url.go
index 2696b697..ad548a49 100644
--- a/internal/resource/url.go
+++ b/internal/resource/url.go
@@ -23,11 +23,12 @@ import (
 	"fmt"
 	"hash"
 	"io"
-	"io/ioutil"
+	"net"
 	"net/http"
 	"net/url"
 	"os"
 	"strings"
+	"syscall"
 	"time"
 
 	"cloud.google.com/go/compute/metadata"
@@ -61,7 +62,7 @@ var (
 	// config is being fetched
 	configHeaders = http.Header{
 		"Accept-Encoding": []string{"identity"},
-		"Accept":          []string{"application/vnd.coreos.ignition+json;version=3.3.0, */*;q=0.1"},
+		"Accept":          []string{"application/vnd.coreos.ignition+json;version=3.4.0, */*;q=0.1"},
 	}
 
 	// We could derive this info from aws-sdk-go/aws/endpoints/defaults.go,
@@ -126,6 +127,14 @@ type FetchOptions struct {
 	// HTTPVerb is an HTTP request method to indicate the desired action to
 	// be performed for a given resource.
 	HTTPVerb string
+
+	// LocalPort is a function returning a local port used to establish the TCP connection.
+	// Most of the time, letting the Kernel choose a random port is enough.
+	LocalPort func() int
+
+	// List of HTTP codes to retry that usually would be considered as complete.
+	// Status codes >= 500 are always retried.
+	RetryCodes []int
 }
 
 // FetchToBuffer will fetch the given url into a temporary file, and then read
@@ -282,16 +291,34 @@ func (f *Fetcher) fetchFromTFTP(u url.URL, dest io.Writer, opts FetchOptions) er
 // FetchFromHTTP fetches a resource from u via HTTP(S) into dest, returning an
 // error if one is encountered.
 func (f *Fetcher) fetchFromHTTP(u url.URL, dest io.Writer, opts FetchOptions) error {
-	// for the case when "config is not valid"
-	// this if necessary if not spawned through kola (e.g. Packet Dashboard)
 	if f.client == nil {
-		logger := log.New(true)
-		f.Logger = &logger
 		if err := f.newHttpClient(); err != nil {
 			return err
 		}
 	}
 
+	if opts.LocalPort != nil {
+		var (
+			d net.Dialer
+			p int
+		)
+
+		// Assert that the port is not already used.
+		for {
+			p = opts.LocalPort()
+			l, err := net.Listen("tcp4", fmt.Sprintf(":%d", p))
+			if err != nil && errors.Is(err, syscall.EADDRINUSE) {
+				continue
+			} else if err == nil {
+				l.Close()
+				break
+			}
+		}
+		d.LocalAddr = &net.TCPAddr{Port: p}
+
+		f.client.transport.DialContext = d.DialContext
+	}
+
 	// We do not want to redirect HTTP headers
 	f.client.client.CheckRedirect = func(req *http.Request, via []*http.Request) error {
 		req.Header = make(http.Header)
@@ -532,7 +559,7 @@ func (f *Fetcher) fetchFromS3WithCreds(ctx context.Context, dest s3target, input
 func (f *Fetcher) uncompress(r io.Reader, opts FetchOptions) (io.ReadCloser, error) {
 	switch opts.Compression {
 	case "":
-		return ioutil.NopCloser(r), nil
+		return io.NopCloser(r), nil
 	case "gzip":
 		return gzip.NewReader(r)
 	default:
diff --git a/internal/sgdisk/sgdisk.go b/internal/sgdisk/sgdisk.go
index 3445e2a9..29915809 100644
--- a/internal/sgdisk/sgdisk.go
+++ b/internal/sgdisk/sgdisk.go
@@ -16,11 +16,11 @@ package sgdisk
 
 import (
 	"fmt"
-	"io/ioutil"
+	"io"
 	"os/exec"
 
 	"github.com/coreos/ignition/v2/config/util"
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/internal/distro"
 	"github.com/coreos/ignition/v2/internal/log"
 )
@@ -73,8 +73,8 @@ func (op *Operation) WipeTable(wipe bool) {
 // on stdout for parsing.
 //
 // Note: because sgdisk does not do any escaping on its output, callers should ensure
-//       the partitions' labels do not have any nasty characters that will interfere
-//       with parsing (e.g. \n)
+// the partitions' labels do not have any nasty characters that will interfere
+// with parsing (e.g. \n)
 func (op *Operation) Pretend() (string, error) {
 	opts := []string{"--pretend"}
 	opts = append(opts, op.buildOptions()...)
@@ -93,12 +93,12 @@ func (op *Operation) Pretend() (string, error) {
 	if err := cmd.Start(); err != nil {
 		return "", err
 	}
-	output, err := ioutil.ReadAll(stdout)
+	output, err := io.ReadAll(stdout)
 	if err != nil {
 		return "", err
 	}
 
-	errors, err := ioutil.ReadAll(stderr)
+	errors, err := io.ReadAll(stderr)
 	if err != nil {
 		return "", err
 	}
diff --git a/internal/state/state.go b/internal/state/state.go
index 4e0f68ff..0adff2e8 100644
--- a/internal/state/state.go
+++ b/internal/state/state.go
@@ -17,9 +17,10 @@ package state
 import (
 	"encoding/json"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"path/filepath"
+
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 )
 
 type State struct {
@@ -36,6 +37,10 @@ type State struct {
 	// created by the mount stage so the files stage can chown them
 	// when creating users.
 	NotatedDirectories []string `json:"notatedDirectories"`
+	// Files generated during provider config fetch, to be written to
+	// the filesystem during files stage.  This is for special
+	// circumstances only.
+	ProviderOutputFiles []types.File `json:"providerOutputFiles"`
 }
 
 type FetchedConfig struct {
@@ -45,7 +50,7 @@ type FetchedConfig struct {
 }
 
 func Load(path string) (State, error) {
-	data, err := ioutil.ReadFile(path)
+	data, err := os.ReadFile(path)
 	if os.IsNotExist(err) {
 		// valid; return empty struct
 		return State{}, nil
@@ -68,7 +73,7 @@ func (s *State) Save(path string) error {
 	if err := os.MkdirAll(filepath.Dir(path), 0700); err != nil {
 		return fmt.Errorf("creating directory for state file: %w", err)
 	}
-	if err := ioutil.WriteFile(path, data, 0600); err != nil {
+	if err := os.WriteFile(path, data, 0600); err != nil {
 		return fmt.Errorf("writing state file: %w", err)
 	}
 	return nil
diff --git a/internal/systemd/systemd.go b/internal/systemd/systemd.go
index c3dfb58d..75f7ecad 100644
--- a/internal/systemd/systemd.go
+++ b/internal/systemd/systemd.go
@@ -15,6 +15,7 @@
 package systemd
 
 import (
+	"context"
 	"fmt"
 	"regexp"
 	"strconv"
@@ -24,8 +25,8 @@ import (
 )
 
 // WaitOnDevices waits for the devices named in devs to be plugged before returning.
-func WaitOnDevices(devs []string, stage string) error {
-	conn, err := dbus.NewSystemdConnection()
+func WaitOnDevices(ctx context.Context, devs []string, stage string) error {
+	conn, err := dbus.NewSystemdConnectionContext(ctx)
 	if err != nil {
 		return err
 	}
@@ -35,7 +36,7 @@ func WaitOnDevices(devs []string, stage string) error {
 		unitName := unit.UnitNamePathEscape(dev + ".device")
 		results[unitName] = make(chan string, 1)
 
-		if _, err = conn.StartUnit(unitName, "replace", results[unitName]); err != nil {
+		if _, err = conn.StartUnitContext(ctx, unitName, "replace", results[unitName]); err != nil {
 			return fmt.Errorf("failed starting device unit %s: %v", unitName, err)
 		}
 	}
@@ -53,8 +54,8 @@ func WaitOnDevices(devs []string, stage string) error {
 
 // GetSystemdVersion fetches the version of Systemd
 // in a given system.
-func GetSystemdVersion() (uint, error) {
-	conn, err := dbus.NewSystemdConnection()
+func GetSystemdVersion(ctx context.Context) (uint, error) {
+	conn, err := dbus.NewSystemdConnectionContext(ctx)
 	if err != nil {
 		return 0, err
 	}
diff --git a/internal/util/tools/docs/docs.go b/internal/util/tools/docs/docs.go
index a5dd8abf..ca65069a 100644
--- a/internal/util/tools/docs/docs.go
+++ b/internal/util/tools/docs/docs.go
@@ -20,7 +20,6 @@ package main
 import (
 	"flag"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"path/filepath"
 	"strings"
@@ -70,7 +69,7 @@ func main() {
 			return nil
 		}
 
-		fileContents, err := ioutil.ReadFile(path)
+		fileContents, err := os.ReadFile(path)
 		if err != nil {
 			return err
 		}
diff --git a/internal/util/verification.go b/internal/util/verification.go
index 26e3f9cc..8f37f550 100644
--- a/internal/util/verification.go
+++ b/internal/util/verification.go
@@ -23,7 +23,7 @@ import (
 	"hash"
 	"strings"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 )
 
 var (
diff --git a/internal/util/verification_test.go b/internal/util/verification_test.go
index fd9132c0..abac5177 100644
--- a/internal/util/verification_test.go
+++ b/internal/util/verification_test.go
@@ -18,7 +18,7 @@ import (
 	"reflect"
 	"testing"
 
-	"github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	"github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 )
 
 func TestAssertValid(t *testing.T) {
diff --git a/signing-ticket.sh b/signing-ticket.sh
new file mode 100755
index 00000000..2e6b0a34
--- /dev/null
+++ b/signing-ticket.sh
@@ -0,0 +1,130 @@
+#!/bin/bash
+# Script for generating Fedora releng release signing tickets.  Generated by
+# https://github.com/coreos/repo-templates; do not edit downstream.
+
+set -euo pipefail
+
+usage() {
+    echo "Usage: $0 test <version-release> <dir>"
+    echo "Usage: $0 ticket <version-release>"
+    exit 1
+}
+
+make_script() {
+    sed -e "s/@@VERSION@@/$ver/g" -e "s/@@RELEASE@@/$rel/g" <<'EOF'
+#!/bin/bash
+set -eux -o pipefail
+
+# Use the Fedora 39 key for the detached signatures
+KEYTOSIGNWITH='fedora-39'
+
+VR='@@VERSION@@-@@RELEASE@@.fc39'
+RPMKEY='18b8e74c' # Fedora 39 key
+
+do_sign() {
+    # Sign with sigul unless FAKESIGN=1
+    if [ ${FAKESIGN:-0} != 1 ]; then
+        sigul sign-data -a $KEYTOSIGNWITH "$1" -o "$1.asc"
+    else
+        echo INVALID > "$1.asc"
+    fi
+}
+
+# Grab the binaries out of the redistributable rpm
+rpm="ignition-validate-redistributable-${VR}.noarch.rpm"
+koji download-build --key $RPMKEY --rpm $rpm
+rpm -qip $rpm | grep -P "^Signature.*${RPMKEY}$" # Verify the output has the key in it
+rpm2cpio $rpm | cpio -idv './usr/share/ignition/ignition-validate-*'
+
+# Rename the binaries
+mv usr/share/ignition/ignition-validate-aarch64-apple-darwin \
+    ignition-validate-aarch64-apple-darwin
+mv usr/share/ignition/ignition-validate-aarch64-unknown-linux-gnu-static \
+    ignition-validate-aarch64-linux
+mv usr/share/ignition/ignition-validate-ppc64le-unknown-linux-gnu-static \
+    ignition-validate-ppc64le-linux
+mv usr/share/ignition/ignition-validate-s390x-unknown-linux-gnu-static \
+    ignition-validate-s390x-linux
+mv usr/share/ignition/ignition-validate-x86_64-apple-darwin \
+    ignition-validate-x86_64-apple-darwin
+mv usr/share/ignition/ignition-validate-x86_64-pc-windows-gnu.exe \
+    ignition-validate-x86_64-pc-windows-gnu.exe
+mv usr/share/ignition/ignition-validate-x86_64-unknown-linux-gnu-static \
+    ignition-validate-x86_64-linux
+
+# Sign them
+do_sign ignition-validate-aarch64-apple-darwin
+do_sign ignition-validate-aarch64-linux
+do_sign ignition-validate-ppc64le-linux
+do_sign ignition-validate-s390x-linux
+do_sign ignition-validate-x86_64-apple-darwin
+do_sign ignition-validate-x86_64-pc-windows-gnu.exe
+do_sign ignition-validate-x86_64-linux
+
+# Fix permissions and clean up
+chmod go+r *.asc
+rm $rpm; rmdir ./usr/share/ignition; rmdir ./usr/share; rmdir ./usr
+EOF
+}
+
+make_ticket() {
+    sed "s/@@VERSION@@/$ver/g" <<'EOF'
+TITLE: Create detached signatures for the ignition @@VERSION@@ release
+
+Please create detached signatures for the binaries we will upload to GitHub for the `ignition` @@VERSION@@ release.  This is a manual process for now, pending the automation discussed in https://pagure.io/robosignatory/issue/53 and https://github.com/coreos/fedora-coreos-tracker/issues/335.
+
+The binaries themselves have been built in koji.  Here is a small script to grab all of the rpms and the files out of the rpms and name them appropriately:
+
+```
+EOF
+    make_script
+    cat <<'EOF'
+```
+
+After running this you should end up with a directory with files in it like:
+
+```
+$ ls -1
+ignition-validate-aarch64-apple-darwin
+ignition-validate-aarch64-apple-darwin.asc
+ignition-validate-aarch64-linux
+ignition-validate-aarch64-linux.asc
+ignition-validate-ppc64le-linux
+ignition-validate-ppc64le-linux.asc
+ignition-validate-s390x-linux
+ignition-validate-s390x-linux.asc
+ignition-validate-x86_64-apple-darwin
+ignition-validate-x86_64-apple-darwin.asc
+ignition-validate-x86_64-linux
+ignition-validate-x86_64-linux.asc
+ignition-validate-x86_64-pc-windows-gnu.exe
+ignition-validate-x86_64-pc-windows-gnu.exe.asc
+```
+EOF
+}
+
+[ "$#" -lt 2 ] && usage
+cmd="$1"
+ver="$2"
+# Disallow version with preceding "v"
+echo "$ver" | grep -q "v" && usage
+# Require version-release
+echo "$ver" | grep -q "-" || usage
+rel="${ver#*-}"
+ver="${ver%%-*}"
+
+case "$cmd" in
+test)
+    [ "$#" != 3 ] && usage
+    dir="$3"
+    mkdir "$dir"
+    make_script > "$dir/script"
+    cd "$dir" && FAKESIGN=1 bash script
+    ;;
+ticket)
+    make_ticket
+    ;;
+*)
+    usage
+    ;;
+esac
diff --git a/tag_release.sh b/tag_release.sh
index fd518671..898c2ce9 100755
--- a/tag_release.sh
+++ b/tag_release.sh
@@ -1,8 +1,10 @@
 #!/usr/bin/env bash
+# Maintained in https://github.com/coreos/repo-templates
+# Do not edit downstream.
 
 set -e
 
-[ $# == 2 ] || { echo "usage: $0 version commit" && exit 1; }
+[ $# == 2 ] || { echo "usage: $0 <version> <commit>" && exit 1; }
 
 VER=$1
 COMMIT=$2
@@ -17,14 +19,11 @@ COMMIT=$2
 	exit 3
 }
 
-source ./build
-
-# TODO(vc): generate NEWS as part of the release process.
-# @marineam suggested using git notes to associate NEWS-destined payloads
-# with objects, we just need to define a syntax and employ them.
-# I would like to be able to write the NEWS annotation as part of the commit message,
-# while still having it go into a note.
+if [ -f Makefile ]; then
+	make
+else
+	./build
+fi
 
 git tag --sign --message "Ignition ${VER}" "${VER}" "${COMMIT}"
-
 git verify-tag --verbose "${VER}"
diff --git a/test b/test
index 15f783e5..d0be5e62 100755
--- a/test
+++ b/test
@@ -58,15 +58,15 @@ go vet $PKG_VET
 
 echo "Running tests..."
 if [ "$GOARCH" == amd64 ]; then
-	go test -timeout 60s -cover $@ ${PKG} --race
+	go test -timeout 60s -cover "${@}" ${PKG} --race
 else
-	go test -timeout 60s -cover $@ ${PKG}
+	go test -timeout 60s -cover "${@}" ${PKG}
 fi
 
 echo "Checking docs..."
 go run internal/util/tools/docs/docs.go
 # Ensure every platform is listed in supported-platforms.md
-platforms=$(grep -A 1 configs.Register internal/platform/platform.go | grep name: | cut -f2 -d\")
+platforms=$(grep -A 1 -h platform.Register internal/providers/*/* | grep Name: | cut -f2 -d\")
 if [ -z "${platforms}" ]; then
     echo "Found no platform IDs; update $0" >&2
     exit 1
diff --git a/tests/blackbox_test.go b/tests/blackbox_test.go
index b7c240fe..086d6566 100644
--- a/tests/blackbox_test.go
+++ b/tests/blackbox_test.go
@@ -18,7 +18,6 @@ import (
 	"context"
 	"flag"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"os/signal"
 	"path/filepath"
@@ -128,7 +127,7 @@ func outer(t *testing.T, test types.Test, negativeTests bool) error {
 	ctx, cancelFunc := context.WithDeadline(killContext, time.Now().Add(testTimeout))
 	defer cancelFunc()
 
-	tmpDirectory, err := ioutil.TempDir("/var/tmp", "ignition-blackbox-")
+	tmpDirectory, err := os.MkdirTemp("/var/tmp", "ignition-blackbox-")
 	if err != nil {
 		return fmt.Errorf("failed to create a temp dir: %v", err)
 	}
@@ -270,7 +269,7 @@ func outer(t *testing.T, test types.Test, negativeTests bool) error {
 	}
 
 	// Ignition config
-	if err := ioutil.WriteFile(filepath.Join(tmpDirectory, "config.ign"), []byte(test.Config), 0666); err != nil {
+	if err := os.WriteFile(filepath.Join(tmpDirectory, "config.ign"), []byte(test.Config), 0666); err != nil {
 		return fmt.Errorf("error writing config: %v", err)
 	}
 
@@ -279,11 +278,11 @@ func outer(t *testing.T, test types.Test, negativeTests bool) error {
 	appendEnv = append(appendEnv, "IGNITION_SYSTEM_CONFIG_DIR="+systemConfigDir)
 
 	if !negativeTests {
-		if err := runIgnition(t, ctx, "fetch", "", tmpDirectory, appendEnv); err != nil {
+		if err := runIgnition(t, ctx, "fetch", "", tmpDirectory, appendEnv, test.SkipCriticalCheck); err != nil {
 			return err
 		}
 
-		if err := runIgnition(t, ctx, "disks", "", tmpDirectory, appendEnv); err != nil {
+		if err := runIgnition(t, ctx, "disks", "", tmpDirectory, appendEnv, test.SkipCriticalCheck); err != nil {
 			return err
 		}
 
@@ -291,12 +290,12 @@ func outer(t *testing.T, test types.Test, negativeTests bool) error {
 			return err
 		}
 
-		if err := runIgnition(t, ctx, "mount", rootPartition.MountPath, tmpDirectory, appendEnv); err != nil {
+		if err := runIgnition(t, ctx, "mount", rootPartition.MountPath, tmpDirectory, appendEnv, test.SkipCriticalCheck); err != nil {
 			return err
 		}
 
-		filesErr := runIgnition(t, ctx, "files", rootPartition.MountPath, tmpDirectory, appendEnv)
-		if err := runIgnition(t, ctx, "umount", rootPartition.MountPath, tmpDirectory, appendEnv); err != nil {
+		filesErr := runIgnition(t, ctx, "files", rootPartition.MountPath, tmpDirectory, appendEnv, test.SkipCriticalCheck)
+		if err := runIgnition(t, ctx, "umount", rootPartition.MountPath, tmpDirectory, appendEnv, test.SkipCriticalCheck); err != nil {
 			return err
 		}
 		if err := umountPartition(rootPartition); err != nil {
@@ -319,11 +318,11 @@ func outer(t *testing.T, test types.Test, negativeTests bool) error {
 		}
 		return nil
 	} else {
-		if err := runIgnition(t, ctx, "fetch", "", tmpDirectory, appendEnv); err != nil {
+		if err := runIgnition(t, ctx, "fetch", "", tmpDirectory, appendEnv, test.SkipCriticalCheck); err != nil {
 			return nil // error is expected
 		}
 
-		if err := runIgnition(t, ctx, "disks", "", tmpDirectory, appendEnv); err != nil {
+		if err := runIgnition(t, ctx, "disks", "", tmpDirectory, appendEnv, test.SkipCriticalCheck); err != nil {
 			return nil // error is expected
 		}
 
@@ -331,12 +330,12 @@ func outer(t *testing.T, test types.Test, negativeTests bool) error {
 			return err
 		}
 
-		if err := runIgnition(t, ctx, "mount", rootPartition.MountPath, tmpDirectory, appendEnv); err != nil {
+		if err := runIgnition(t, ctx, "mount", rootPartition.MountPath, tmpDirectory, appendEnv, test.SkipCriticalCheck); err != nil {
 			return nil // error is expected
 		}
 
-		filesErr := runIgnition(t, ctx, "files", rootPartition.MountPath, tmpDirectory, appendEnv)
-		if err := runIgnition(t, ctx, "umount", rootPartition.MountPath, tmpDirectory, appendEnv); err != nil {
+		filesErr := runIgnition(t, ctx, "files", rootPartition.MountPath, tmpDirectory, appendEnv, test.SkipCriticalCheck)
+		if err := runIgnition(t, ctx, "umount", rootPartition.MountPath, tmpDirectory, appendEnv, test.SkipCriticalCheck); err != nil {
 			return nil
 		}
 		if err := umountPartition(rootPartition); err != nil {
diff --git a/tests/filesystem.go b/tests/filesystem.go
index fa16c44b..2d9c676b 100644
--- a/tests/filesystem.go
+++ b/tests/filesystem.go
@@ -19,6 +19,7 @@ import (
 	"bytes"
 	"compress/bzip2"
 	"context"
+	"crypto/rand"
 	"encoding/base64"
 	"fmt"
 	"io"
@@ -115,7 +116,7 @@ func umountPartition(p *types.Partition) error {
 }
 
 // returns true if no error, false if error
-func runIgnition(t *testing.T, ctx context.Context, stage, root, cwd string, appendEnv []string) error {
+func runIgnition(t *testing.T, ctx context.Context, stage, root, cwd string, appendEnv []string, skipCriticalCheck bool) error {
 	args := []string{"-platform", "file", "-stage", stage,
 		"-root", root, "-log-to-stdout",
 		"-config-cache", filepath.Join(cwd, "ignition.json"),
@@ -140,7 +141,7 @@ func runIgnition(t *testing.T, ctx context.Context, stage, root, cwd string, app
 	if strings.Contains(string(out), "panic") {
 		return fmt.Errorf("ignition panicked")
 	}
-	if strings.Contains(string(out), "CRITICAL") {
+	if !skipCriticalCheck && strings.Contains(string(out), "CRITICAL") {
 		return fmt.Errorf("found critical ignition log")
 	}
 	return err
@@ -226,6 +227,22 @@ func setupDisk(ctx context.Context, disk *types.Disk, diskIndex int, imageSize i
 			return err
 		}
 	}
+
+	if disk.CorruptTable {
+		bytes := make([]byte, 1536)
+		if _, err := rand.Read(bytes); err != nil {
+			return err
+		}
+		f, err := os.OpenFile(disk.ImageFile, os.O_WRONLY, 0666)
+		if err != nil {
+			return err
+		}
+		if _, err := f.Write(bytes); err != nil {
+			return err
+		}
+		defer f.Close()
+	}
+
 	return nil
 }
 
diff --git a/tests/negative/general/config.go b/tests/negative/general/config.go
index 3116e331..481cc2cd 100644
--- a/tests/negative/general/config.go
+++ b/tests/negative/general/config.go
@@ -281,12 +281,12 @@ func VersionOnlyConfig25() types.Test {
 }
 
 func VersionOnlyConfig35() types.Test {
-	name := "config.versions.3.5.0-exp"
+	name := "config.versions.3.6.0-exp"
 	in := types.GetBaseDisk()
 	out := in
 	config := `{
 	  "ignition": {
-	    "version": "3.5.0-experimental"
+	    "version": "3.6.0-experimental"
 	  }
 	}`
 
diff --git a/tests/negative/security/tls.go b/tests/negative/security/tls.go
index 0df69e7b..83149e89 100644
--- a/tests/negative/security/tls.go
+++ b/tests/negative/security/tls.go
@@ -17,7 +17,7 @@ package security
 import (
 	"crypto/tls"
 	"fmt"
-	"io/ioutil"
+	"io"
 	"log"
 	"net/http"
 	"net/http/httptest"
@@ -34,7 +34,7 @@ func init() {
 	}
 	config := &tls.Config{Certificates: []tls.Certificate{cer}}
 	customCAServer.TLS = config
-	customCAServer.Config.ErrorLog = log.New(ioutil.Discard, "", 0)
+	customCAServer.Config.ErrorLog = log.New(io.Discard, "", 0)
 	customCAServer.StartTLS()
 
 	cer2, err := tls.X509KeyPair(fixtures.PublicKey2, fixtures.PrivateKey2)
@@ -43,7 +43,7 @@ func init() {
 	}
 	config2 := &tls.Config{Certificates: []tls.Certificate{cer2}}
 	customCAServer2.TLS = config2
-	customCAServer2.Config.ErrorLog = log.New(ioutil.Discard, "", 0)
+	customCAServer2.Config.ErrorLog = log.New(io.Discard, "", 0)
 	customCAServer2.StartTLS()
 
 	register.Register(register.NegativeTest, AppendConfigCustomCert())
diff --git a/tests/positive/files/units.go b/tests/positive/files/units.go
index b8974479..03e24ea7 100644
--- a/tests/positive/files/units.go
+++ b/tests/positive/files/units.go
@@ -25,6 +25,7 @@ func init() {
 	register.Register(register.PositiveTest, TestUnmaskUnit())
 	register.Register(register.PositiveTest, TestMaskUnit())
 	register.Register(register.PositiveTest, RemoveEnablementSymLinksforUnit())
+	register.Register(register.PositiveTest, TestPresetsFileInAlphabeticalOrder())
 }
 
 func CreateInstantiatedService() types.Test {
@@ -320,3 +321,57 @@ func RemoveEnablementSymLinksforUnit() types.Test {
 		ConfigMinVersion: configMinVersion,
 	}
 }
+
+// TestPresetsFileinAlphabeticalOrder checks if Ignition
+// writes the systemd presets in alphabetical order by
+// unit name into the 20-ignition.preset file.
+func TestPresetsFileInAlphabeticalOrder() types.Test {
+	name := "unit.presets.sorted"
+	in := types.GetBaseDisk()
+	out := types.GetBaseDisk()
+	config := `{
+		"ignition": { "version": "$version" },
+		"systemd": {
+			"units": [
+				{
+					"enabled": true,
+					"name": "foo.service"
+				},
+				{
+					"enabled": true,
+					"name": "bar.service"
+				},
+				{
+					"enabled": true,
+					"name": "qux.service"
+				},
+				{
+					"enabled": true,
+					"name": "baz.service"
+				},
+				{
+					"enabled": true,
+					"name": "garply.service"
+				}
+			]
+        }
+		}`
+	out[0].Partitions.AddFiles("ROOT", []types.File{
+		{
+			Node: types.Node{
+				Name:      "20-ignition.preset",
+				Directory: "etc/systemd/system-preset",
+			},
+			Contents: "enable bar.service\nenable baz.service\nenable foo.service\nenable garply.service\nenable qux.service\n",
+		},
+	})
+	configMinVersion := "3.0.0"
+
+	return types.Test{
+		Name:             name,
+		In:               in,
+		Out:              out,
+		Config:           config,
+		ConfigMinVersion: configMinVersion,
+	}
+}
diff --git a/tests/positive/filesystems/creation.go b/tests/positive/filesystems/creation.go
index b0f058ee..45741945 100644
--- a/tests/positive/filesystems/creation.go
+++ b/tests/positive/filesystems/creation.go
@@ -190,7 +190,7 @@ func FilesystemCreationOnMultipleDisks() types.Test {
 					Label:          label,
 					Number:         1,
 					Length:         65536,
-					FilesystemType: "xfs",
+					FilesystemType: "ext4",
 				},
 			},
 		})
@@ -208,25 +208,25 @@ func FilesystemCreationOnMultipleDisks() types.Test {
 				{
 					"path": "/tmp-0",
 					"device": "$dev0",
-					"format": "xfs",
+					"format": "ext4",
 					"label": "data-0"
 				},
 				{
 					"path": "/tmp-1",
 					"device": "$dev1",
-					"format": "xfs",
+					"format": "ext4",
 					"label": "data-1"
 				},
 				{
 					"path": "/tmp-2",
 					"device": "$dev2",
-					"format": "xfs",
+					"format": "ext4",
 					"label": "data-2"
 				},
 				{
 					"path": "/tmp-3",
 					"device": "$dev3",
-					"format": "xfs",
+					"format": "ext4",
 					"label": "data-3"
 				}
 			]
diff --git a/tests/positive/filesystems/reformat_filesystem.go b/tests/positive/filesystems/reformat_filesystem.go
index 6e58db70..ffa57b10 100644
--- a/tests/positive/filesystems/reformat_filesystem.go
+++ b/tests/positive/filesystems/reformat_filesystem.go
@@ -76,6 +76,9 @@ func ReformatToXFS() types.Test {
 			Substitution: "$DEVICE",
 		},
 	}
+	// mkfs.xfs >= 5.19 requires --unsupported to create filesystems
+	// smaller than 300 MB
+	// https://git.kernel.org/pub/scm/fs/xfs/xfsprogs-dev.git/commit/?id=6e0ed3d19c54603f0f7d628ea04b550151d8a262
 	config := `{
 	  "ignition": { "version": "$version" },
 	  "storage": {
@@ -85,7 +88,8 @@ func ReformatToXFS() types.Test {
 	      "format": "xfs",
 	      "label": "OEM",
 	      "uuid": "$uuid0",
-	      "wipeFilesystem": true
+	      "wipeFilesystem": true,
+	      "options": ["--unsupported"]
 	    }]
 	  }
 	}`
@@ -317,6 +321,9 @@ func TestXFSClobberZFS() types.Test {
 			Substitution: "$DEVICE",
 		},
 	}
+	// mkfs.xfs >= 5.19 requires --unsupported to create filesystems
+	// smaller than 300 MB
+	// https://git.kernel.org/pub/scm/fs/xfs/xfsprogs-dev.git/commit/?id=6e0ed3d19c54603f0f7d628ea04b550151d8a262
 	config := `{
 	  "ignition": { "version": "$version" },
 	  "storage": {
@@ -324,7 +331,7 @@ func TestXFSClobberZFS() types.Test {
 	      "path": "/tmp0",
 	      "device": "$DEVICE",
 	      "format": "xfs",
-	      "options": ["-K"],
+	      "options": ["-K", "--unsupported"],
 	      "wipeFilesystem": true
 	    }]
 	  }
diff --git a/tests/positive/partitions/wipe.go b/tests/positive/partitions/wipe.go
new file mode 100644
index 00000000..da8b34bf
--- /dev/null
+++ b/tests/positive/partitions/wipe.go
@@ -0,0 +1,65 @@
+// Copyright 2023 CoreOS, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package partitions
+
+import (
+	"github.com/coreos/ignition/v2/tests/register"
+	"github.com/coreos/ignition/v2/tests/types"
+)
+
+func init() {
+	// Tests that wipe tables
+	register.Register(register.PositiveTest, WipeBadTable())
+}
+
+func WipeBadTable() types.Test {
+	name := "partition.wipebadtable"
+	in := append(types.GetBaseDisk(), types.Disk{
+		Alignment: types.IgnitionAlignment,
+		Partitions: types.Partitions{
+			{
+				Label:  "deleteme",
+				Number: 1,
+				Length: 65536,
+			},
+		},
+		CorruptTable: true,
+	})
+	out := append(types.GetBaseDisk(), types.Disk{Alignment: types.IgnitionAlignment})
+	config := `{
+		"ignition": {
+			"version": "$version"
+		},
+		"storage": {
+			"disks": [
+			{
+				"device": "$disk1",
+				"wipeTable": true
+			}
+			]
+		}
+	}`
+	configMinVersion := "3.0.0"
+
+	return types.Test{
+		Name:             name,
+		In:               in,
+		Out:              out,
+		Config:           config,
+		ConfigMinVersion: configMinVersion,
+		// the first `sgdisk --zap-all` is expected to fail
+		SkipCriticalCheck: true,
+	}
+}
diff --git a/tests/register/register.go b/tests/register/register.go
index c6ae2d64..07e803b7 100644
--- a/tests/register/register.go
+++ b/tests/register/register.go
@@ -20,7 +20,8 @@ import (
 	types31 "github.com/coreos/ignition/v2/config/v3_1/types"
 	types32 "github.com/coreos/ignition/v2/config/v3_2/types"
 	types33 "github.com/coreos/ignition/v2/config/v3_3/types"
-	types_exp "github.com/coreos/ignition/v2/config/v3_4_experimental/types"
+	types34 "github.com/coreos/ignition/v2/config/v3_4/types"
+	types_exp "github.com/coreos/ignition/v2/config/v3_5_experimental/types"
 	"github.com/coreos/ignition/v2/tests/types"
 )
 
@@ -49,7 +50,7 @@ func Register(tType TestType, t types.Test) {
 		{semver.Version{}}, // place holder 0
 		{semver.Version{}}, // place holder 1
 		{semver.Version{}}, // place holder 2
-		{types30.MaxVersion, types31.MaxVersion, types32.MaxVersion, types33.MaxVersion, types_exp.MaxVersion},
+		{types30.MaxVersion, types31.MaxVersion, types32.MaxVersion, types33.MaxVersion, types34.MaxVersion, types_exp.MaxVersion},
 	}
 
 	test := types.DeepCopy(t)
diff --git a/tests/servers/servers.go b/tests/servers/servers.go
index 4082c2e4..6aa688b8 100644
--- a/tests/servers/servers.go
+++ b/tests/servers/servers.go
@@ -110,7 +110,7 @@ func headerCheck(w http.ResponseWriter, r *http.Request) {
 	headers := map[string]string{
 		"X-Auth":          "r8ewap98gfh4d8",
 		"Keep-Alive":      "300",
-		"Accept":          "application/vnd.coreos.ignition+json;version=3.3.0, */*;q=0.1",
+		"Accept":          "application/vnd.coreos.ignition+json;version=3.4.0, */*;q=0.1",
 		"Accept-Encoding": "identity",
 	}
 
diff --git a/tests/stubs/groupdel-stub/main.go b/tests/stubs/groupdel-stub/main.go
index 130b7ea9..3b36bf1e 100644
--- a/tests/stubs/groupdel-stub/main.go
+++ b/tests/stubs/groupdel-stub/main.go
@@ -17,7 +17,6 @@ package main
 import (
 	"flag"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"path"
 	"strings"
@@ -39,7 +38,7 @@ func main() {
 
 	groupname := flag.Args()[0]
 
-	groupContents, err := ioutil.ReadFile(path.Join(flagRoot, "/etc/group"))
+	groupContents, err := os.ReadFile(path.Join(flagRoot, "/etc/group"))
 	if err != nil {
 		fmt.Printf("couldn't open /etc/group: %v\n", err)
 		os.Exit(1)
@@ -60,7 +59,7 @@ func main() {
 		os.Exit(1)
 	}
 
-	gshadowContents, err := ioutil.ReadFile(path.Join(flagRoot, "/etc/gshadow"))
+	gshadowContents, err := os.ReadFile(path.Join(flagRoot, "/etc/gshadow"))
 	if err != nil {
 		fmt.Printf("couldn't open /etc/gshadow: %v\n", err)
 		os.Exit(1)
diff --git a/tests/stubs/useradd-stub/main.go b/tests/stubs/useradd-stub/main.go
index 089212c9..fe5a3fab 100644
--- a/tests/stubs/useradd-stub/main.go
+++ b/tests/stubs/useradd-stub/main.go
@@ -17,7 +17,6 @@ package main
 import (
 	"flag"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"path"
 	"strconv"
@@ -164,7 +163,7 @@ func main() {
 func getNextUidAndGid() (int, error) {
 	idMap := make(map[int]struct{})
 
-	passwdContents, err := ioutil.ReadFile(path.Join(flagRoot, "/etc/passwd"))
+	passwdContents, err := os.ReadFile(path.Join(flagRoot, "/etc/passwd"))
 	if err != nil {
 		return -1, err
 	}
@@ -188,7 +187,7 @@ func getNextUidAndGid() (int, error) {
 		idMap[int(gid)] = struct{}{}
 	}
 
-	groupContents, err := ioutil.ReadFile(path.Join(flagRoot, "/etc/group"))
+	groupContents, err := os.ReadFile(path.Join(flagRoot, "/etc/group"))
 	if err != nil {
 		return -1, err
 	}
diff --git a/tests/stubs/userdel-stub/main.go b/tests/stubs/userdel-stub/main.go
index 8470e558..93c2da26 100644
--- a/tests/stubs/userdel-stub/main.go
+++ b/tests/stubs/userdel-stub/main.go
@@ -17,7 +17,6 @@ package main
 import (
 	"flag"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"path"
 	"strings"
@@ -41,7 +40,7 @@ func main() {
 
 	username := flag.Args()[0]
 
-	passwdContents, err := ioutil.ReadFile(path.Join(flagRoot, "/etc/passwd"))
+	passwdContents, err := os.ReadFile(path.Join(flagRoot, "/etc/passwd"))
 	if err != nil {
 		fmt.Printf("couldn't open /etc/passwd: %v\n", err)
 		os.Exit(1)
@@ -64,7 +63,7 @@ func main() {
 		os.Exit(1)
 	}
 
-	groupContents, err := ioutil.ReadFile(path.Join(flagRoot, "/etc/group"))
+	groupContents, err := os.ReadFile(path.Join(flagRoot, "/etc/group"))
 	if err != nil {
 		fmt.Printf("couldn't open /etc/group: %v\n", err)
 		os.Exit(1)
@@ -87,7 +86,7 @@ func main() {
 		os.Exit(1)
 	}
 
-	shadowContents, err := ioutil.ReadFile(path.Join(flagRoot, "/etc/shadow"))
+	shadowContents, err := os.ReadFile(path.Join(flagRoot, "/etc/shadow"))
 	if err != nil {
 		fmt.Printf("couldn't open /etc/shadow: %v\n", err)
 		os.Exit(1)
@@ -110,7 +109,7 @@ func main() {
 		os.Exit(1)
 	}
 
-	gshadowContents, err := ioutil.ReadFile(path.Join(flagRoot, "/etc/gshadow"))
+	gshadowContents, err := os.ReadFile(path.Join(flagRoot, "/etc/gshadow"))
 	if err != nil {
 		fmt.Printf("couldn't open /etc/gshadow: %v\n", err)
 		os.Exit(1)
diff --git a/tests/stubs/usermod-stub/main.go b/tests/stubs/usermod-stub/main.go
index 795b3713..be868255 100644
--- a/tests/stubs/usermod-stub/main.go
+++ b/tests/stubs/usermod-stub/main.go
@@ -17,7 +17,6 @@ package main
 import (
 	"flag"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"path"
 	"strconv"
@@ -58,7 +57,7 @@ func main() {
 
 	username := flag.Args()[0]
 
-	passwdContents, err := ioutil.ReadFile(path.Join(flagRoot, "/etc/passwd"))
+	passwdContents, err := os.ReadFile(path.Join(flagRoot, "/etc/passwd"))
 	if err != nil {
 		fmt.Printf("couldn't open /etc/passwd: %v\n", err)
 		os.Exit(1)
diff --git a/tests/types/types.go b/tests/types/types.go
index d5bd3fe7..46de2bfa 100644
--- a/tests/types/types.go
+++ b/tests/types/types.go
@@ -57,10 +57,11 @@ type Node struct {
 }
 
 type Disk struct {
-	ImageFile  string
-	Device     string
-	Alignment  int
-	Partitions Partitions
+	ImageFile    string
+	Device       string
+	Alignment    int
+	Partitions   Partitions
+	CorruptTable bool // set to true to corrupt the partition table
 }
 
 type Partitions []*Partition
@@ -103,6 +104,7 @@ type Test struct {
 	ConfigMinVersion  string
 	ConfigVersion     string
 	ConfigShouldBeBad bool // Set to true to skip config validation step
+	SkipCriticalCheck bool // Set to true to skip critical logging check
 }
 
 func (ps Partitions) GetPartition(label string) *Partition {
diff --git a/tests/validator.go b/tests/validator.go
index 6256ace8..d64957db 100644
--- a/tests/validator.go
+++ b/tests/validator.go
@@ -17,7 +17,6 @@ package blackbox
 import (
 	"context"
 	"fmt"
-	"io/ioutil"
 	"os"
 	"os/exec"
 	"path/filepath"
@@ -223,7 +222,7 @@ func validateFile(t *testing.T, partition *types.Partition, file types.File) {
 		return
 	}
 	if file.Contents != "" {
-		dat, err := ioutil.ReadFile(path)
+		dat, err := os.ReadFile(path)
 		if err != nil {
 			t.Error("Error when reading file", path)
 			return
diff --git a/validate/main.go b/validate/main.go
index 3ac03d7c..bec64866 100644
--- a/validate/main.go
+++ b/validate/main.go
@@ -17,7 +17,7 @@ package main
 import (
 	"flag"
 	"fmt"
-	"io/ioutil"
+	"io"
 	"os"
 	"strings"
 
@@ -69,9 +69,9 @@ func runIgnValidate(args []string) {
 	var blob []byte
 	var err error
 	if args[0] == "-" {
-		blob, err = ioutil.ReadAll(os.Stdin)
+		blob, err = io.ReadAll(os.Stdin)
 	} else {
-		blob, err = ioutil.ReadFile(args[0])
+		blob, err = os.ReadFile(args[0])
 	}
 	if err != nil {
 		die("couldn't read config: %v", err)
